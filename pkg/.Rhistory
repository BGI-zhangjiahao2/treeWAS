[snps.loci.unique[[i]][e]])]))
## if any loci are selected for multiple mutations
## within their given branch length:
if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){
## identify which loci are repeaters
repeats <- table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]
## how many times they repeat
n.reps <- repeats - 1
## the positions of these loci in the vector of snps loci
toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))
## run chain of re-sampling to end in our new nt for repeater loci:
foo <- list()
for(j in 1:length(toRepeat)){
foo[[j]] <- new.nts[[i]][toRepeat[j]]
for(k in 1:n.reps[j]){
if(k==1){
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][1])])
}else{
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][k-1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][k-1])])
}
}
## retain only the last nt selected
out <- sapply(c(1:length(foo)),
function(e) foo[[e]][length(foo[[e]])])
}
## for the loci with repeated mts, replace these positions
## in new.nts with the corresponding elements of out, above.
new.nts[[i]][toRepeat] <- out
} # end of if statement for repeaters
## update ancestral genotype with new.nts:
temp <- snps[[tree$edge[i,1]]]
temp[snps.loci.unique[[i]]] <- new.nts[[i]]
snps[[tree$edge[i,2]]] <- temp
}else{
## if no mts occur on branch, set genotype of
## downstream individual to be equal to ancestor's
snps[[tree$edge[i,2]]] <- snps[[tree$edge[i,1]]]
}
} # end of for loop selecting new nts at mutator loci
f <- FALSE
f == "a"
source('~/treeWAS/pkg/R/utils.R')
#############################
## For Loop to get new nts ##
#############################
for(i in x){
## for all snps other than root, we mutate the
## genome of the node preceding it, according to snps.loci.
## Draw new nts for each locus selected for mutation:
if(!.is.integer0(snps.loci.unique[[i]])){
# new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)
#   selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                  %in% snps[[tree$edge[i,1]]]
#                                                  [snps.loci.unique[[i]][e]])]))
new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)
selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% snps[[tree$edge[i,1]]]
[snps.loci.unique[[i]][e]])]))
## if any loci are selected for multiple mutations
## within their given branch length:
if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){
## identify which loci are repeaters
repeats <- table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]
## how many times they repeat
n.reps <- repeats - 1
## the positions of these loci in the vector of snps loci
toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))
## run chain of re-sampling to end in our new nt for repeater loci:
foo <- list()
for(j in 1:length(toRepeat)){
foo[[j]] <- new.nts[[i]][toRepeat[j]]
for(k in 1:n.reps[j]){
if(k==1){
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][1])])
}else{
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][k-1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][k-1])])
}
}
## retain only the last nt selected
out <- sapply(c(1:length(foo)),
function(e) foo[[e]][length(foo[[e]])])
}
## for the loci with repeated mts, replace these positions
## in new.nts with the corresponding elements of out, above.
new.nts[[i]][toRepeat] <- out
} # end of if statement for repeaters
## update ancestral genotype with new.nts:
temp <- snps[[tree$edge[i,1]]]
temp[snps.loci.unique[[i]]] <- new.nts[[i]]
snps[[tree$edge[i,2]]] <- temp
}else{
## if no mts occur on branch, set genotype of
## downstream individual to be equal to ancestor's
snps[[tree$edge[i,2]]] <- snps[[tree$edge[i,1]]]
}
} # end of for loop selecting new nts at mutator loci
object.size(new.nts)
object.size(temp)
object.size(snps)
object.size(foo)
temp <- do.call("rbind", snps)
temp <- temp[1:n.ind, ]
object.size(temp)
polyThres <- 0.01
n.min <- n.ind*polyThres
## make a list of any NON-polymorphic loci:
toRepeat <- list()
for(i in 1:ncol(temp)){
if(any(table(temp[,i]) < n.min) | length(table(temp[,i])) == 1){
toRepeat[[length(toRepeat)+1]] <- i
}
}
if(length(toRepeat) > 0){
toRepeat <- as.vector(unlist(toRepeat))
}
counter <- 0
if(!is.null(seed)) seed.i <- seed
while(length(toRepeat) > 0){
## for each site, draw the branches to which
## you will assign the mts for this site
## (~ branch length):
## Get vector of FALSEs of length tree$edge.length:
null.vect <- rep(FALSE, length(tree$edge.length))
if(max(n.mts[toRepeat]) > length(tree$edge.length)){
if(!is.null(seed)){
seed.i <- seed.i+1
set.seed(seed.i)
}
snps.loci <- sapply(c(1:length(n.mts[toRepeat])),
function(e)
replace(null.vect,
sample(c(1:length(tree$edge.length)),
n.mts[toRepeat][e],
replace=TRUE,
prob=tree$edge.length), TRUE))
}else{
if(!is.null(seed)){
seed.i <- seed.i+1
set.seed(seed.i)
}
snps.loci <- sapply(c(1:length(n.mts[toRepeat])),
function(e)
replace(null.vect,
sample(c(1:length(tree$edge.length)),
n.mts[toRepeat][e],
replace=FALSE,
prob=tree$edge.length), TRUE))
}
## rearrange snps.loci s.t it becomes a
## list of length tree$edge.length,
## each element of which contains the
## locations of the mutations that will
## occur on that branch
snps.loci <- sapply(c(1:nrow(snps.loci)),
function(e) which(snps.loci[e,] == TRUE))
## get the node names for all individuals (terminal and internal)
all.inds <- sort(unique(as.vector(unlist(tree$edge))))
# we will store the output in a list called snps:
# snps <- list()
## we start w all inds having same genotype as root:
# snps[all.inds][toRepeat] <- rep(list(gen.root[toRepeat]), length(all.inds))
for(i in 1:length(all.inds)){
snps[[all.inds[i]]][toRepeat] <- gen.root[toRepeat]
}
## store replacement nts in list new.nts:
new.nts <- list()
## distinguish btw list of loci and unique list
snps.loci.ori <- snps.loci
## will need to treat repeat loci differently...
snps.loci.unique <- lapply(snps.loci, unique) # (identical to snps.loci?)
#############################
## For Loop to get new nts ##
#############################
for(i in x){
## for all snps other than root, we mutate the
## genome of the node preceding it, according to snps.loci.
## Draw new nts for each locus selected for mutation:
if(!.is.integer0(snps.loci.unique[[i]])){
# new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)
#   selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                  %in% snps[[tree$edge[i,1]]][toRepeat]
#                                                  [snps.loci.unique[[i]][e]])]))
new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)
selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% snps[[tree$edge[i,1]]][toRepeat]
[snps.loci.unique[[i]][e]])]))
## if any loci are selected for multiple mutations
## within their given branch length:
if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){
## identify which loci are repeaters
repeats <- table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]
## how many times they repeat
n.reps <- repeats - 1
## the positions of these loci in the vector of snps loci
toRep <- which(snps.loci.unique[[i]] %in% names(repeats))
## run chain of re-sampling to end in our new nt for repeater loci:
foo <- list()
for(j in 1:length(toRep)){
foo[[j]] <- new.nts[[i]][toRep[j]]
for(k in 1:n.reps[j]){
if(k==1){
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][1])])
}else{
# foo[[j]][k] <- selectBiallelicSNP(c("a", "c", "g", "t")[which(c("a", "c", "g", "t")
#                                                               %in% foo[[j]][k-1])])
foo[[j]][k] <- selectBiallelicSNP(c(TRUE, FALSE)[which(c(TRUE, FALSE)
%in% foo[[j]][k-1])])
}
}
## retain only the last nt selected
out <- sapply(c(1:length(foo)),
function(e) foo[[e]][length(foo[[e]])])
}
## for the loci with repeated mts, replace these positions
## in new.nts with the corresponding elements of out, above.
new.nts[[i]][toRep] <- out
} # end of if statement for repeaters
## update ancestral genotype with new.nts:
toto <- snps[[tree$edge[i,1]]][toRepeat]
toto[snps.loci.unique[[i]]] <- new.nts[[i]]
snps[[tree$edge[i,2]]][toRepeat] <- toto
}else{
## if no mts occur on branch, set genotype of
## downstream individual to be equal to ancestor's
snps[[tree$edge[i,2]]][toRepeat] <- snps[[tree$edge[i,1]]][toRepeat]
}
} # end of for loop selecting new nts at mutator loci
## temporarily assemble non-associated loci into matrix:
# temp.new <- do.call("rbind", snps)
temp <- do.call("rbind", snps)
## keep only rows containing terminal individuals:
# temp <- temp.new[1:n.ind, ]
temp <- temp[1:n.ind, ]
##############################################################
# temp <- temp.new
######################################
##### while loop CHECK here: #########
######################################
## CHECK IF ALL LOCI ARE POLYMORPHIC (|polyThres)
## identify n.minor.allele required to meet polyThres:
polyThres <- 0.01
n.min <- n.ind*polyThres
## make a list of any NON-polymorphic loci:
toRepeat.ori <- toRepeat
temp.toRepeat <- temp[, toRepeat.ori]
toRepeat <- list()
## if temp.toRepeat is a true matrix:
if(!is.matrix(temp.toRepeat)){
if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){
toRepeat[[length(toRepeat)+1]] <- toRepeat.ori
}
}else{
if(ncol(temp.toRepeat) > 0){
for(i in 1:ncol(temp.toRepeat)){
if(any(table(temp.toRepeat[,i]) < n.min) | length(table(temp.toRepeat[,i])) == 1){
toRepeat[[length(toRepeat)+1]] <- toRepeat.ori[i]
}
}
}else{
if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){
toRepeat[[length(toRepeat)+1]] <- toRepeat.ori
}
}
}
if(length(toRepeat) > 0){
toRepeat <- as.vector(unlist(toRepeat))
}
counter <- counter+1
print("COUNTER"); print(counter)
print("toRepeat"); print(length(toRepeat))
} # end NEW while loop...
object.size(temp)
colnames(temp) <- c(1:ncol(temp))
object.size(temp)
object.size(snps)
rm(snps)
snps <- temp
rm(temp)
gc()
snps <- snps[1:n.ind, ]
gc()
str(snps)
snps[1:5,1:10]
object.size(snps)
SNPS <- snps
snps <- as.character(snps)
snps <- replace(snps, which(snps == "TRUE"), "a")
snps <- replace(snps, which(snps == "FALSE"), "t")
object.size(snps)
dna <- as.DNAbin(snps)
rownames(dna) <- c(1:nrow(snps))
str(snps)
snps <- SNPS
snps <- as.character(snps)
str(snps)
snps <- SNPS
snps <- replace(snps, which(snps == TRUE), "a")
str(snps)
snps <- replace(snps, which(snps == "FALSE"), "t")
str(snps)
snps <- SNPS
snps <- matrix(as.character(snps), nrow=nrow(snps), ncol=ncol(snps))
str(snps)
snps <- SNPS
snps <- replace(snps, which(snps == TRUE), "a")
snps <- replace(snps, which(snps == "FALSE"), "t")
str(snps)
dna <- as.DNAbin(snps)
rownames(dna) <- c(1:nrow(snps))
str(dna)
str(dna[1:10,])
?as.DNAbin
snps <- SNPS
heatmap.DNAbin(dna=dna,
dist.dna.model=dist.dna.model)
levs <- unique(snps)
levs
levs <- unique(as.vector(unlist(snps)))
levs
str(snps)
mat <- matrix(sample(c(0,1), 1000), nrow=10, ncol=100)
mat <- matrix(sample(c(0,1), 1000, replace=T), nrow=10, ncol=100)
str(mat)
rownames(mat) <- c(1:nrow(mat))
colnames(mat) <- c(1:ncol(mat))
str(mat)
toto <- as.character(mat)
str(toto)
dna <- snps
sp <- matrix(as.character(dna), nrow=nrow(dna), ncol=ncol(dna))
rownames(sp) <- rownames(dna)
colnames(sp) <- colnames(dna)
str(sp)
sp <- matrix(as.character(dna), nrow=nrow(dna), ncol=ncol(dna))
str(sp)
rownames(sp) <- rownames(dna)
colnames(sp) <- colnames(dna)
levs <- unique(as.vector(unlist(sp)))
levs
!levs %in% c("a", "c", "g", "t")
!all(levs %in% c("a", "c", "g", "t"))
nts <- c("a", "c", "g", "t")
!all(levs %in% nts)
SP <- sp
levs <- unique(as.vector(unlist(sp)))
levs <- unique(as.vector(unlist(tt)))
tt <- c(0,0,1,NA)
tt
levs <- unique(as.vector(unlist(tt)))
levs
?unique
is.na("NA")
tt <- as.character(tt)
tt
levs <- unique(as.vector(unlist(tt)))
levs
is.na(levs)
length(levs)
levs[!is.na(levs)]
dna <- rbind(tt, tt)
dna
tt <- c(0,0,1,NA)
dna <- rbind(tt, tt)
dna
sp <- matrix(as.character(dna), nrow=nrow(dna), ncol=ncol(dna))
sp
levs <- unique(as.vector(unlist(sp)))
nts <- c("a", "c", "g", "t")
levs[!is.na(levs)]
length(levs[!is.na(levs)])
if(!all(levs %in% nts)){
for(i in 1:length(levs)){
sp <- replace(sp, which(sp == levs[i]), nts[i])
} # end for loop
} # end levs conversion
sp
sp <- rbind(tt, tt)
sp
colnames(sp) <- c(1:ncol(sp))
sp
SP <- sp
dna <- sp
sp <- matrix(as.character(dna), nrow=nrow(dna), ncol=ncol(dna))
rownames(sp) <- rownames(dna)
colnames(sp) <- colnames(dna)
## Check/convert levels:
levs <- unique(as.vector(unlist(sp)))
nts <- c("a", "c", "g", "t")
sp
if(length(levs[!is.na(levs)]) > 4){
stop("There must be no more than 4 unique values in dna, excluding NAs.")
}
if(!all(levs %in% nts)){
for(i in 1:length(levs)){
sp <- replace(sp, which(sp == levs[i]), nts[i])
} # end for loop
} # end levs conversion
sp
dna <- as.DNAbin(sp)
rownames(dna) <- rownames(sp)
colnames(dna) <- colnames(sp)
dna
str(dna)
source('~/treeWAS/pkg/R/tree.reconstruct.R')
class(dna) == "genind"
dn <- as.genind(dna)
dn@tab
dnb <- as.DNAbin(dn)
dna <- SNPS
class(dna)
is.matrix(dna)
sp <- matrix(as.character(dna), nrow=nrow(dna), ncol=ncol(dna))
rownames(sp) <- rownames(dna)
colnames(sp) <- colnames(dna)
## Check/convert levels:
levs <- unique(as.vector(unlist(sp)))
nts <- c("a", "c", "g", "t")
if(length(levs[!is.na(levs)]) > 4){
stop("There must be no more than 4 unique values in dna, excluding NAs.")
}
if(!all(levs %in% nts)){
for(i in 1:length(levs)){
sp <- replace(sp, which(sp == levs[i]), nts[i])
} # end for loop
} # end levs conversion
dna <- as.DNAbin(sp)
rownames(dna) <- rownames(sp)
colnames(dna) <- colnames(sp)
str(dna)
source('~/treeWAS/pkg/R/tree.reconstruct.R')
source('~/treeWAS/pkg/R/tree.reconstruct.R')
str(snps)
gen.size <- ncol(snps)
source('~/treeWAS/pkg/R/tree.reconstruct.R')
ploidy <- 1
snps <- as.DNAbin(snps, ploidy=ploidy)
str(SNPS)
snps <- SNPS
dna <- snps
dna <- replace(dna, which(dna == TRUE), "a")
dna <- replace(dna, which(dna == "FALSE"), "t")
str(dna)
rownames(dna) <- c(1:nrow(dna))
dna <- as.DNAbin(dna)
str(dna)
str(snps)
dna <- snps
dna <- replace(dna, which(dna == TRUE), "0")
dna <- replace(dna, which(dna == "FALSE"), "1")
str(dna)
dna <- as.DNAbin(dna)
str(dna)
?as.DNAbin
dna <- snps
dna <- replace(dna, which(dna == TRUE), 0)
str(dna)
dna[1:10,1:20]
dna <- snps
dna <- replace(dna, which(dna == TRUE), 1)
str(dna)
dna[1:10,1:20]
source('~/treeWAS/pkg/R/snp.sim.R')
source('~/treeWAS/pkg/R/treeWAS.R')
source('~/treeWAS/pkg/R/coalescent.sim.R')
source('~/treeWAS/pkg/R/snp.sim.Q.R')
source('~/treeWAS/pkg/R/plot.phen.R')
?as.phyDat
source('~/treeWAS/pkg/R/snp.sim.R')
source('~/treeWAS/pkg/R/snp.sim.Q.R')
?pace
?ace
#' Short one-phrase description.
library(devtools)
document()
setwd("treeWAS/pkg")
getwd()
setwd("/home/caitiecollins/treeWAS/pkg")
document()
library(treeWAS)
library(treeWAS)
setwd("/home/caitiecollins/ClonalFrameML/src/pubMLST/Neisseria/C/Europe/")
library(data.table)
dat <- fread(input="./phen.csv", sep=",", na.strings = "NA")
str(dat)
dat <- fread(input="./phen.csv", sep=",", na.strings = "NA")
dat <- fread(input="./phen.csv", sep=",", na.strings = "NA")
str(dat)
phen <- dat$disease
## add names before subsetting:
names(phen)
names(phen) <- dat$id
table(phen)
str(phen)
save(phen, file="./phen_ori.Rdata")
is.null(fs)
source('~/treeWAS/pkg/R/snp.sim.R')
for(prefix in c("moo", "ba", "la", "la", "la")){print(prefix)}
