phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
str(snps.reconstruction)
SR <- snps.reconstruction
sr <- asr(snps, tree, "parsimony")
str(sr)
sr <- sr$var.rec
str(SR)
str(sr)
all(rownames(SR) %in% rownames(sr))
document()
library(devtools)
document()
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
str(snps.reconstruction)
names(phen)
toRemove <- names(phen)[1]
toRemove <- names(phen)[c(1,5)]
phen <- phen[-which(names(phen) %in% toRemove)]
snps.ini <- snps
snps <- snps[-which(rownames(snps) %in% toRemove), ]
## remove individuals from tree:
tree <- drop.tip(tree, tip = toRemove)
str(snps.ini)
str(snps)
is.matrix(snps.reconstruction)
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
is.null(toKeep)
NA.tab <- sapply(c(1:ncol(snps)), function(e) length(which(is.na(snps[,e]))))
toRemove <- which(NA.tab > floor(nrow(snps)/2)) # Remove columns w > 50% of NAs
toRemove
ncol(snps)
length(toRemove)
snps.ini <- snps
snps <- snps[, -toRemove]
snps <- snps.ini
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
toRemove <- rownames(snps)[which(NA.tab == ncol(snps))] # Remove ENTIRELY missing rows...
length(toRemove)
toRemove <- which(NA.tab > floor(ncol(snps)*0.75))
length(toRemove)
toRemove <- which(NA.tab > floor(nrow(snps)/2))
length(toRemove)
identical(as.character(rownames(snps)), as.character(tree$tip.label))
ord <- match(tree$tip.label, rownames(snps))
ord
snps.ini <- snps
snps <- snps[ord,]
identical(as.character(rownames(snps)), as.character(tree$tip.label))
identical(as.character(rownames(snps.reconstruction)), as.character(tree$tip.label))
ord <- match(tree$tip.label, rownames(snps.reconstruction))
snps.rec.ini <- snps.reconstruction
snps.reconstruction <- snps.reconstruction[ord,]
identical(as.character(rownames(snps.reconstruction)), as.character(tree$tip.label))
identical(as.character(names(phen)), as.character(tree$tip.label))
toChange <- which(tree$edge.length < 0)
toChange
length(toChange)
source('~/treeWAS/pkg/R/treeWAS.R')
phen.rec.method <- levs <- NULL
phen.ori <- phen
## Convert to numeric (required for assoc tests):
na.before <- length(which(is.na(phen)))
## CHECK for discrete vs. continuous:
## NB: can only be binary or continuous at this point...
levs <- unique(as.vector(unlist(phen)))
n.levs <- length(levs[!is.na(levs)])
n.levs
levs
phen.rec.method <- "discrete"
!is.numeric(phen)
all.is.numeric(phen)
phen <- as.numeric(as.factor(phen))
phen
document()
library(treeWAS)
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
## Examine data:
## genetic data
str(snps)
## phenotype
str(phen)
table(phen)
## tree
str(tree)
## genetic data reconstruction:
str(snps.reconstruction)
data(phen.plot.col)
## Plot tree showing phenotype:
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes, cex=0.5)
tiplabels(text=tree$tip.label, cex=0.5, adj=c(-0.5, 0), col=leafCol, frame="none")
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
snps.assoc
all(suffixes %in% c(".a", ".c", ".g", ".t"))
snps <- get.binary.snps(snps)
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
length(ix)
ix <- c(1,5)
toRemove <- rownames(snps)[ix]
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
## drop tips from tree:
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
## (Example only, if needed for user data)
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
str(snps)
unique(snps)
unique(as.vector(unlist(snps)))
unique(as.vector(unlist(snps[!is.na(snps)])))
?unique
unique(as.vector(unlist(snps[!is.na(snps)])), incomparables = NA)
unique(as.vector(unlist(snps)), incomparables = NA)
length(unique(as.vector(unlist(snps[!is.na(snps)]))))
source('~/treeWAS/pkg/R/treeWAS.R')
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
print(out)
snps.assoc
source('~/treeWAS/pkg/R/get.sig.snps.R')
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
document()
library(treeWAS)
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
data(phen.plot.col)
## Plot tree showing phenotype:
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
is.matrix(snps.reconstruction)
snps <- get.binary.snps(snps)
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
if(length(ix) > 0){
toRemove <- rownames(snps)[ix]
## Remove individuals from all elements...
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
## drop tips from tree:
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
## (Example only, if needed for user data)
if(is.matrix(snps.reconstruction)){
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
}
}
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
snps.assoc
str(snps)
snps.assoc
data(snps)
str(snps)
library(treeWAS)
data(snps)
snps.assoc
snps.assoc
snps.assoc
library(treeWAS)
snps.assoc
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
## Examine data:
## genetic data
str(snps)
## phenotype
str(phen)
table(phen)
## tree
str(tree)
## genetic data reconstruction:
str(snps.reconstruction)
data(phen.plot.col)
## Plot tree showing phenotype:
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
set.args(list(tree, phen.nodes, snp.nodes=NULL, plot=TRUE, RTL=FALSE, main.title = TRUE))
phen.nodes <- phen.plot.col$all.nodes
set.args(list(tree, phen.nodes, snp.nodes=NULL, plot=TRUE, RTL=FALSE, main.title = TRUE))
set.args(list(tree=tree, phen.nodes=phen.plot.col$all.nodes, snp.nodes=NULL, plot=TRUE, RTL=FALSE, main.title = TRUE))
tree <- reorder.phylo(tree, order="pruningwise")
## Trees must be rooted:
# if(!is.rooted(tree)) tree <- midpoint(tree)
## PLOT MARGINS: ##
mar.ori <- par()$mar
if(RTL==FALSE){
# mar.new <- c(2.5,0.5,0,0.5)
mar.new <- c(4, 2, 4, 0.5) + 0.1
}else{
# mar.new <- c(2.5,1.5,0,0.5)
mar.new <- c(5, 4, 4, 2) + 0.1
}
## Set plot margins:
par(mar=mar.new)
if(is.null(main.title)) main.title <- FALSE
if(!is.null(phen.nodes) & !is.null(snp.nodes)) par(mfrow=c(1,2))
## get number of terminal nodes
if(!is.null(tree$tip.label)){
n.ind <- length(tree$tip.label)
}else{
n.ind <- tree$Nnode+1
}
## check if phen provided is for all nodes or only terminal nodes:
if(length(phen.nodes) == (n.ind + tree$Nnode)){
prit(1)
print(1)}
if(length(phen.nodes) == (n.ind + tree$Nnode)){
print(1)
}
## get COLOR for NODES
nodeCol <- as.vector(phen.nodes)
nodeCol <- as.character(nodeCol)
nodeCol <- replace(nodeCol, which(nodeCol %in% c("R", "B", "1")), "red")
nodeCol <- replace(nodeCol, which(nodeCol %in% c("S", "A", "0")), "blue")
nodeCol <- replace(nodeCol, which(nodeCol %in% c("0.5")), "grey")
nodeCol <- as.vector(unlist(nodeCol))
## get COLOR for LEAVES ONLY
leafCol <- nodeCol[1:n.ind]
## get COLOR of INTERNAL nodes ONLY
internalNodeCol <- nodeCol[(n.ind+1):length(nodeCol)]
## get COLOR for EDGES
edgeCol <- rep("black", nrow(tree$edge))
for(i in 1:nrow(tree$edge)){
edgeCol[i] <- nodeCol[tree$edge[i,2]]
if(nodeCol[tree$edge[i,1]] != nodeCol[tree$edge[i,2]]) edgeCol[i] <- "grey"
}
edgeLabCol <- edgeCol
if(RTL == FALSE){
# plot(tree, show.tip=FALSE, edge.width=2, edge.color=edgeCol, ...) # edgeCol
plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol,...) # edge.width=3  #  no.margin=T
## TEMP
# plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, no.margin=T)
}else{
# plot(tree, show.tip=FALSE, edge.width=2, edge.color=edgeCol, direction = "leftwards", ...) # edgeCol
plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, direction = "leftwards", ...) # edge.width=3  #  no.margin=T
## TEMP
# plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, direction = "leftwards", no.margin=TRUE, use.edge.length=FALSE) #
}
## Add title?
if(main.title == TRUE){
# if(is.ultrametric(tree)) title("Coalescent tree w/ phenotypic changes")
title("Tree with phenotypic changes")
}else{
if(!is.null(main.title)) if(main.title != FALSE) title(main.title)
}
## Add axis?
# axisPhylo()
# edgelabels(text=paste("e", c(1:nrow(tree$edge)), sep="."),
# cex=0.5, font=2, bg=transp(edgeLabCol, 0.3), adj=c(1,1))
if(RTL == FALSE){
tiplabels(text=tree$tip.label, cex=0.55, adj=c(-0.5, 0), col=leafCol, frame="none")
## TEMP
# tiplabels(text=tree$tip.label, cex=0.75, adj=c(-0.42, 0), col=leafCol, frame="none")
}else{
## if RTL == TRUE (i.e., direction="leftwards"):
tiplabels(text=tree$tip.label, cex=0.55, adj=c(1.5,0), col=leafCol, frame="none")
## TEMP
# tiplabels(text=tree$tip.label, cex=0.75, adj=c(1.42,0), col=leafCol, frame="none")
}
## TEMP: (LTR)
# plot(tree, show.tip=FALSE, edge.width=6, edge.color=edgeCol)
## terminal symbols?
# tiplabels(text=NULL, cex=2, adj=c(0.58, 0.5), col=leafCol, pch=15)
#         ord <- get.tip.order(tree)
#         setCol <- rep("black", 15)
#         toChange <- rev(tree$tip.label[ord])[1:6]
#         setCol[toChange] <- "darkgrey"
#         tiplabels(text=NULL, cex=2, adj=c(0.58, 0.5), col=setCol, pch=15)
## TEMP: (RTL)
# plot(tree, show.tip=FALSE, edge.width=6, edge.color=edgeCol, direction = "leftwards")
## terminal symbols?
# tiplabels(text=NULL, cex=2, adj=c(0.44, 0.5), col=leafCol, pch=15)
## TEMP: (cladogram)
# plot(tree, show.tip=FALSE, edge.width=6, edge.color=edgeCol, type="c", use.edge.length=F)
## terminal symbols?
# tiplabels(text=NULL, cex=1.5, adj=c(1.15, 0.5), col=leafCol, pch=15)
## TOO CROWDED:
#         if(is.null(tree$node.label)){
#           # nodeLabs <- unique(tree$edge[,1])
#           ## nodeLabs should start from the lowest internal node index (ie n.terminal+1):
#           # if(nodeLabs[length(nodeLabs)] == (tree$Nnode+2)) nodeLabs <- rev(nodeLabs)
#           nodeLabs <- sort(unique(tree$edge[,1])) ## This seems to work...
#           nodelabels(text=nodeLabs, cex=0.5, bg=transp(internalNodeCol, 0.3))
#           # nodelabels(text=nodeLabs, cex=0.5, col=internalNodeCol, bg="yellow")
#         }else{
#           nodelabels(text=tree$node.label, cex=0.5, bg=transp(internalNodeCol, 0.3))
#         }
## should be numbered s.t. the root node is n.term+1
## RECALL: terminal nodes are numbered 1:n.ind from bottom to top of plot of tree;
## edges are numbered 1:nrow(edges) by following the lowest trace on the plot
## (starting from the root down to the lowermost tips);
## thus, internal nodes are numbered (n.ind+1):(n.ind+(n.ind-1)),
## from root to the top-most internal node to be connected (ie. the highest in the plot)
# }
} # end plot = TRUE
if(RTL == FALSE){
# plot(tree, show.tip=FALSE, edge.width=2, edge.color=edgeCol, ...) # edgeCol
plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol,...) # edge.width=3  #  no.margin=T
## TEMP
# plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, no.margin=T)
}else{
# plot(tree, show.tip=FALSE, edge.width=2, edge.color=edgeCol, direction = "leftwards", ...) # edgeCol
plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, direction = "leftwards", ...) # edge.width=3  #  no.margin=T
## TEMP
# plot(tree, show.tip=T, tip.col="white", edge.width=3, edge.color=edgeCol, direction = "leftwards", no.margin=TRUE, use.edge.length=FALSE) #
}
## Add title?
if(main.title == TRUE){
# if(is.ultrametric(tree)) title("Coalescent tree w/ phenotypic changes")
title("Tree with phenotypic changes")
}else{
if(!is.null(main.title)) if(main.title != FALSE) title(main.title)
}
## Add axis?
# cex=0.5, font=2, bg=transp(edgeLabCol, 0.3), adj=c(1,1))
if(RTL == FALSE){
tiplabels(text=tree$tip.label, cex=0.55, adj=c(-0.5, 0), col=leafCol, frame="none")
## TEMP
# tiplabels(text=tree$tip.label, cex=0.75, adj=c(-0.42, 0), col=leafCol, frame="none")
}else{
## if RTL == TRUE (i.e., direction="leftwards"):
tiplabels(text=tree$tip.label, cex=0.55, adj=c(1.5,0), col=leafCol, frame="none")
## TEMP
# tiplabels(text=tree$tip.label, cex=0.75, adj=c(1.42,0), col=leafCol, frame="none")
}
is.null(snp.nodes)
if(!is.null(phen.nodes) & !is.null(snp.nodes)) par(mfrow=c(1,1))
phen.plot.colors <- list(edgeLabCol, edgeCol, nodeCol, internalNodeCol, leafCol)
names(phen.plot.colors) <- c("edge.labels", "edges", "all.nodes", "internal.nodes", "tip.labels")
return(phen.plot.colors)
str(phen.plot.col)
plot(1)
p <- plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
if(all(suffixes %in% c(".a", ".c", ".g", ".t"))){
## SNPs:
snps <- get.binary.snps(snps)
## ... Optional step (for snps.reconstruction, if present)
## (Example only, if needed for user data)
if(is.matrix(snps.reconstruction)){
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
}
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
if(length(ix) > 0){
toRemove <- rownames(snps)[ix]
## Remove individuals from all elements...
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
## drop tips from tree:
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
## (Example only, if needed for user data)
if(is.matrix(snps.reconstruction)){
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
}
}
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
}
print(out)
library(devtools)
document()
