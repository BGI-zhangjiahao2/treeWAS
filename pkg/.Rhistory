## remove individuals from phen:
phen <- phen[-which(names(phen) %in% toRemove)]
## remove individuals from tree:
tree <- drop.tip(tree, tip = toRemove)
}
# }
####################################################################
## CHECK FOR NON-BINARY SNPS (?): ## DO THIS OUTSIDE OF THE treeWAS PIPELINE -- TOO MANY OPPORTUNITIES FOR ERRORS IF DONE AUTOMATICALLY.
## (This will only work if all snps colnames end in one of .a/.c/.g/.t)
#   snps <- get.binary.snps(snps)
#   ## (+ snps.reconstruction)
#   if(is.matrix(snps.reconstruction)){
#     snps.reconstruction <- get.binary.snps(snps.reconstruction)
#   }
####################################################################
## REORDER SNPS TO MATCH TREE$TIP.LABEL
if(!identical(as.character(rownames(snps)), as.character(tree$tip.label))){
ord <- match(tree$tip.label, rownames(snps))
snps <- snps[ord,]
## check:
if(!identical(as.character(rownames(snps)), as.character(tree$tip.label))){
stop("Unable to rearrange snps such that rownames(snps)
match content and order of tree$tip.label.
Please check that these match.")
}
}
## REORDER PHEN TO MATCH TREE$TIP.LABEL
if(!identical(as.character(names(phen)), as.character(tree$tip.label))){
ord <- match(tree$tip.label, names(phen))
phen <- phen[ord]
## check:
if(!identical(as.character(names(phen)), as.character(tree$tip.label))){
stop("Unable to rearrange phen such that names(phen)
match content and order of tree$tip.label.
Please check that these match.")
}
}
####################################################################
## CHECK TREE: (set NEGATIVE branch lengths to zero (??)) ##
toChange <- which(tree$edge.length < 0)
if(length(toChange) > 0){
tree$edge.length[toChange] <- 0
cat("Setting", length(toChange), "negative branch lengths to zero.", sep=" ")
}
####################################################################
mar.ori <- par()$mar
## get tip.col:
leafCol <- "black"
if(all.is.numeric(phen)){
var <- as.numeric(as.character(phen))
}else{
var <- as.character(phen)
}
levs <- unique(var)
if(length(levs) == 2){
## binary:
myCol <- c("red", "blue")
}else{
if(is.numeric(var)){
## numeric:
# myCol <- seasun(length(levs))
myCol <- num2col(var, col.pal = seasun)
}else{
## categorical...
myCol <- funky(length(levs))
}
}
## get leafCol from colour scheme:
if(is.numeric(var)){
leafCol <- myCol
}else{
leafCol <- var
## for loop
for(i in 1:length(levs)){
leafCol <- replace(leafCol, which(leafCol == levs[i]), myCol[i])
} # end for loop
}
## PLOT TREE:
plot(tree, show.tip=T, tip.col=leafCol, align.tip.label=TRUE, cex=0.5)
title("Phylogenetic tree")
axisPhylo()
## reset plot margins:
par(mar=mar.ori)
head(phen)
## get parsimomy cost for each SNP locus using fitch:
n.subs <- get.fitch.n.mts(snps=snps, tree=tree)
n.subs <- table(n.subs)
## handle n.subs "levels" with 0 SNP loci at those levels:
noms <- as.numeric(names(n.subs))
temp <- rep(0, max(noms))
for(i in 1:max(noms)){
if(i %in% noms) temp[i] <- n.subs[which(noms==i)]
}
n.subs <- temp
names(n.subs) <- 1:length(n.subs)
## check?
n.snps.sim = 5*ncol(pa)
## check n.snps.sim:
if(is.null(n.snps.sim)){
n.snps.sim <- ncol(snps)*10
}else{
## Update n.snps.sim to match the REAL ncol(snps) after checks...
if(n.snps != ncol(snps)){
if(n.snps.sim == n.snps){
n.snps.sim.ori <- n.snps.sim
n.snps.sim <- ncol(snps)
warning(paste("Note: Updating n.snps.sim to match the number of real loci after data cleaning.
Input:", n.snps.sim.ori, " -->
Updated:", n.snps.sim))
}else{
Nx <- c(2:200)
if(any(n.snps*Nx %in% n.snps.sim)){
n.snps.sim.ori <- n.snps.sim
Nx <- Nx[which(Nx == (n.snps.sim/n.snps))]
n.snps.sim <- ncol(snps)*Nx
warning(paste("Note: Updating n.snps.sim to match ", Nx, "x the number of real loci after data cleaning.
Input: ", n.snps.sim.ori, " -->
Updated: ", n.snps.sim, sep=""))
## TO DO: ##
## If the user, for whatever reason, wanted to simulate the number they requested
## (ie. matching the input n.snps (coincidentally?)), could either
## (A) Add an argument like upate.n.snps.sim = FALSE,
## (B) Tell them to do their own data cleaning exactly as I do but outside of/before running the treeWAS function.
## (C) Fudge--tell them to add 1, eg. 10,000 --> 10,001?
}
}
}
}
out <- genomes <- snps.mat <- list()
## SIMULATE A DATASET | your tree ##
if(!is.null(seed)) set.seed(seed)
out[[1]] <- snp.sim(n.snps = n.snps.sim,
n.subs = n.subs,
n.snps.assoc = 0,
assoc.prob = 100,
tree = tree,
phen.loci = NULL,
heatmap = FALSE,
reconstruct = FALSE,
dist.dna.model = dist.dna.model,
row.names = rownames(snps),
seed = seed)
genomes[[1]] <- out[[1]][[1]]
## Modify genomes/snps matrices
if(!is.null(genomes[[1]])){
snps.mat[[1]] <- genomes[[1]]
}else{
snps.mat[[1]] <- NULL
}
gc()
print("treeWAS snps sim done.")
snps.unique <- snps.index <- snps.sim.unique <- snps.sim.index <- NULL
#################
## Handle snps ##
#################
## Check snps column names
if(is.null(colnames(snps))) colnames(snps) <- c(1:ncol(snps))
################################
## Handle snps.sim --> matrix ##
################################
snps.sim <- snps.mat
## Handle matrix/list input:
if(class(snps.sim) == "list"){
## If list of length 1...
if(length(snps.sim) == 1){
## keep matrix:
snps.sim <- snps.sim[[1]]
}else{
## If list of multiple matrices...
## merge all elements into one big matrix
## by pasting columns together:
snps.sim <- do.call("cbind", snps.sim)
}
}
## check n.subs:
# n.subs.sim <- get.fitch.n.mts(snps.sim, tree=tree)
# n.subs.sim2 <- table(n.subs.sim)
# barplot(n.subs.sim2, col=transp("blue", 0.5), names=c(1:length(n.subs.sim2)))
# title("Homoplasy distribution \n (snps.sim)")
## NOTE--this is also necessary for returning results in step (5)!
phen.ori <- phen
if(!is.numeric(phen)) phen <- as.numeric(phen)
## for ease of interpretation,
## if phen has 2 levels, 1 and 2,
## make these 0 and 1:
if(length(unique(phen))!=2){
stop("This function is only designed for phenotypes with two levels.")
}else{
if(length(phen[-c(which(phen==1), which(phen==2))])==0){
phen <- replace(phen, which(phen==1), 0)
phen <- replace(phen, which(phen==2), 1)
}
}
## ensure ind names not lost
names(phen) <- names(phen.ori)
##############################################################################################
## Reconstruct ancestral SNPs & phen by parsimony/ML (for tests simultaneous & subsequent) ##
##############################################################################################
## Ensure we are only reconstructing ancestral states ONCE here, to be used in MULTIPLE tests later.
snps.REC <- snps.sim.REC <- phen.REC <- NULL
head(phen)
head(phen.ori)
phen <- phen.ori
ff <- c(4,4,5,5,4)
ff <- factor(ff)
ff
as.numeric(ff)
as.numeric(as.character(phen))
any(is.na(phen))
na.before <- length(which(is.na(phen)))
na.after <- length(which(is.na(phen)))
na.after > na.before
na.before
head(phen)
is.numeric(phen)
phen <- as.numeric(as.character(phen))
snps.REC <- snps.sim.REC <- phen.REC <- NULL
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
snps.reconstruction
str(tree)
min(tree$edge.length)
length(which(tree$edge.length == 0))
head(phen)
names(phen) <- names(phen.ori)
head(phen)
var <- snps
str(snps)
str(SNPS)
SNPS <- snps
TREE <- tree
PHEN <- phen
SNPS.SIM <- snps.sim
VAR <- SNPS
type <- "ml"
method <- "continuous"
length(unique(as.vector(unlist(phen))))
class(phen)
head(phen)
class(ff)
length(unique(as.vector(unlist(ff))))
snps.REC <- snps.sim.REC <- phen.REC <- rec.method <- NULL
snps.REC <- snps.sim.REC <- phen.REC <- rec.method <- levs <- NULL
n.levs
length(unique(as.vector(unlist(phen))))
levs <- unique(as.vector(unlist(phen)))
n.levs <- length(levs[!is.na(levs)])
n.levs
head(phen)
levs <- unique(as.vector(unlist(phen)))
n.levs <- length(levs[!is.na(levs)])
if(n.levs == 2){
phen.rec.method <- "discrete"
}else{
phen.rec.method <- "continuous"
}
phen.rec.method
snps.reconstruction
snps.reconstruction <- snps.sim.reconstruction <- "parsimony"
str(snps)
str(tree)
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
snps.rec <- snps.REC$var.rec
snps.sim.REC <- asr(var = snps.sim, tree = tree, type = snps.sim.reconstruction)
snps.sim.rec <- snps.sim.REC$var.rec
if(phen.rec.method == "continuous") phen.reconstruction <- "ml"
phen.REC <- asr(var = phen, tree = tree, type = phen.reconstruction, method = phen.rec.method)
warnings()
head(phen)
phen.reconstruction
phen.rec.method
method = phen.rec.method
type = phen.reconstruction
head(phen)
head(PHEN)
tree <- reorder.phylo(tree, order="pruningwise")
## Trees must be rooted:
if(!is.rooted(tree)) tree <- midpoint(tree)
## get tree edges
edges <- tree$edge
ord <- NULL
## Arg checks:
if(length(type) > 1) type <- type[1]
type <- tolower(type)
if(type == "ace") type <- "ml"
if(!type %in% c("parsimony", "ml", "ace")) stop("type should be one of 'parsimony' or 'ML'.")
if(length(method) > 1) method <- method[1]
method <- tolower(method)
if(!method %in% c("discrete", "continuous")) warning("Only 'discrete' and 'continuous' are allowed as method argument.
Note that handling of non-binary categorical phenotypes has not yet been implemented.")
levs <- unique(as.vector(unlist(var)))
levs <- levs[!is.na(levs)]
if(length(levs) != 2){
## If NON-BINARY: ##
if(type != "ml"){
type <- "ml"
cat("Variable is non-binary. Setting reconstruction type to 'ML'")
}
if(method != "continuous"){
method <- "continuous"
cat("Variable is non-binary. Setting reconstruction method to 'continuous'")
}
}else{
## If BINARY: ##
if(!type %in% c("parsimony", "ml", "ace")){
type <- "parsimony"
cat("Reconstruction type must be one of 'parsimony' or 'ML'. Selecting 'parsimony' by default.")
}
if(!method %in% c("discrete", "continuous")){
method <- "discrete"
cat("Reconstruction method must be one of 'discrete' or 'continuous'. Selecting 'discrete' by default.")
}
}
is.matrix(var)
phen.reconstruction
phen.rec.method
var <- phen
VAR <- var
is.matrix(var)
phen.terminal <- phen
## get internal values (from ML output)
phen.ML <- ace(phen, tree, type=method)
warnings()
?ace
str(TREE)
identical(TREE, tree)
which(tree$edge.length == 0)
tree$edge.length[which(tree$edge.length == 0)] <- 0.000001
which(tree$edge.length == 0)
phen.ML <- ace(phen, tree, type=method)
phen.internal <- phen.ML$lik.anc[,2]
## get reconstruction from terminal & internal values
var.rec <- c(phen.terminal, phen.internal)
phen.ML <- ace(as.character(phen), tree, type=method)
min(tree$edge.length)
1e-10
0.00000000001
any(tree$edge.length <= 0)
toReplace <- 339
tree$edge.length[toReplace] <- 1e-10
phen.ML <- ace(phen, tree, type=method)
phen.internal <- phen.ML$lik.anc[,2]
## get reconstruction from terminal & internal values
var.rec <- c(phen.terminal, phen.internal)
tree <- TREE
phen.pars <- get.ancestral.pars(var=phen, tree=tree)
toReplace <- which(tree$edge.length <= 0)
tree$edge.length[toReplace] <- 1e-10
phen.pars <- get.ancestral.pars(var=phen, tree=tree)
foo <- sample(c(0,1), length(phen))
foo <- sample(c(0,1), length(phen), replace=T)
names(foo) <- names(phen)
phen.pars <- get.ancestral.pars(var=foo, tree=tree)
any(tree$edge.length <= 0)
tree <- TREE
any(tree$edge.length <= 0)
phen.pars <- get.ancestral.pars(var=phen, tree=tree)
phen.pars <- get.ancestral.pars(var=foo, tree=tree)
str(snps)
foo <- snps
foo <- as.numeric(as.character(foo))
str(foo)
is.numeric(snps)
tree <- TREE
snps.rec <- snps.ML <- list()
for(i in 1:ncol(snps)){
## get variable i
var <- snps[,i]
## get terminal values
var.terminal <- var
## get internal values (from ML output for variable i)
snps.ML[[i]] <- ace(var, tree, type=method)
var.internal <- snps.ML[[i]]$lik.anc[,2]
## get reconstruction from terminal & internal values
snps.rec[[i]] <- c(var.terminal, var.internal)
}
warnings()
i
i <- 1
var <- snps[,i]
## get terminal values
var.terminal <- var
## get internal values (from ML output for variable i)
snps.ML[[i]] <- ace(var, tree, type=method)
snps.ML[[i]] <- ace(var, tree, type=method)
method
is.numeric(var)
toReplace <- which(tree$edge.length <= 0)
tree$edge.length[toReplace] <- 1e-10
snps.ML[[i]] <- ace(var, tree, type=method)
method <- "discrete"
snps.ML[[i]]
var.internal <- snps.ML[[i]]$lik.anc[,2]
var.internal
method
table(var)
snps.ML[[i]] <- ace(var, tree, type=method)
snps.ML[[i]]
method
method <- "continuous"
phen.ML <- ace(phen, tree, type=method)
phen.ML
method <- "discrete"
foo <- as.character(phen)
str(foo)
names(foo) <- names(phen)
phen.ML <- ace(foo, tree, type=method)
foo <- sample(c("A", "B"), length(phen), replace=T)
names(foo) <- names(phen)
phen.ML <- ace(foo, tree, type=method)
phen.ML
is.numeric(snps)
all.is.numeric(snps)
snps.ori <- snps
noms <- names(phen)
noms
c.noms <- colnames(snps)
r.noms <- rownames(snps)
str(SNPS)
str(snps)
snps <- matrix(as.numeric(as.character(snps)), nrow=nrow(snps), ncol=ncol(snps))
str(snps)
source('~/treeWAS/pkg/R/reconstruct.R')
phen.REC <- asr(var = phen, tree = tree, type = phen.reconstruction, method = phen.rec.method)
phen.rec <- phen.REC$var.rec
phen.rec
snps.sim.reconstruction
snps.sim.REC <- asr(var = snps.sim, tree = tree, type = snps.sim.reconstruction)
snps.sim.rec <- snps.sim.REC$var.rec
library(devtools)
getwd()
document()
document()
library(treeWAS)
snps.sim.REC <- asr(var = snps.sim, tree = tree, type = snps.sim.reconstruction)
?as.phyDat
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
c.noms <- colnames(snps)str(tree)
str(tree)
str(snpposi.plot)
str(snps)
r.noms
c.noms
rownames(snps) <- r.noms
colnames(snps) <- c.noms
str(snps)
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
var <- snps
snps.reconstruction
type <- snps.reconstruction
method
## Always work with trees in "pruningwise" order:
tree <- reorder.phylo(tree, order="pruningwise")
## Trees must be rooted:
if(!is.rooted(tree)) tree <- midpoint(tree)
## get tree edges
edges <- tree$edge
ord <- NULL
## Arg checks:
if(length(type) > 1) type <- type[1]
type <- tolower(type)
if(type == "ace") type <- "ml"
if(length(method) > 1) method <- method[1]
method <- tolower(method)
levs <- unique(as.vector(unlist(var)))
levs <- levs[!is.na(levs)]
levs
if(length(levs) != 2){
## If NON-BINARY: ##
if(type != "ml"){
type <- "ml"
cat("Variable is non-binary. Setting reconstruction type to 'ML'")
}
if(method != "continuous"){
method <- "continuous"
cat("Variable is non-binary. Setting reconstruction method to 'continuous'")
}
}else{
## If BINARY: ##
if(!type %in% c("parsimony", "ml", "ace")){
type <- "parsimony"
cat("Reconstruction type must be one of 'parsimony' or 'ML'. Selecting 'parsimony' by default.")
}
if(!method %in% c("discrete", "continuous")){
method <- "discrete"
cat("Reconstruction method must be one of 'discrete' or 'continuous'. Selecting 'discrete' by default.")
}
}
is.matrix(var)
temp <- get.unique.matrix(snps, MARGIN=2)
snps.unique <- temp$unique.data
index <- temp$index
if(ncol(snps.unique) == ncol(snps)){
all.unique <- TRUE
}else{
all.unique <- FALSE
}
## work w only unique snps:
snps.ori <- snps
snps <- snps.unique
print("N snps.unique (reconstruction):"); print(ncol(snps.unique))
type
snps.pars <- get.ancestral.pars(var=snps, tree=tree)
library(devtools)
document()
library(treeWAS)
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
phangorn::as.phyDat
as.phyDat <- phangorn::as.phyDat
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
?pace
library(treeWAS)
snps.REC <- asr(var = snps, tree = tree, type = snps.reconstruction)
