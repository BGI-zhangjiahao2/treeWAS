# pval2[i] <- ANOVA$"Pr(>Chi)"[2]
} # end for loop
pval.pca <- pval2
## Get results:
p.thresh <- p.value # 0.01
pca.snps.uncorrected <- snps.names[which(pval.pca < p.thresh)]
p.vals.bonf <- p.adjust(pval.pca, "bonferroni")
p.bonf <- which(p.vals.bonf < p.thresh)
pca.snps.bonf <- snps.names[p.bonf]
## Store results:
pca.results <- list(snps.corrected.pca, pval.pca, pca.snps.uncorrected, pca.snps.bonf)
names(pca.results) <- c("snps.corrected.pca", "pval.pca", "pca.snps.uncorrected", "pca.snps.bonf")
print("PCA done")
#############################
## CHECK:
print("n.grp"); print(n.grp)
print("NAs?"); print(any(is.na(pval.pca)))
print("pca.snps.uncorrected"); print(length(pca.results$pca.snps.uncorrected))
print("pca.snps.bonf"); print(length(pca.results$pca.snps.bonf))
n.grp <- 10
PCA.RESULTS.LM2 <- pca.results
pca.snps.bonf
snps.assoc
PCA.RESULTS$pval.pca[snps.assoc]
round(PCA.RESULTS$pval.pca[snps.assoc], 3)
round(PCA.RESULTS$pval.pca[snps.assoc], 6)
round(PCA.RESULTS$pval.pca[snps.assoc], 9)
PCA.RESULTS$pval.pca[snps.assoc]
PCA.RESULTS.LM$pval.pca[snps.assoc]
PCA.RESULTS.LM2$pval.pca[snps.assoc]
ncol(snps)
0.0000000029
0.0000000029*10000
PCA.RESULTS2$pval.pca[snps.assoc]
0.00009
0.00009*10000
pval2 <- numeric(0)
# system.time( # 120.78
for(i in 1:ncol(snps)){
## LM: ##
# foo <- lm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]  + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9])) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
# ANOVA <- anova(foo, test="Chisq")
# pval2[i] <- ANOVA$"Pr(>F)"[1]
## GLM: ##
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]  + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]), family="gaussian")) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
# ANOVA <- anova(foo, test="Chisq")
# pval2[i] <- ANOVA$"Pr(>Chi)"[2]
} # end for loop
pval.pca <- pval2
## Get results:
p.thresh <- p.value # 0.01
pca.snps.uncorrected <- snps.names[which(pval.pca < p.thresh)]
p.vals.bonf <- p.adjust(pval.pca, "bonferroni")
p.bonf <- which(p.vals.bonf < p.thresh)
pca.snps.bonf <- snps.names[p.bonf]
## Store results:
pca.results <- list(snps.corrected.pca, pval.pca, pca.snps.uncorrected, pca.snps.bonf)
names(pca.results) <- c("snps.corrected.pca", "pval.pca", "pca.snps.uncorrected", "pca.snps.bonf")
print("PCA done")
#############################
## CHECK:
print("n.grp"); print(n.grp)
print("NAs?"); print(any(is.na(pval.pca)))
print("pca.snps.uncorrected"); print(length(pca.results$pca.snps.uncorrected))
print("pca.snps.bonf"); print(length(pca.results$pca.snps.bonf))
PCA.RESULTS.GLM2 <- pca.results
PCA.RESULTS.LM2$pval.pca[snps.assoc]
PCA.RESULTS.GLM2$pval.pca[snps.assoc]
i <- 1
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]  + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]), family="binomial"))
summary(foo)
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="binomial"))
summary(foo)
summary(foo)$coefficients[,'Pr(>|Z|)'][2]
summary(foo)$coefficients[,'Pr(>|z|)'][2]
pval2 <- numeric(0)
# system.time( # 120.78
for(i in 1:ncol(snps)){
## LM: ##
# foo <- lm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]  + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9])) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
## ANOVA <- anova(foo, test="Chisq")
## pval2[i] <- ANOVA$"Pr(>F)"[1]
#####
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="binomial"))
pval2[i] <- summary(foo)$coefficients[,'Pr(>|z|)'][2]
## GLM: ##
# foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]  + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]), family="gaussian"))
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
## ANOVA <- anova(foo, test="Chisq")
## pval2[i] <- ANOVA$"Pr(>Chi)"[2]
} # end for loop
pval.pca <- pval2
n.grp <- 5
## Get results:
p.thresh <- p.value # 0.01
pca.snps.uncorrected <- snps.names[which(pval.pca < p.thresh)]
p.vals.bonf <- p.adjust(pval.pca, "bonferroni")
p.bonf <- which(p.vals.bonf < p.thresh)
pca.snps.bonf <- snps.names[p.bonf]
## Store results:
pca.results <- list(snps.corrected.pca, pval.pca, pca.snps.uncorrected, pca.snps.bonf)
names(pca.results) <- c("snps.corrected.pca", "pval.pca", "pca.snps.uncorrected", "pca.snps.bonf")
print("PCA done")
#############################
## CHECK:
print("n.grp"); print(n.grp)
print("NAs?"); print(any(is.na(pval.pca)))
print("pca.snps.uncorrected"); print(length(pca.results$pca.snps.uncorrected))
print("pca.snps.bonf"); print(length(pca.results$pca.snps.bonf))
pca.snps.bonf
snps.assoc
PCA.RESULTS.GLMB <- pca.results
?anova
?test
?wald
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="binomial"))
ANOVA <- anova(foo, test="Chisq")
ANOVA$"Pr(>Chi)"[2]
ANOVA <- anova(foo, test="Wald")
wald.test(b = coef(foo), Sigma = vcov(foo), Terms = 1:6)
??wald.test
install.packages("aod")
library(aod)
?wald.test
wald.test(b = coef(foo), Sigma = vcov(foo), Terms = 1:6)
i <- 1
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="binomial"))
wald.test(b = coef(foo), Sigma = vcov(foo))
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2:5)
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)
foo <- lm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5])) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)
PCA.RESULTS.LM$pval.pca[1]
snps.asspc
snps.assoc
i <- 1382
PCA.RESULTS.LM$pval.pca[1382]
foo <- lm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5])) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)
str(wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2))
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)$result$chi2["P"]
wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)$result$chi2["P"]*10000
pval2 <- numeric(0)
# system.time( # 120.78
for(i in 1:ncol(snps)){
## LM: ##
# foo <- lm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5])) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
## ANOVA <- anova(foo, test="Chisq")
## pval2[i] <- ANOVA$"Pr(>F)"[1]
## GLM (binomial): ##
foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="binomial"))
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|z|)'][2]
# library(aod)
pval2[i] <- wald.test(b = coef(foo), Sigma = vcov(foo), Terms=2)$result$chi2["P"]
## GLM: ##
# foo <- suppressWarnings(glm(phen ~ (snps[,i] + pca1$li[, 1] + pca1$li[, 2] + pca1$li[, 3] + pca1$li[, 4] + pca1$li[, 5]), family="gaussian")) # + pca1$li[, 6] + pca1$li[, 7] + pca1$li[, 8] + pca1$li[, 9]
# pval2[i] <- summary(foo)$coefficients[,'Pr(>|t|)'][2]
## ANOVA <- anova(foo, test="Chisq")
## pval2[i] <- ANOVA$"Pr(>Chi)"[2]
} # end for loop
pval.pca <- pval2
## Get results:
p.thresh <- p.value # 0.01
pca.snps.uncorrected <- snps.names[which(pval.pca < p.thresh)]
p.vals.bonf <- p.adjust(pval.pca, "bonferroni")
p.bonf <- which(p.vals.bonf < p.thresh)
pca.snps.bonf <- snps.names[p.bonf]
## Store results:
pca.results <- list(snps.corrected.pca, pval.pca, pca.snps.uncorrected, pca.snps.bonf)
names(pca.results) <- c("snps.corrected.pca", "pval.pca", "pca.snps.uncorrected", "pca.snps.bonf")
print("PCA done")
#############################
## CHECK:
print("n.grp"); print(n.grp)
print("NAs?"); print(any(is.na(pval.pca)))
print("pca.snps.uncorrected"); print(length(pca.results$pca.snps.uncorrected))
print("pca.snps.bonf"); print(length(pca.results$pca.snps.bonf))
PCA.RESULTS.GLMBW <- pca.results
?glm
?lm
evalStats <- get(load("/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set3/coaltree/parsimony/set3_coal_1_80_treeWAS_ALL_all_tests_best_thresh_evalStats.Rdata"))
str(evalStats)
summary(evalStats$n.phen.subs)
(34-6)
(34-6)/40
library(treeWAS)
source('~/treeWAS/pkg/R/treeWAS.R')
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
## reconstruction
str(snps.reconstruction)
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
ix
ix <- c(1,2,3)
toRemove <- rownames(snps)[ix]
## Remove individuals from all elements...
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
data(snps)
data(phen)
data(tree)
## Examine data:
## genetic data
str(snps)
## phenotype
data(snps.reconstruction)
## reconstruction
str(snps.reconstruction)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
all(suffixes %in% c(".a", ".c", ".g", ".t"))
snps <- get.binary.snps(snps)
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- c(1,2,3)
toRemove <- rownames(snps)[ix]
## Remove individuals from all elements...
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
str(snps.reconstruction)
SR <- snps.reconstruction
sr <- asr(snps, tree, "parsimony")
str(sr)
sr <- sr$var.rec
str(SR)
str(sr)
all(rownames(SR) %in% rownames(sr))
document()
library(devtools)
document()
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
str(snps.reconstruction)
names(phen)
toRemove <- names(phen)[1]
toRemove <- names(phen)[c(1,5)]
phen <- phen[-which(names(phen) %in% toRemove)]
snps.ini <- snps
snps <- snps[-which(rownames(snps) %in% toRemove), ]
## remove individuals from tree:
tree <- drop.tip(tree, tip = toRemove)
str(snps.ini)
str(snps)
is.matrix(snps.reconstruction)
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
is.null(toKeep)
NA.tab <- sapply(c(1:ncol(snps)), function(e) length(which(is.na(snps[,e]))))
toRemove <- which(NA.tab > floor(nrow(snps)/2)) # Remove columns w > 50% of NAs
toRemove
ncol(snps)
length(toRemove)
snps.ini <- snps
snps <- snps[, -toRemove]
snps <- snps.ini
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
toRemove <- rownames(snps)[which(NA.tab == ncol(snps))] # Remove ENTIRELY missing rows...
length(toRemove)
toRemove <- which(NA.tab > floor(ncol(snps)*0.75))
length(toRemove)
toRemove <- which(NA.tab > floor(nrow(snps)/2))
length(toRemove)
identical(as.character(rownames(snps)), as.character(tree$tip.label))
ord <- match(tree$tip.label, rownames(snps))
ord
snps.ini <- snps
snps <- snps[ord,]
identical(as.character(rownames(snps)), as.character(tree$tip.label))
identical(as.character(rownames(snps.reconstruction)), as.character(tree$tip.label))
ord <- match(tree$tip.label, rownames(snps.reconstruction))
snps.rec.ini <- snps.reconstruction
snps.reconstruction <- snps.reconstruction[ord,]
identical(as.character(rownames(snps.reconstruction)), as.character(tree$tip.label))
identical(as.character(names(phen)), as.character(tree$tip.label))
toChange <- which(tree$edge.length < 0)
toChange
length(toChange)
source('~/treeWAS/pkg/R/treeWAS.R')
phen.rec.method <- levs <- NULL
phen.ori <- phen
## Convert to numeric (required for assoc tests):
na.before <- length(which(is.na(phen)))
## CHECK for discrete vs. continuous:
## NB: can only be binary or continuous at this point...
levs <- unique(as.vector(unlist(phen)))
n.levs <- length(levs[!is.na(levs)])
n.levs
levs
phen.rec.method <- "discrete"
!is.numeric(phen)
all.is.numeric(phen)
phen <- as.numeric(as.factor(phen))
phen
document()
library(treeWAS)
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
## Examine data:
## genetic data
str(snps)
## phenotype
str(phen)
table(phen)
## tree
str(tree)
## genetic data reconstruction:
str(snps.reconstruction)
data(phen.plot.col)
## Plot tree showing phenotype:
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes, cex=0.5)
tiplabels(text=tree$tip.label, cex=0.5, adj=c(-0.5, 0), col=leafCol, frame="none")
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
source('~/treeWAS/pkg/R/plot.phen.R')
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
snps.assoc
all(suffixes %in% c(".a", ".c", ".g", ".t"))
snps <- get.binary.snps(snps)
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
length(ix)
ix <- c(1,5)
toRemove <- rownames(snps)[ix]
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
## drop tips from tree:
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
## (Example only, if needed for user data)
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
str(snps)
unique(snps)
unique(as.vector(unlist(snps)))
unique(as.vector(unlist(snps[!is.na(snps)])))
?unique
unique(as.vector(unlist(snps[!is.na(snps)])), incomparables = NA)
unique(as.vector(unlist(snps)), incomparables = NA)
length(unique(as.vector(unlist(snps[!is.na(snps)]))))
source('~/treeWAS/pkg/R/treeWAS.R')
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
print(out)
snps.assoc
source('~/treeWAS/pkg/R/get.sig.snps.R')
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
document()
library(treeWAS)
data(snps)
data(phen)
data(tree)
data(snps.reconstruction)
data(phen.plot.col)
## Plot tree showing phenotype:
plot.phen(tree, phen.nodes=phen.plot.col$all.nodes)
suffixes <- keepLastN(colnames(snps), n = 2)
suffixes <- unique(suffixes)
is.matrix(snps.reconstruction)
snps <- get.binary.snps(snps)
snps.reconstruction <- snps.reconstruction[, which(colnames(snps.reconstruction) %in% colnames(snps))]
NA.tab <- sapply(c(1:nrow(snps)), function(e) length(which(is.na(snps[e,]))))
ix <- which(NA.tab == ncol(snps))
if(length(ix) > 0){
toRemove <- rownames(snps)[ix]
## Remove individuals from all elements...
snps <- snps[-which(rownames(snps) %in% toRemove), ]
phen <- phen[-which(names(phen) %in% toRemove)]
## ... Including optional elements (if present):
## drop tips from tree:
tree <- drop.tip(tree, tip = toRemove)
## drop rows from snps.rec:
## (Example only, if needed for user data)
if(is.matrix(snps.reconstruction)){
nodes <- sort(unique(as.vector(unlist(tree$edge))), decreasing=FALSE)
nodes <- nodes[(nrow(snps)+1):length(nodes)]
toKeep <- which(rownames(snps.reconstruction) %in% rownames(snps))
toKeep <- c(toKeep, nodes)
snps.reconstruction <- snps.reconstruction[toKeep, ]
}
}
out <- treeWAS(snps = snps,
phen = phen,
tree = tree,
n.subs = NULL,
n.snps.sim = ncol(snps)*10,
chunk.size = ncol(snps),
test = c("terminal", "simultaneous", "subsequent"),
snps.reconstruction = "parsimony",
snps.sim.reconstruction = "parsimony",
phen.reconstruction = "parsimony",
na.rm = TRUE,
p.value = 0.01,
p.value.correct = "bonf",
p.value.by = "count",
dist.dna.model = "JC69",
plot.tree = FALSE,
plot.manhattan = TRUE,
plot.null.dist = TRUE,
plot.dist = FALSE,
snps.assoc = NULL,
filename.plot = NULL,
seed = 1)
snps.assoc
str(snps)
snps.assoc
data(snps)
str(snps)
library(treeWAS)
data(snps)
snps.assoc
snps.assoc
