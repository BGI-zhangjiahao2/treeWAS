{
    "collab_server" : "",
    "contents" : "\n\n##########\n## GWAS ##\n##########\n\n## see pdf link below for origin of points to follow\n# http://www.montefiore.ulg.ac.be/~kvansteen/GeneticEpi-UA2/Class5/Introduction%20to%20GenABEL.pdf\n\n# Install packages\ninstall.packages(\"adegenet\")\n\n# load packages\nlibrary(adegenet)\n\n# Load data\nread.csv(\"file.csv\")\ndat <- get(load(\"file.Rdata\"))\n\n# Check data\ndim(dat)\nsummary(dat)\nhead(dat)\n\n# Convert data\n## Make a genpop object to store all your data in a compressed form\ndat <- new(\"genind\", dat)\n\n# Check data again\nhead(as.matrix(dat))\n\n# Check for missing data\n## Visualise-check for patterns indicative of systematic error in data\n\n## Correct/ replace/ remove missing\n\n# Examine the trait/ phenotype among individuals\ntable(dat@pop)\nsummary(dat@pop)\nhist(dat@pop) # or a different type of plot...\n\n# Inspect all data available for one individual\n## Take a look at all the slots of a genind object\ndat[1,]\n\n# Get summary for markers 2 & 3, eg. \n## Take a look at all data/ data summary available for each marker\nsummary(dat[,2:3])\n\n\n# Check for Confounding-- Run univariate test-Is the SNP correlated with any counfounder variables (eg. sex)? \n####################################################################################################################################################\n####################################################################################################################################################\n\n##########################################################################\n## NOTE--CHECK YOUR ACME STUFF FOR THESE PRECURSOR STEPS!!!!!!!!!!!!!!\n## GO TO LINE 1039 FOR ANALYSIS WITH CORRECTION FOR POP STRAT\n## AND INCORPORATE THE FOLLOWING PRECURSOR QC STEPS FOR YOUR EXAMPLE DATA:\n##########################################################################\nglm2<-glm(arcA ~ DAP_E + Mortality + Vanc_w.30 + Septic_Shock + Sepsis\n          + Microbroth_MIC + Initial_Vanc_Etest, data=dat.clean, family=\"quasibinomial\")\ndropterm(glm2, test=\"Chisq\")\n# \n# ## Clearly there is an association between arcA and Initial vancomycin Etest, \n# # and also an association with Sepsis that is verging on significant! \n# \ntable(dat.clean$arcA, dat.clean$Initial_Vanc_Etest)\n# \n# # There appears to be a correlation between absence of the ACME element in the accessory genome  \n# # (as determined by a negative PCR test for the arcA gene) and a negative result on the initial \n# # vancomycin Etest. \n# \n# ## This association between clinical measurements is interesting, and it is hypothesized that DAPC  \n# # will give overlapping results for arcA and the initial vancomycin Etest iff the SNPs underlying \n# # both these changes remain significant after correcting for population stratification and share\n# # links to both phenotypes. \n# \ntable(dat.clean$arcA, dat.clean$Sepsis)\n# \n# # It appears that a minor association exists between absence of the ACME element and presence of sepsis.\n##########################################################################\npca2arcA<-dudi.pca(scaleGen(snps.arcA, scale=FALSE, missing=\"mean\")[-333,],\n                   scale=FALSE, scannf=FALSE, nf=100)\nsave(pca2arcA, file=\"ROutput/ST239/Robjects/pca2arcA.RData\")\n\nload(\"ROutput/ST239/Robjects/pca2arcA.RData\")\n\npca2<-pca2arcA\n\nbarplot(pca2$eig[1:100], main=\"PCA eigenvalues\")\n\n# From visible inspection, it appears that the first 3 PCs contain most of the variation\n# (but we can look into this statistically using Paschou's or TW's method later...)\n\ns.label(pca2$li, sub=\"PCA: PCs 1 and 2\")\n\n# At this resolution, it is difficult to identify the number of distinct bacterial lineages in the data\n# Clustering methods will allow us to use the first 3 PCs (which are likely to contain most of the population structure)\n# to map out a dendrogram based on the squared Euclidean distances between individuals on these PCs.\n\nD<- dist(pca2$li[,1:3])^2\nclust<-hclust(D, method=\"complete\")\nplot(clust, main=\"Complete-Linkage Clustering of ST239 Based on the First 4 PCs of PCA\") # 5 clusters...\n\n# While our definition of a \"population\" depends on the degree of resolution we desire, we can certainly say at this\n# point that at least 5 clusters contribute to overall population structure. We will now define these clusters:\n\npop <- factor(cutree(clust, k=5))\n\n# We can now visualize this major population substructure in PCA space:\npar(mfrow=c(1,2))\ns.class(pca2$li, fac=pop, col=transp(funky(5)), cpoint=2, sub=\"PCA: PCs 1 and 2\")\n## IF YOU DO CORRECT FOR POP STRAT, repeat this/ these plots (keeping pop) to show that no pop structure remains\n\n# What does the third axis contribute?\n\ns.class(pca2$li, xax=1, yax=3, fac=pop, col=transp(funky(5)), cpoint=2, sub=\"PCA: PCs 1 and 3\")\n##########################################################################\n################################################################################################\n## CORRECTING FOR POP STRUCTURE #######################################\n################################################################################################\nsnps.corrected <- truenames(na.replace(as.genind(snps), method=\"mean\"))#[-333,] # no missing values for simGWAS...\ntoRemove <- apply(snps.corrected,2, function(e) length(unique(e))<2)\nsum(toRemove)\nsnps.corrected <- snps.corrected[,!toRemove]\n\n\n#snps.corrected <- apply(snps.corrected, 2, function(e) residuals(lm(e~pca2$li[,1]+pca2$li[,2]+pca2$li[,3])))\n\n## for simGWAS:\nsnps.corrected <- apply(snps, 2, function(e) residuals(lm(e~pca2$li[,1]+pca2$li[,2]+pca2$li[,3]+pca2$li[,4]))) # may take a minute\n##########################################################################\n##########################################################################\n\n####################################################################################################################################################\n####################################################################################################################################################\n\n## ... Continue with Check for Confounding: \n\ntab <- table(pop(dat), dat$sex)\nfisher.test(tab)\n\n## In practical--HERE, Run pop structure analyses--visualise, correct with Genomic Control, PCA-based rescaling (EIGENSTRAT) \n####and compare results (+ compare to no correction)--discuss pros and cons of correcting and pros/cons of each method of correcting ... \n\n\n# Test for association--Run univariate test-Is the SNP correlated with the response/ outcome/ phenotype/ trait of interest?\nboxplot(pop(dat) ~ dat[,1],\n        names = c(\"Controls\", \"Cases\"),\n        ylab = \"Response\"\n        )\n\n# Quality Control\n## DO a simple QC\nqc1 <- check.marker(dat, call = 0.95, perid.call = 0.95, maf = 1e-08, p.lev = 1e-08)\ndat.clean <- dat[qc1$idok, qc1$snpok]\n## DO a simple association test\nbt <- dat[,1] #??\nresponse <- pop(dat) #??\nan <- qtscore(bt ~ response, dat, \n              trait.type=\"binomial\", times=1)\nsummary(an, top=5)\n\n# Association test\n## Q-Q plot\n## What is lambda (show Q-Q plot)\nestlambda(an[,\"P1df\"]) # from pkg GenABEL\n# plot, $estimate, $se are of interest... \n\n## Manhattan plot\nplot(an, \n     col = c(\"red, \"stateblue\"\"), pch = 19, cex = 0.5, df = \"1\")\n\nbonferroni <- -log10(0.05 / ncol(as.matrix(dat))) # divided by n.snps\nabline(h=bonferroni, col=\"red\")\n\n\n# Vouches for GenABEL for ease of comparing different approaches\n## Suggest, \"load your data and enjoy:\"\n### Simple assocation tests\n### Genomic Control\n### PCA-based correction--Eigenstrat\n### Mixed models\n### Structured association\n### Any combo of above! \n\n\n\n#\n\n\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n\n\n######################################\n## GWAS Simple Examples for LECTURE ##\n######################################\n\n#######################\n## PACKAGES REQUIRED ##\n#######################\nlibrary(glmnet)\nlibrary(adegenet)\n\n##############\n## The DATA ##\n##############\n\n## useful parameters for simulating datasets...\n\n# k <- rep_len(c(1:5), n)                                           # range k (n.ancestral.pops) in [1,5]\n# n.ind <- round(((200 - (10*k))*LHSvalues[,1]) + 10*k)            # ranges n.ind in [10k, 1000]\n# n.snp.struc <- round(((100 - 5)*LHSvalues[,2]) + 5)               # ranges n.snp.struc in [5,100]\n# n.snp.nonstruc <- round(((100000 - 1000)*LHSvalues[,3]) + 1000)     # ranges n.snp.nonstruc in [1000, 200000]\n# grpA.size <- round((((0.5-0.1)*LHSvalues[,4])+0.1), 4)            # ranges grpA.size in [0.1, 0.5]\n# \n# alpha <- round(((0.5)*LHSvalues[,5]),4)                           # ranges alpha in [0, 0.5]\n# block.size <- round(((10000-1000)*LHSvalues[,6]) + 1000)                # ranges block size in [1000, 10000]            \n# \n# LD <- sample(c(FALSE, TRUE, TRUE), n, replace=TRUE)               # establishes LD scheme (with theta)\n# theta <- sample(c(0, 0.2), n, replace=TRUE)                       # ranges theta (LD dilution) in [0, 0.2]\n\n\n###################################################################################################################\n############################################################################################################\n############################################################################################################\n############################################################################################################\n######################################  ... arcA example .... ##############################################\n\n################################################################################################\n################################################################################################\n#######       WITHOUT correcting for pop structure with arcA: ######################################\n################################################################################################\n\n\nload(\"ROutput/ST239/Robjects/snps.RData\")\nload(\"ROutput/ST239/Robjects/dnaClean.Rdata\")\nload(\"ROutput/ST239/Robjects/datClean.Rdata\")\n\ndat.old <- dat\n\nlength(seg.sites(dna))\n\nsnps <- DNAbin2genind(dna, polyThres=0.0001)\nsave(snps, file=\"Robjects/snps.RData\")\n\nload(\"ROutput/ST239/Robjects/snps.Rdata\")\n\nstr(snps)\n\nsnps.noNA<- truenames(na.replace(snps, method=\"mean\"))[-333,] # 65521 missing replaced\ntoRemove <- apply(snps.noNA,2, function(e) length(unique(e))<2)\nsum(toRemove)\nsnps.noNA <- snps.noNA[,!toRemove]\ndim(snps.noNA)\nsave(snps.noNA, file=\"ROutput/ST239/Robjects/snps.noNA\")\nload(\"ROutput/ST239/Robjects/snps.noNA\")\nstr(snps.noNA)\ndimnames(snps.noNA)[2]\n\nstr(dat.old$arcA)\ntable(dat.old$arcA)\nstr(dat)\n\nV<-as.vector(dat.old$arcA)\nstr(V) #336\nV<-V[-333]\ntoRemove <- which(is.na(V)) \nVmod <-V[-toRemove]\nstr(Vmod) # 328\nVF <- factor(Vmod)\nsnps.arcA<-snps.noNA[-toRemove,]\ndim(snps.arcA) # 328 11415\nclass(snps.arcA) # matrix\n\npca2arcA<-dudi.pca(snps.arcA, scale=FALSE, scannf=FALSE, nf=100)\nsave(pca2arcA, file=\"ROutput/ST239/Robjects/pca2arcA.RData\")\nload(\"ROutput/ST239/Robjects/pca2arcA.RData\")\n\n\n\npca2<-pca2arcA\npca2\n\nmyCol<-colorRampPalette(c(\"blue\", \"gold\", \"red\"))\ns.class(pca2$li, fac=VF, col=transp(myCol((nlevels(VF)))), cpoint=2)\ns.class(pca2$li, fac=VF, xax=3, yax=2, col=transp(myCol((nlevels(VF)))), cpoint=2)\n\n\n#\n##########################\n\npar(mfrow=c(1,1))\n\n\narcA<-dat.old$arcA\nnames(arcA)<-row.names(dat.old)\narcA<-arcA[-333]\narcA<-arcA[!is.na(arcA)]\narcA<-arcA[names(arcA)%in%rownames(snps.corrected)]\narcA<-factor(arcA)\ntable(arcA)\n\n###########\nsnps <- snps.arcA\nphen <- arcA\n\nsave(snps, file=\"~/Leuven/Rcode/snps-arcA.Rdata\")\nload(\"~/Leuven/Rcode/snps-arcA.Rdata\")\n\nsave(phen, file=\"~/Leuven/Rcode/phen-arcA.Rdata\")\nload(\"~/Leuven/Rcode/phen-arcA.Rdata\")\n\n\n############################################################################################################\n############################################################################################################\n############################################################################################################\n######################################  ^^^ arcA example ^^^^ ##############################################\n\n\n\n##############################\n## Make a Simulated Dataset ##\n##############################\n\n################\n# Use pre-existing dataset instead???\n#data(microbov)\ndata(sim2pop)\nsimpop <- sim2pop\nsnps <- as.matrix(simpop)\nphen <- pop(simpop)\nset.seed(1)\n#########\n\n\n\n##############\n## new dataset with glSim, then shuffle! \n## if n.snp.nonstruc is large enough, univar should struggle, and if n.snp.struc is large enough, glm should too...\nset.seed(2) # seed(1), k=0: glm=7/20, dapc=7/20, univ=10/20\nsimpop <- glSim(n.ind=100, n.snp.nonstruc=1000, n.snp.struc=0, block.minsize=1000, block.maxsize=1000, k=4)\nsnps <- as.matrix(simpop)\nphen <- pop(simpop)\nglPlot(simpop)\n##############\n\n# set.seed(1)\n# #simpop <- glSim(n.ind = 200, n.snp.nonstruc = 10000, n.snp.struc = 10)\n# simpop <- glSim(n.ind = 100, n.snp.nonstruc = 1000, n.snp.struc = 20)\n# snps <- as.matrix(simpop)\n# phen <- simpop@pop\n\n################################################################################################\n## Test of Association (GWAS) ##################################################################\n################################################################################################\n\n# n.pca <- seq(1, nrow(Output1b), by=5)\n# n.pca <- Output1b$ward[n.pca]\n# n.pca <- n.pca[as.integer(row.names(toTest))]\n# n.pca.toTest <- n.pca\n\nsave(n.pca.toTest, file=\"~/Leuven/Rcode/testLHSdatanpca.Rdata\")\nsave(toTest, file=\"~/Leuven/Rcode/testLHSdatan.snp.struc200orLess.Rdata\")\n\nfor(i in 41:150){\n  \n  set.seed(1)\n  \nn.ind <- toTest[i,1]\nn.snp.nonstruc <- toTest[i,2]\nn.snp.struc <- toTest[i,3]\ngrp.size <- toTest[i,4]\ngrp.size <- c(grp.size, n.ind-grp.size)\nalpha <- toTest[i,5]\n\nsimpop <- glSim(n.ind=n.ind, n.snp.nonstruc=n.snp.nonstruc, n.snp.struc=n.snp.struc, grp.size=grp.size, alpha=alpha)\nsnps <- as.matrix(simpop)\nphen <- simpop@pop\n\n\n## univariate\npval <- apply(snps, 2, function(e) fisher.test(table(factor(e, levels=c(0,1)), phen))$p.value)\nmin(pval) # 0.000049\nwhich(pval < 0.05)\nlength(which(pval < 0.05)) # 64 (19 of the 33)\nmin(p.adjust(pval, method=\"fdr\")) # 0.0931 for i=121 \nsnpsV.univariate <- which(p.adjust(pval, method=\"fdr\") < 0.05) # !  finds NO snps after correcting for pop structure (4 pcs)\n\nprint(\"ROUND I 1=41\"); print(i)\n\nprint(\"UNIVARIATE\")\nsnpsV.univariate\nlength(snpsV.univariate)\n\n## glm\nGLM <- cv.glmnet(snps, phen, family=\"binomial\", lambda.min.ratio=0.01, alpha=1)  \nbeta <- as.vector(t(coef(GLM, s=\"lambda.min\")))\nselected <- which(beta[-1] !=0)\nn.snp.selected.glm <- as.integer(length(selected))\nsnpsV.glm <- as.vector(selected)\nprint(\"GLM\")\nn.snp.selected.glm \nsnpsV.glm # still finds all 5 snps after correcting for pop structure w simGWAS 4pcs\n\n## dapc\n#n.pca <- as.integer(n.pca.toTest[i])\n\n## before correcting \nxval <- xvalDapc(snps.ori, phen)\ndapc1 <- xval[[7]]\n#dapc1 <- dapc(snps.ori, phen, n.pca=n.pca, n.da=1)\nresult <- snpzip(snps.ori, dapc1, method=\"single\", xval.plot = FALSE, plot = FALSE, loading.plot = TRUE)\n\n## with correction\nxval2 <- xvalDapc(snps, phen, plot=FALSE)\ndapc2 <- xval2[[7]]\nresult2 <- snpzip(snps, dapc2, method=\"ward\", xval.plot = FALSE, plot = TRUE, loading.plot = TRUE)\n## note: your y-axis changes scale, and the snps with larger contributions (except the structural snps) change\n\nn.snp.selected.dapc <- as.integer(result2$FS[[1]][1]) # 30 snps for cheater arcA\nsnpsV.dapc <- as.vector(result2$FS[[2]]) # a vector of the SNPs selected\nprint(\"DAPC\")\nn.snp.selected.dapc\nsnpsV.dapc\n\nlength(which(c((n.snp.nonstruc+1):(n.snp.nonstruc+n.snp.struc)) %in% snpsV.dapc)) # 17 w complete (selects 59; 33 snp.struc; i=121)\n\n\nn.snps <- n.snp.struc\nout <- c(length(snpsV.univariate),  n.snp.selected.glm, n.snp.selected.dapc, n.snps)\nnames(out) <- c(\"UNIVAR\", \"GLM\", \"DAPC\", \"Total\")\nprint(out)\n\n\nprint(names(out)[which(out %in% max(out))])\n\nif(is.integer(i/10)) gc()\n}\n\n\n############################################\n## Univariate FS with Fisher's exact test ##\n############################################\npval <- apply(snps, 2, function(e) fisher.test(table(factor(e, levels=c(0,1)), phen))$p.value) # get p-values for fisher's exact test of each snp vs. phen \nmV <- which(pval < (0.05/length(pval))) # bonferonni correction\nsnpsV.univariate <- as.vector(mV)\nn.snp.selected.univariate <- length(mV)\nn.snp.selected.univariate # 269\nsnpsV.univariate\n\n# 6022.c   6022.t   8765.c   8765.t  15102.g  15102.a  23563.g  23563.t  26008.c  26008.t  43450.g  43450.t  47173.a \n# 491      492      705      706     1467     1468     2045     2046     2396     2397     3786     3787     4110 \n# 47173.t  47325.g  47325.a  51356.c  51356.t  53199.c  53199.a  73084.a  73084.g  78578.g  78578.a  83478.t  83478.c \n# 4111     4132     4133     4589     4590     5047     5048     6780     6781     7118     7119     7666     7667 \n# 92349.a  92349.g  97383.g  97383.a 107309.g 107309.a \n# 8918     8919     9264     9265    10111    10112 \n\n## FDR\n#?p.adjust\nfoo <- p.adjust(pval, method=\"fdr\")\ntoRemove <- which(foo <0.05)\ntoRemove\ntoKeep <- which(toRemove %in% snpsV.dapc.ward)\n\ntoRemove <- toRemove[-toKeep] # removed 376 snps\n\nsnps.ori <- snps\nsnps <- snps[,-toRemove]\nsave(snps, file=\"~/Leuven/Rcode/snps.arcA.cheater.Rdata\")\nload(\"~/Leuven/Rcode/snps.arcA.cheater.Rdata\")\ndim(snps) # 328 11039\n\nsnpsV.univariate <- which(p.adjust(pval, method=\"fdr\") < 0.05)\nsnpsV.univariate\nlength(snpsV.univariate) # 32 with cheater2! # 32 with cheater1 (was 410 with original snps, before any cheating)\n\n\n###############################\n## DAPC-based FS with snpzip ##\n###############################\nset.seed(1) # arcA: 50 PCs (mean success ~92% with cheater2)\nxval <- xvalDapc(snps, phen, result=\"groupMean\")\n\ndapc1 <- xval[[7]]\nscatter(dapc1)\n\npar(ask=FALSE)\ndapc1 <- dapc(snps, phen, n.pca=50, n.da=1)\n## --> 66 snps with both methods?!\nresult <- snpzip(snps, dapc1, method=\"complete\", xval.plot = TRUE, plot = TRUE, loading.plot = TRUE) \nresult <- snpzip(snps, dapc1, method=\"ward\", xval.plot = FALSE, plot = FALSE, loading.plot = TRUE) \n\n##\nresult <- snpzip(snps, phen, method=\"ward\", xval.plot = TRUE, plot = TRUE, loading.plot = TRUE) \n\nn.snp.selected.dapc.single <- as.integer(result$FS[[1]][1]) # 30 snps for cheater arcA\nsnpsV.dapc.single <- as.vector(result$FS[[2]]) # a vector of the SNPs selected\n\nn.snp.selected.dapc.ward <- as.integer(result$FS[[1]][1]) # 58 snps for cheater arcA # 30 for cheater2 # 55 for ch3\nsnpsV.dapc.ward <- as.vector(result$FS[[2]]) # a vector of the SNPs selected\n\n##save just the 66 snps\nsnps <- snps[,snpsV.dapc.ward]\n\nall(snpsV.dapc.ward %in% snpsV.univariate) # TRUE\nwhich(!snpsV.univariate %in% snpsV.dapc.ward)\n\nn.snp.selected.dapc\nsnpsV.dapc\n\npar(ask=FALSE)\n######################\n## LASSO regression ##\n######################\nrequire(glmnet)\n\n# we use the binomial distribution when the response is categorical with 2 possible outcomes. \n# note: the tuning parameter lambda controls the overall strength of the penalty...\n# IF n.obs > n.vars, 0.0001 is the default for lambda.min.ratio\n# BUT if n.obs < n.vars, the defult is 0.01. (here, a very small value of lmr will --> a saturated fit...)\n\n# note: # alpha = 1 is LASSO, alpha=0 is ridge... \n# lasso tends to select one of a set of correlated predoctors, while ridge tends to shrink all their coefficients together. \n# setting alpha = 0.5 usually selects groups of correlated predictors together (where they exist).\nGLM <- cv.glmnet(snps, phen, family=\"binomial\", lambda.min.ratio=0.01, alpha=1) \n\nplot(GLM) # plots the log(Lambda) against binomial deviance/ MSE\nplot(GLM$glmnet.fit) # plots the L1 norm against the values for the coefficients (so you can see how they shrink and when they hit zero). \n\nGLM$lambda.min # the \"best\" lambda selected by k-fold cross-validation (criterion = lowest Mean Squared Error) \nbeta <- as.vector(t(coef(GLM, s=\"lambda.min\")))\nselected <- which(beta[-1] !=0)\nn.snp.selected.glm <- as.integer(length(selected))\nsnpsV.glm <- as.vector(selected)\nn.snp.selected.glm # 118 with cheater1, ONLY 3 w cheater2!# 3 w cheater3 (1 bad) \n# 159 w elasticNet for cheater3...(30 of these identical to univariate, but only 1 identical to dapc)\nsnpsV.glm\n\nlength(which(mV.glm %in% snpsV.dapc.ward)) # 0\n\ntoRemove <- snpsV.glm\nsnps2 <- snps[,-toRemove]\nsnps.ori.cheater <- snps\nsnps <- snps2\ndim(snps) # 328 10921\nsave(snps, file=\"~/Leuven/Rcode/snps.arcA.cheater2.Rdata\")\nload(\"~/Leuven/Rcode/snps.arcA.cheater2.Rdata\")\n\n\ntoKeep <- which(snpsV.dapc.ward %in% snpsV.glm)\ntoRemove <- snpsV.glm[-toKeep]\nlength(toRemove) # 103 # 92\nwhich(snpsV.dapc.ward %in% snpsV.univariate)\n\nsnps <- snps[,-toRemove]\n\n##\nload(\"~/Leuven/Rcode/snps.arcA.cheater.Rdata\")\ntoRemove2 <- sample(toRemove, 70)\nsnps <- snps[,-toRemove2]\n\nsave(snps, file=\"~/Leuven/Rcode/snps.arcA.cheater3.Rdata\")\nload(\"~/Leuven/Rcode/snps.arcA.cheater3.Rdata\")\n##\n\n\nwhich(snpsV.glm %in% snpsV.univariate) # 55 65 66 # --> 0 \n\nsnpsV.glm\nsnpsV.dapc       \nsnpsV.univariate\n\n#######################################\n## Summarise Results from any Method ##\n#######################################\n\ncolnames <- colnames(snps, do.NULL=FALSE, prefix=NULL) # Creates SNP names to cross-reference the selected and true \"structural\" SNPs\nsnpsV <- as.integer(colnames)\nsnp.struc <- as.integer(tail(snpsV, n.snp.struc))\n\nTP <- sum(mV%in%snp.struc) # True positives\nFN <- n.snp.struc-TP # False negatives\nFP <- length(mV)-TP # False positives\nTN <- ((length(snpsV)-n.snp.struc)-(n.snp.struc-TP)-(length(mV)-TP)) # True negatives\n\nsensitivity <- (TP/(TP+FN)) # calculates Sensitivity (\"Recall\")\nFPR <- (FP/(FP+TN)) # calculates False Positive Rate \nPPV <- (TP/(TP+FP)) # calculates Positive Predictive Value (\"Precision\")\n\nanswer <- list(n.snp.selected, sensitivity, PPV, FPR)\nnames(answer)[[1]] <- \"n.snp.selected\"\nnames(answer)[[2]] <- \"sensitivity\"\nnames(answer)[[3]] <- \"PPV\"\nnames(answer)[[4]] <- \"FPR\"\n\nanswer\n\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#######################################################################################################################################################\n#\n\n\n\n# data(microbov)\n# \n# x.cows <- scaleGen(microbov, missing=\"mean\", scale=FALSE)\n# pca.cows <- dudi.pca(x.cows, center=FALSE, scale=FALSE,\n#                        +                      scannf=FALSE, nf=3)\n# barplot(pca.cows$eig)\n# s.class(pca.cows$li, fac=pop(microbov),\n#         + col=transp(funky(15),.6),\n#         + axesel=FALSE, cstar=0, cpoint=3)\n# add.scatter.eig(pca.cows$eig[1:50],3,1,2, ratio=.3)\n# \n# str(x.cows)\n# snps <- x.cows\n# phen <- microbov@pop\n# \n# ## correct for pop strat\n# snps.corrected <- apply(snps, 2, function(e) residuals(lm(e~pca.cows$li[,1]+pca.cows$li[,2]+pca.cows$li[,3])))\n# \n# pca.cows.corrected <- dudi.pca(snps.corrected, center=FALSE, scale=FALSE, scannf=FALSE, nf=3)\n# \n# ## just eigenvalues\n# barplot(pca.cows.corrected$eig)\n# \n# ## pca shows no strong group structure one snps corrected for pop structure\n# s.class(pca.cows.corrected$li, fac=pop(microbov),\n#         col=transp(funky(15),.6),\n#         axesel=FALSE, cstar=1, cpoint=3)\n# add.scatter.eig(pca.cows.corrected$eig[1:50],3,1,2, ratio=.22)\n# #?add.scatter.eig ## ^^ WHY ARE THERE CHUNKS OF WHITE THEN DARK GREY IN THE TRAILING EIGENVALUES??\n# \n# #s.class(pca2$li, fac=pop, col=transp(funky(5)), cpoint=2, sub=\"PCA: PCs 1 and 2\")\n# \n# \n# #####################################\n# \n# ## make a fake eg dist mat for your 5 snps --> hclust\n# \n# a <- 0.39\n# b <- 0.18\n# c <- 0.22\n# d <- 0.15\n# e <- 0.06\n# \n# a+b+c+d+e\n# \n# mat <- c(a,b,c,d,e)\n# mat <- as.matrix(mat)\n# D <- dist(mat)\n# temp <- as.data.frame(as.matrix(D))\n# \n# temp <- t(as.matrix(D))\n# temp <- temp[,ncol(temp):1]\n# \n# par(mar=c(6,5,5,1))\n# image(x=1:5, y=1:5, temp, col=rev(heat.colors(nlevels(as.factor(D)))),\n#       xaxt=\"n\", yaxt=\"n\",\n#       xlab=\"\",ylab=\"\")\n# axis(side=2, at=1:5, lab=rev(c(\"a\", \"b\", \"c\", \"d\", \"e\")), las=2, cex.axis=1.5)\n# axis(side=3, at=1:5, lab=c(\"a\", \"b\", \"c\", \"d\", \"e\"), las=1, cex.axis=1.5)\n\n# \n# clust <- hclust(D,method=\"complete\")\n# pop <- factor(cutree(clust,k=2,h=NULL))\n# m <- which.max(tapply(mat,pop,mean))\n# maximus<-which(pop==m)\n# popvect<-as.vector(unclass(pop))\n# n.snp.selected<-sum(popvect==m)\n# \n# plot(clust, labels=c(\"a\", \"b\", \"c\", \"d\", \"e\"), las=1)\n# \n# #thresh<- as.vector(mat)[maximus][(which.min(as.vector(mat)[maximus]))]\n# \n# $FS\n# $FS$`Number of selected vs. unselected alleles`\n# [1]    1   4\n# \n# $FS$`List of selected alleles`\n# [1] 1\n# \n# $FS$`Names of selected alleles`\n# [1] \"a\"\n# \n# $FS$`Contributions of selected alleles to discriminant axis`\n# 1        \n# 0.39  \n\n#################################################################################################################################\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# ####################################################################################################################################\n# ###\n# \n# ###\n# ###################################################\n# head(phen,10)\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# s.class(pca1$li, fac=phen, col=transp(c(\"royalblue\",\"red\")), cpoint=2,\n#         sub=\"PCA - axes 1 and 2\")\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# s.class(pca1$li, xax=3, yax=4, fac=phen, col=transp(c(\"royalblue\",\"red\")),\n#         cpoint=2, sub=\"PCA - axes 3 and 4\")\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# table(phen, pop)\n# chisq.test(table(phen, pop), simulate=TRUE)\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# dapc1 <- dapc(snps, phen, n.pca=30, n.da=1)\n# ###################################################\n# ###\n# \n# \n# \n# ###\n# ###################################################\n# dapc1 <- dapc(snps, phen)\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# dapc1\n# ###################################################\n# ###\n# phen\n# phen <- as.character(phen)\n# foo <- replace(phen, which(phen==\"NEG\"), \"Healthy\")\n# foo <- replace(foo, which(foo==\"POS\"), \"Diseased\")\n# foo <- as.factor(foo)\n# \n# dapc.red <- dapc(snps, foo, n.pca=3, n.da=1)\n# \n# \n# ## FOR ARCA FOR DAPC FISH EG IN PRES\n# scatter(dapc.red, bg=\"white\", scree.da=FALSE, scree.pca=FALSE,\n#         col=c(\"dodgerblue\",\"darkorange\"),\n#         legend=TRUE, posi.leg=\"topright\", xaxt=\"\", yaxt=\"\")\n# \n# ###\n# ###################################################\n# scatter(dapc1, bg=\"white\", scree.da=FALSE, scree.pca=TRUE,\n#         posi.pca=\"topright\", col=c(\"royalblue\",\"red\"),\n#         legend=TRUE, posi.leg=\"topleft\")\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# loadingplot(dapc1$var.contr)\n# ###################################################\n# ###\n# \n# \n# ###\n# ###################################################\n# sel.snps <- loadingplot(dapc1$var.contr, thres=0.004)\n# ###################################################\n# ###\n# \n# \n# \n# ###\n# ###################################################\n# sel.snps\n# ###################################################\n# ###\n",
    "created" : 1472757221756.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3000876711",
    "id" : "41CDCAE8",
    "lastKnownWriteTime" : 1414622288,
    "last_content_update" : 1414622288,
    "path" : "/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Teaching/Glasgow/Practical/GWAS.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}