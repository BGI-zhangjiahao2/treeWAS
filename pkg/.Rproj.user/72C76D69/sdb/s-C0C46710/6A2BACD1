{
    "collab_server" : "",
    "contents" : "\n######################\n## CMH TEST (2x2xk) ##\n######################\n\n?mantelhaen.test\n\n## Use the same K as DAPC...\n\n\n## sample sim data...\n\n# snps <- get(load(\"E:/treeWAS_Sims/set1/n.subs_1/set1_1_snps.Rdata\"))\n# phen <- get(load(\"E:/treeWAS_Sims/set1/n.subs_1/set1_1_phen.Rdata\"))\n# snps.assoc <- get(load(\"E:/treeWAS_Sims/set1/n.subs_1/set1_1_performance.Rdata\"))\n# snps.assoc <- snps.assoc$snps.assoc\n# tree <- get(load(\"E:/treeWAS_Sims/set1/n.subs_1/set1_1_tree.Rdata\"))\n\nsnps <- get(load(\"/media/caitiecollins/Seagate Backup Plus Drive/treeWAS_Sims/set1/n.subs_1/set1_1_snps.Rdata\"))\nphen <- get(load(\"/media/caitiecollins/Seagate Backup Plus Drive/treeWAS_Sims/set1/n.subs_1/set1_1_phen.Rdata\"))\nsnps.assoc <- get(load(\"/media/caitiecollins/Seagate Backup Plus Drive/treeWAS_Sims/set1/n.subs_1/set1_1_performance.Rdata\"))\nsnps.assoc <- snps.assoc$snps.assoc\ntree <- get(load(\"/media/caitiecollins/Seagate Backup Plus Drive/treeWAS_Sims/set1/n.subs_1/set1_1_tree.Rdata\"))\n\n\nsnps.ori <- snps.ori.ori\nphen.ori <- phen.ori.ori\n\n## Get colnames(snps)\nif(is.null(colnames(snps))) colnames(snps) <- c(1:ncol(snps))\nsnps.names <- colnames(snps)\n\n## First make sure PHEN is in BINARY form (0, 1) only!\nlevs <- levels(as.factor(phen))\nphen.ini <- phen\nif(any(!levs %in% c(0,1))){\n  phen <- as.character(phen)\n  phen <- replace(phen, which(phen == levs[1]), 0)\n  phen <- replace(phen, which(phen == levs[2]), 1)\n  phen <- as.numeric(phen)\n  names(phen) <- names(phen.ini)\n} # end make phen binary..\n\n\n## Get pop factor (same as in PCA/DAPC):\n\n## Identify main pop clusters:\nn.PCs <- 5\ngrp <- find.clusters(snps, n.pca=n.PCs, choose.n.clust=FALSE, max.n.clust=(n.PCs + 1)) # pca.select=\"percVar\", perc.pca=60,\npop <- grp$grp # gives same result as cutree(clust, k=6)\nn.grp <- length(levels(pop))\n\n##############################################\n\nsnps.12 <- snps+1\nphen.34 <- phen+3\nmat <- t(matrix(as.numeric(paste(snps.12, \".\", phen.34, sep=\"\")), nrow=ncol(snps), byrow=T))\n\n## get only unique columns of pasted mat:\nmat.u <- get.unique.matrix(mat)\nmat.unique <- mat.u$unique.data\nindex <- mat.u$index\n\n## get all 2x2 combos of snps.12 and phen.34:\nnoms <- c(\"1.3\", \"1.4\", \"2.3\", \"2.4\")\n\n## get array from table, by pop:\narr.l <- list()\nfor(i in 1:ncol(mat.unique)){\n  tab <- list()\n  for(e in 1:length(levels(pop))){\n    temp <- ftable(mat.unique[pop==e, i])\n    tab[[e]] <- replace(rep(0, 4), which(noms %in% attr(temp, \"col.vars\")[[1]]), temp)\n  } # end (e) loop\n  arr.l[[i]] <- do.call(cbind, tab)\n} # end for (i) loop\narr <- do.call(rbind, arr.l)\n\n\narr.complete <- arr\n##############\n## FOR LOOP ##\n##############\n## TO GET P-VALUES FROM CMH TEST for EACH SNPs COLUMN:\np.vals <- list()\nfor(i in 1:ncol(mat.unique)){\n  ## get indices for this snp for all pops and all 4 2x2 combos:\n  from <- seq(1, nrow(arr.complete), 4)[i]\n  to <- from+3\n  arr <- arr.complete[from:to,]\n  dat <- array(arr,\n               dim = c(2,2,ncol(arr)),\n               dimnames = list(\n                 phen = c(\"0\", \"1\"),\n                 SNP = c(\"0\", \"1\"),\n                 pop = levels(pop)\n               ))\n  ## Run CMH test on this unique snps column:\n  CMH <- mantelhaen.test(dat)\n  p.vals[[i]] <- CMH$p.value\n} # end for loop\np.vals <- as.vector(unlist(p.vals))\n\n## get full set of p-vals for non-unique columns:\np.vals.ori <- p.vals\np.vals <- p.vals[index]\n\n## get Bonferroni threshold:\nthresh <- 0.01/ncol(snps)\n## identify sig snps:\nsig.snps <- snps.names[which(p.vals < thresh)]\n\n## STORE AND SAVE p.vals & sig.snps...\n\n\n\n#\n\n\n\n\n#\n",
    "created" : 1476363145110.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1468525457",
    "id" : "6A2BACD1",
    "lastKnownWriteTime" : 1476368749,
    "last_content_update" : 1476368749497,
    "path" : "~/treeWAS/misc/CMH_2x2xk_test.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}