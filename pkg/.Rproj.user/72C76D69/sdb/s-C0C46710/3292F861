{
    "collab_server" : "",
    "contents" : "\n####################################################\n## subsequent.test ## ORIGINAL (w integral score) ##\n####################################################\n\n## SEE BELOW FOR NEW/CURRENT VERSION(s) !!!!!!!!!!!!!!\n#####################\n#\n# subsequent.test <- function(snps.reconstruction,\n#                             phen.reconstruction,\n#                             tree){\n#\n#   snps.rec <- snps.reconstruction\n#   phen.rec <- phen.reconstruction\n#\n#   ## get tree edges:\n#   edges <- tree$edge\n#\n#   #########################\n#   ## Get UNIQUE snps.rec ##\n#   #########################\n#   temp <- get.unique.matrix(snps.rec, MARGIN=2)\n#   snps.rec.unique <- temp$unique.data\n#   index <- temp$index\n#\n#   if(ncol(snps.rec.unique) == ncol(snps.rec)){\n#     all.unique <- TRUE\n#   }else{\n#     all.unique <- FALSE\n#   }\n#\n#   ## work w only unique snps:\n#   snps.rec.ori <- snps.rec\n#   snps.rec <- snps.rec.unique\n#\n#   ###############################\n#   ## GET SCORE ACROSS BRANCHES ##\n#   ###############################\n#\n#   score <- list()\n#   score.p <- list()\n#\n#   ##############\n#   ## FOR LOOP ##\n#   ##############\n#   for(i in 1:ncol(snps.rec)){\n#\n#     score3 <- list()\n#\n#     # ## TEMP -- try w new score3 for all nodes (ie no edges/lengths):\n#     # for(e in 1:length(phen.rec)){\n#     #\n#     #   pi <- phen.rec[e]\n#     #   si <- snps.rec[e, i]\n#     #\n#     #   score3[[e]] <- get.score3.1(Pi=pi, Si=si)\n#     # }\n#\n#     ##############\n#     ## FOR LOOP ##\n#     ##############\n#     for(e in 1:nrow(edges)){\n#\n#       pa <- phen.rec[edges[e,1]]\n#       pd <- phen.rec[edges[e,2]]\n#       sa <- snps.rec[edges[e,1], i]\n#       sd <- snps.rec[edges[e,2], i]\n#       bl <- tree$edge.length[e]\n#\n#       score3[[e]] <- get.score3(Pa = pa, Pd = pd, Sa = sa, Sd = sd, l = bl)\n#\n#     } # end (e) for loop\n#\n#     score3 <- as.vector(unlist(score3))\n#\n#     score[[i]] <- abs(sum(score3))\n#\n#     ## TEMP -- get positive-/negative-only scores?\n#     score.p[[i]] <- max(abs(sum(score3[score3 > 0])), abs(sum(score3[score3 < 0])))\n#\n#\n#   } # end (i) for loop\n#\n#   score <- as.vector(unlist(score))\n#   names(score) <- colnames(snps.rec)\n#\n#   ## TEMP -- positive/neg scores:\n#   score.p <- as.vector(unlist(score.p))\n#   names(score.p) <- colnames(snps.rec)\n#\n#   # ## check out snps.assoc vs snps:\n#   # snps.assoc.ori.ori <- snps.assoc\n#   #\n#   # snps.ass <- snps.index[snps.assoc]\n#   # print(\"SCORE\"); print(score[snps.ass])\n#   # print(\"SCORE P\"); print(score.p[snps.ass])\n#\n#   ################################################\n#   ## get values for duplicate snps.rec columns: ##\n#   ################################################\n#\n#   ## get reconstruction for all original sites\n#   if(all.unique == TRUE){\n#     score.complete <- score\n#   }else{\n#     score.complete <- score[index]\n#     names(score.complete) <- colnames(snps.rec.ori)\n#   }\n#\n#   score <- score.complete\n#\n#   return(score)\n#\n# } # end subsequent.test\n\n\n\n\n\n\n\n#'\n#' ################\n#' ## get.score3 ##\n#' ################\n#'\n#' ########################################################################\n#'\n#' ###################\n#' ## DOCUMENTATION ##\n#' ###################\n#'\n#' #' Short one-phrase description.\n#' #'\n#' #' Longer proper discription of function...\n#' #'\n#' #' @param Pa A numeric value containing either the state,\n#' #' or the probability of the state, of the phenotype at a given \\emph{ancestral} node.\n#' #' @param Pd A numeric value containing either the state,\n#' #' or the probability of the state, of the phenotype at a given \\emph{descendant} node.\n#' #' @param Sa A numeric value containing either the state,\n#' #' or the probability of the state, of SNPi at a given \\emph{ancestral} node.\n#' #' @param Sd A numeric value containing either the state,\n#' #' or the probability of the state, of SNPi at a given \\emph{descendant} node.\n#' #' @param l A numeric value specifying the length of the branch in the phylogenetic tree\n#' #' that joins the ancestral and descendant node.\n#' #'\n#' #' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' #' @export\n#' #' @examples\n#' #'\n#' #' ## basic use of fn\n#' #' tree <- coalescent.tree.sim(n.ind = 100, seed = 1)\n#' #'\n#'\n#' ########################################################################\n#'\n# get.score3 <- function(Pa, Pd, Sa, Sd, l){\n#\n#   score3 <- NULL\n#\n#   ## CHECKS:\n#   if(length(Pa) > 1) stop(\"Pa must be of length one\n#                                     (i.e., (the probability of)\n#                           the phenotypic state of ONE ancestral node.\")\n#   if(length(Pd) > 1) stop(\"Pd must be of length one\n#                                     (i.e., (the probability of)\n#                           the phenotypic state of ONE descendant node.\")\n#   if(length(Sa) > 1) stop(\"Sa must be of length one\n#                                     (i.e., (the probability of)\n#                           the SNPi state of ONE ancestral node.\")\n#   if(length(Sd) > 1) stop(\"Sd must be of length one\n#                                     (i.e., (the probability of)\n#                           the SNPi state of ONE descendant node.\")\n#\n#   ## Original integral-based score:\n#   score3 <- l*(((4/3)*Pa*Sa) +\n#                  ((2/3)*Pa*Sd) +\n#                  ((2/3)*Pd*Sa) +\n#                  ((4/3)*Pd*Sd) -\n#                  Pa -\n#                  Pd -\n#                  Sa -\n#                  Sd +\n#                  1)\n#\n#\n#   ## Simple score1-like score (across edges):\n# #   score3 <- (l/2)*(\n# #     Pa*Sa + (1 - Pa)*(1 - Sa) -\n# #       Pa*(1 - Sa) - (1 - Pa)*Sa +\n# #       Pd*Sd + (1 - Pd)*(1 - Sd) -\n# #       Pd*(1 - Sd) - (1 - Pd)*Sd)\n#\n#\n#   return(score3)\n#\n# } # end get.score3\n\n\n\n##################\n## get.score3.1 ##\n##################\n## TEMPORARY FN-- TESTING SCORE3 = SCORE1 FOR ALL NODES:\n# get.score3.1 <- function(Pi, Si){\n#\n#   score3 <- NULL\n#\n#   ## CHECKS:\n#   if(length(Pi) > 1) stop(\"Pi must be of length one\n#                                     (i.e., (the probability of)\n#                           the phenotypic state of ONE ancestral node.\")\n#\n#   if(length(Si) > 1) stop(\"Si must be of length one\n#                                     (i.e., (the probability of)\n#                           the SNPi state of ONE ancestral node.\")\n#\n#\n#   ## Simple score1-like score (for all/individual nodes):\n#   score3 <- Pi*Si + (1 - Pi)*(1 - Si) -\n#       Pi*(1 - Si) - (1 - Pi)*Si\n#\n#\n#   return(score3)\n#\n# } # end get.score3.1\n\n\n\n####################################################################################################################################\n\n#############################\n## NEW Pagel-like SCORE3 ? ##\n#############################\n\n## INCLUDE:\n\n## Pr(state11 | state11) # maintained\n## Pr(state01 | state01) # simultaneous\n## Pr(state01 | state11) # subsequent\n\n## And the REVERSE x2:\n## ie.\n## 01 & 10\n## AND SNP|Phen & Phen|SNP\n\n# snps <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_snps.Rdata\"))\n# snps.rec <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_res.Rdata\"))$dat$snps.rec\n# snps.assoc <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_performance.Rdata\"))$snps.assoc\n# phen <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_phen.Rdata\"))\n# phen.rec <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_res.Rdata\"))$dat$phen.rec\n# tree <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_29_tree.Rdata\"))\n\n# snps <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_snps.Rdata\"))\n# snps.rec <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_res.Rdata\"))$dat$snps.rec\n# snps.assoc <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_performance.Rdata\"))$snps.assoc\n# phen <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_phen.Rdata\"))\n# phen.rec <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_res.Rdata\"))$dat$phen.rec\n# tree <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_30_tree.Rdata\"))\n\n\n###################################################################################\n## NEW (temporary/replacement) FUNCTION for subsequent test more like PAGEL test ##\n###################################################################################\n\n#####################\n## subsequent.test ##\n#####################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param snps.reconstruction A matrix containing the terminal and reconstructed\n#' ancestral states of SNPs for all nodes in the tree.\n#' @param phen.reconstruction A vector containing the terminal and reconstructed\n#' ancestral states of the phenotype for all nodes in the tree.\n#' @param tree A phylo object containing the tree representing the ancestral relationships\n#' between the individuals for which snps and phen are known.\n#'\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n\n########################################################################\n\nsubsequent.test <- function(snps.reconstruction,\n                            phen.reconstruction,\n                            tree){\n\n  snps.rec <- snps.reconstruction\n  phen.rec <- phen.reconstruction\n\n  ## get tree edges:\n  edges <- tree$edge\n\n  #########################\n  ## Get UNIQUE snps.rec ##\n  #########################\n  temp <- get.unique.matrix(snps.rec, MARGIN=2)\n  snps.rec.unique <- temp$unique.data\n  index <- temp$index\n\n  if(ncol(snps.rec.unique) == ncol(snps.rec)){\n    all.unique <- TRUE\n  }else{\n    all.unique <- FALSE\n  }\n\n  ## work w only unique snps:\n  snps.rec.ori <- snps.rec\n  snps.rec <- snps.rec.unique\n\n###############################\n## GET SCORE ACROSS BRANCHES ##\n###############################\n\nscore <- SCORE3.1 <- SCORE3.2 <- SCORE3.3 <- SCORE3.4 <- SCORE3.5 <- SCORE3.raw <- SCORE3.p <- SCORE3.n <- SCORE3.RAW <- list()\nSCORE3.integral.sum <- SCORE3.integral.max <- SCORE3.1.edges.sum <- SCORE3.1.edges.max <- list()\nQ.ew <- Q.uw <- list()\n\n## HANDLE PHEN.REC:\n## get rid of any 0.5 values (make NA):\nphen.rec.ori <- phen.rec\nphen.rec <- replace(phen.rec, which(! phen.rec %in% c(\"A\", \"B\", 0, 1)), NA)\n## make numeric 0/1:\nphen.rec <- as.numeric(as.factor(phen.rec)) - 1\n\n##############\n## FOR LOOP ##\n##############\nfor(i in 1:ncol(snps.rec)){\n\n  score3 <- list()\n  score3.integral <- score3.1.edges <- list()\n\n  #####################\n  ## get ~ Q matrix: ##\n  #####################\n  ## HANDLE SNPS.REC:\n  snp.rec <- snps.rec[,i]\n  snp.rec <- replace(snp.rec, which(! snp.rec %in% c(0, 1)), NA)\n\n  ## For each EDGE in EDGES, PASTE ANC SNP.PHEN w DEC SNP.PHEN as SaSd|PaPd:\n  ##############\n  ## FOR LOOP ##\n  ##############\n  edges <- tree$edge\n  for(e in 1:nrow(edges)){\n\n    Pa <- phen.rec[edges[e,1]]\n    Pd <- phen.rec[edges[e,2]]\n    Sa <- snp.rec[edges[e,1]]\n    Sd <- snp.rec[edges[e,2]]\n    l <- tree$edge.length[e]\n\n    if(!any(is.na(Sa), is.na(Sd), is.na(Pa), is.na(Pd))){\n      score3[[e]] <- paste(Sa, Pa, \"|\", Sd, Pd, sep=\"\")\n    }else{\n      score3[[e]] <- NA\n    }\n\n    # score3[[e]] <- get.score3(Pa = pa, Pd = pd, Sa = sa, Sd = sd, l = bl)\n\n    ## Original integral-based score:\n    score3.integral[[e]] <- l*(((4/3)*Pa*Sa) +\n                              ((2/3)*Pa*Sd) +\n                              ((2/3)*Pd*Sa) +\n                              ((4/3)*Pd*Sd) -\n                              Pa -\n                              Pd -\n                              Sa -\n                              Sd +\n                              1)\n\n\n    ## Simple score1-like score (across edges):\n    score3.1.edges[[e]] <- (l/2)*(\n                            Pa*Sa + (1 - Pa)*(1 - Sa) -\n                              Pa*(1 - Sa) - (1 - Pa)*Sa +\n                              Pd*Sd + (1 - Pd)*(1 - Sd) -\n                              Pd*(1 - Sd) - (1 - Pd)*Sd)\n\n  } # end (e) for loop\n\n  ## Combine all edges into one FACTOR for this snps.rec column:\n  score3 <- as.vector(unlist(score3))\n  names(score3) <- c(1:length(score3))\n\n  ## Combine alternative scores into one per snp: #############################\n\n  ## integral-based score\n  score3.integral <- as.vector(unlist(score3.integral))\n  ## save BOTH the sum and the max-only score:\n  ## sum:\n  SCORE3.integral.sum[[i]] <- abs(sum(score3.integral))\n  ## max -- positive-/negative-only scores?\n  SCORE3.integral.max[[i]] <- max(abs(sum(score3.integral[score3.integral > 0])), abs(sum(score3.integral[score3.integral < 0])))\n\n  ## score1-like cross-edges score:\n  score3.1.edges <- as.vector(unlist(score3.1.edges))\n  ## save BOTH the sum and the max-only score:\n  ## sum:\n  SCORE3.1.edges.sum[[i]] <- abs(sum(score3.1.edges))\n  ## max -- positive-/negative-only scores?\n  SCORE3.1.edges.max[[i]] <- max(abs(sum(score3.1.edges[score3.1.edges > 0])), abs(sum(score3.1.edges[score3.1.edges < 0])))\n\n  ###########################################################################\n\n  ## Use relative freq of each factor level as prob (or incorporate edge length to get ~ rate)...\n  # table(score3)\n\n  ## get separate positive and negative scores for concordant (00,11) and discordant (01,10) associations:\n  score3.p.noms <- c(\"00|00\", \"11|11\", \"00|11\", \"11|00\", \"01|00\", \"10|00\", \"01|11\", \"10|11\")\n  score3.n.noms <- c(\"00|01\", \"00|10\", \"11|01\", \"11|10\", \"01|01\", \"10|10\", \"01|10\", \"10|01\")\n  score3.p <- replace(score3, which(!score3 %in% score3.p.noms), NA)\n  score3.n <- replace(score3, which(!score3 %in% score3.n.noms), NA)\n\n  tab.p <- table(score3.p)\n  tab.n <- table(score3.n)\n\n  SCORE3.raw[[i]] <- score3\n  SCORE3.p[[i]] <- score3.p\n  SCORE3.n[[i]] <- score3.n\n\n  ################################################################################################\n\n  ##################################\n  ## Get UN-edge-weighted SCORES: ##\n  ##################################\n\n  # i <- 1369\n\n  ##################\n  ## SIMPLE score ## (all equal +/- 1): # p = 1.76x n\n  ##################\n  score3.p.u <- sum(tab.p) # 125\n  score3.n.u <- sum(tab.n) # 71\n\n  ## get unewighted simple score as max of pos and neg scores:\n  SCORE3.1[[i]] <- score3.u <- max(score3.p.u, score3.n.u) # 125\n\n  ############################\n  ## COMPLEX weighted score ## (simultaneous > maintained > subsequent (?)): # p = 2.1x n\n  ############################\n  sim.p <- tab.p[which(names(tab.p) %in% c(\"00|11\", \"11|00\"))]\n  maint.p <- tab.p[which(names(tab.p) %in% c(\"00|00\", \"11|11\"))]\n  subsq.p <- tab.p[which(names(tab.p) %in% c(\"01|00\", \"01|11\", \"10|00\", \"10|11\"))]\n  ## positive complex score:\n  score3.p.w.u <- sum(sim.p*3, maint.p*2, subsq.p*1) # 202\n\n  sim.n <- tab.n[which(names(tab.n) %in% c(\"01|10\", \"10|01\"))]\n  maint.n <- tab.n[which(names(tab.n) %in% c(\"01|01\", \"10|10\"))]\n  subsq.n <- tab.n[which(names(tab.n) %in% c(\"00|01\", \"00|10\", \"11|01\", \"11|10\"))]\n  ## negative complex score:\n  score3.n.w.u <- sum(sim.n*3, maint.n*2, subsq.n*1) # 96\n\n  ## get weighted (un-edge-weighted) score as mx of pos and neg scores:\n  SCORE3.2[[i]] <- score3.w.u <- max(score3.p.w.u, score3.n.w.u) # 202\n\n\n  ###########################################\n  ## Get SCORES weighted by EDGE LENGTH??: ##   ###   ###   ###   ###   ###   ###   ###   ###\n  ###########################################\n\n  ##################\n  ## SIMPLE score ## (all equal +/- 1): # p = 2.06x n\n  ##################\n  score3.p.ew <- sum(tree$edge.length[which(score3 %in% score3.p.noms)]) # 6.7\n  score3.n.ew <- sum(tree$edge.length[which(score3 %in% score3.n.noms)]) # 3.25\n\n  ## Keep only higher of the two scores:\n  SCORE3.3[[i]] <- score3.ew <- max(score3.p.ew, score3.n.ew) # 6.7\n\n  ############################\n  ## COMPLEX weighted score ## (simultaneous > maintained > subsequent (?)): # p = 2.5x n\n  ############################\n  sim.p.ew <- tree$edge.length[which(score3 %in% c(\"00|11\", \"11|00\"))]\n  maint.p.ew <- tree$edge.length[which(score3 %in% c(\"00|00\", \"11|11\"))]\n  subsq.p.ew <- tree$edge.length[which(score3 %in% c(\"01|00\", \"01|11\", \"10|00\", \"10|11\"))]\n  ## positive complex score:\n  score3.p.w.ew <- sum(sim.p.ew*3, maint.p.ew*2, subsq.p.ew*1) # 11.03\n\n  sim.n.ew <- tree$edge.length[which(score3 %in% c(\"01|10\", \"10|01\"))]\n  maint.n.ew <- tree$edge.length[which(score3 %in% c(\"01|01\", \"10|10\"))]\n  subsq.n.ew <- tree$edge.length[which(score3 %in% c(\"00|01\", \"00|10\", \"11|01\", \"11|10\"))]\n  ## negative complex score:\n  score3.n.w.ew <- sum(sim.n.ew*3, maint.n.ew*2, subsq.n.ew*1) # 4.37\n\n  ##############\n\n  # Q.noms <- paste(c(0,0,1,1), c(0,1,0,1), sep=\"|\")\n  # ## (SNPphen.anc|SNPphen.dec)\n  # m <- c(\"00|00\", \"00|01\", \"00|10\", \"00|11\",\n  #        \"01|00\", \"01|01\", \"01|10\", \"01|11\",\n  #        \"10|00\", \"10|01\", \"10|10\", \"10|11\",\n  #        \"11|00\", \"11|01\", \"11|10\", \"11|11\")\n  # ## Get the sum of the edge lengths over which that type of association happens,\n  # ## divided by the sum of edge lengths for which we have a score at this SNP\n  # ## (ie. the edges for which neither the ancestor nor the descendant has\n  # ## an unknown reconstructed SNP/phen (ie. value of 0.5))\n  # m.corr <- c(2, 0.75, 0.75, 1, 3, 0.5, 0.25,  3, 3, 0.25, 0.5, 3, 1, 0.75, 0.75, 2)\n  # mat.corr <- matrix(m.corr, ncol=4, nrow=4, byrow=TRUE)\n  # ## sum to 1:\n  # mat.corr <- mat.corr/sum(mat.corr)\n  # ## (SNP|phen) -- anc in rows, dec in cols:\n  # rownames(mat.corr) <- colnames(mat.corr) <- c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")\n  # Q <- mat.corr\n\n  ##############\n  ## get rate matrix:\n  # s3 <- SCORE3$corr.dat[[6]]\n  #\n  # for(s in 1:length(snps.assoc)){\n  # score3 <- s3[[snps.assoc[s]]]\n\n  Q.noms <- paste(c(0,0,1,1), c(0,1,0,1), sep=\"|\")\n  ## (SNPphen.anc|SNPphen.dec)\n  m <- c(\"00|00\", \"00|01\", \"00|10\", \"00|11\",\n         \"01|00\", \"01|01\", \"01|10\", \"01|11\",\n         \"10|00\", \"10|01\", \"10|10\", \"10|11\",\n         \"11|00\", \"11|01\", \"11|10\", \"11|11\")\n  ## Get the sum of the edge lengths over which that type of association happens,\n  ## divided by the sum of edge lengths for which we have a score at this SNP\n  ## (ie. the edges for which neither the ancestor nor the descendant has\n  ## an unknown reconstructed SNP/phen (ie. value of 0.5))\n  m.ew <- sapply(c(1:length(m)),\n                 function(e)\n                   sum(tree$edge.length[which(score3 == m[e])])) / sum(tree$edge.length[!is.na(score3)])\n  mat.ew <- matrix(m.ew, ncol=4, nrow=4, byrow=TRUE)\n  ## (SNP|phen) -- anc in rows, dec in cols:\n  rownames(mat.ew) <- colnames(mat.ew) <- c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")\n  # print(mat.ew)\n\n  ## OR ##\n  ## Get unweighed \"probs\"??\n  m.uw <- sapply(c(1:length(m)),\n                 function(e)\n                   length(which(score3 == m[e]))) / length(score3[!is.na(score3)])\n  mat.uw <- matrix(m.uw, ncol=4, nrow=4, byrow=TRUE)\n\n  ## (SNP|phen) -- anc in rows, dec in cols:\n  rownames(mat.uw) <- colnames(mat.uw) <- c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")\n  # print(mat.uw)\n\n  # sum(mat[,c(1,4)])\n  # sum(mat[,c(2,3)])\n\n  # print(sum(mat.ew[,c(1,4)]))\n  # print(sum(mat.ew[,c(2,3)]))\n  #\n  # print(sum(mat.uw[,c(1,4)]))\n  # print(sum(mat.uw[,c(2,3)]))\n  # }\n\n  Q.ew[[i]] <- mat.ew\n  Q.uw[[i]] <- mat.uw\n\n  # load(\"/home/caitiecollins/treeWAS/misc/SCORE3.set1_31.Rdata\")\n  # snps.assoc <- out$performance[[1]]$snps.assoc\n  # tree <- out$tree[[1]]\n  # snps.rec <- out$res$set1_31$dat$snps.rec\n  # phen.rec <- out$res$set1_31$dat$phen.rec\n\n  ##\n  # var.rec <- snps.rec[,snps.assoc[1]]\n  # var.rec <- round(var.rec)\n  # var.rec <- replace(var.rec, which(var.rec == 0), \"A\")\n  # var.rec <- replace(var.rec, which(var.rec == 1), \"B\")\n  # if(any(!var.rec %in% c(\"A\", \"B\"))) var.rec <- replace(var.rec, which(!var.rec %in% c(\"A\", \"B\")), NA)\n  # plot.phen(tree, phen.nodes=var.rec)\n  # title(\"SNP 304\", line=-1)\n\n\n  # Q.ew <- SCORE3$corr.dat[[9]]\n  # Q.uw <- SCORE3$corr.dat[[10]]\n  #\n  # Q.ew[[snps.assoc[1]]]\n  # Q.uw[[snps.assoc[1]]]\n  #\n  # var <- snps.rec[,snps.assoc[1]][-which(!snps.rec[,snps.assoc[1]] %in% c(0,1))]\n  # table(var)/length(var)\n  # sum(Q.uw[[snps.assoc[1]]][, c(1,2)])\n  # sum(Q.uw[[snps.assoc[1]]][, c(3,4)])\n\n  ## sum.mat <- Reduce(\"+\", list(mat, mat, mat)) # add matrices togeter by cell.\n  ############\n\n  ## KEEP ONLY THE HIGHER OF THE TWO SCORES!  ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n  ## NOTE -- ORRRRRRRRRRRRRRR SHOULD WE KEEP THE ABS VAL OF THE DIFFERENCE BETWEEN THE TWO SCORES??????????????????????????    <----- (??)\n  SCORE3.4[[i]] <- score3.w.ew <- max(score3.p.w.ew, score3.n.w.ew) # 11.03\n\n  SCORE3.5[[i]] <- abs(score3.p.w.ew - score3.n.w.ew)\n\n  ## for now, using weighted complex as subsequent score:\n  ## trying w unweighted simple score (makes more sense, given sim is using probs without factoring in branch lengths..)\n  score[[i]] <- SCORE3.1[[i]]\n  } # end (i) for loop\n  ################################################################################################\n\n  score <- as.vector(unlist(score))\n  names(score) <- colnames(snps.rec)\n\n  ## TEMP!: ##\n  ############\n  ## name SCORE3 AND re-duplicate all elements AND save it to compare to new score....\n  SCORE3.1 <- as.vector(unlist(SCORE3.1))\n  names(SCORE3.1) <- colnames(snps.rec)\n\n  SCORE3.2 <- as.vector(unlist(SCORE3.2))\n  names(SCORE3.2) <- colnames(snps.rec)\n\n  SCORE3.3 <- as.vector(unlist(SCORE3.3))\n  names(SCORE3.3) <- colnames(snps.rec)\n\n  SCORE3.4 <- as.vector(unlist(SCORE3.4))\n  names(SCORE3.4) <- colnames(snps.rec)\n\n  SCORE3.5 <- as.vector(unlist(SCORE3.5))\n  names(SCORE3.5) <- colnames(snps.rec)\n\n  ################################################\n  ## get values for duplicate snps.rec columns: ##\n  ################################################\n\n  ## get reconstruction for all original sites\n  if(all.unique == TRUE){\n    score.complete <- score\n  }else{\n    score.complete <- score[index]\n    names(score.complete) <- colnames(snps.rec.ori)\n\n    SCORE3.1 <- SCORE3.1[index]\n    names(SCORE3.1) <- colnames(snps.rec.ori)\n\n    SCORE3.2 <- SCORE3.2[index]\n    names(SCORE3.2) <- colnames(snps.rec.ori)\n\n    SCORE3.3 <- SCORE3.3[index]\n    names(SCORE3.3) <- colnames(snps.rec.ori)\n\n    SCORE3.4 <- SCORE3.4[index]\n    names(SCORE3.4) <- colnames(snps.rec.ori)\n\n    SCORE3.5 <- SCORE3.5[index]\n    names(SCORE3.5) <- colnames(snps.rec.ori)\n\n    ## alternative scores:\n    ## score 1-like cross-edges\n    SCORE3.1.edges.sum <- SCORE3.1.edges.sum[index]\n    names(SCORE3.1.edges.sum) <- colnames(snps.rec.ori)\n\n    SCORE3.1.edges.max <- SCORE3.1.edges.max[index]\n    names(SCORE3.1.edges.max) <- colnames(snps.rec.ori)\n\n    ## integral-based score:\n    SCORE3.integral.sum <- SCORE3.integral.sum[index]\n    names(SCORE3.integral.sum) <- colnames(snps.rec.ori)\n\n    SCORE3.integral.max <- SCORE3.integral.max[index]\n    names(SCORE3.integral.max) <- colnames(snps.rec.ori)\n  }\n\n\n  SCORE3 <- list(\"SCORE3.1\"=SCORE3.1, \"SCORE3.2\"=SCORE3.2, \"SCORE3.3\"=SCORE3.3, \"SCORE3.4\"=SCORE3.4, \"SCORE3.5\"=SCORE3.5,\n                 \"SCORE3.raw\"=SCORE3.raw, \"SCORE3.p\"=SCORE3.p, \"SCORE3.n\"=SCORE3.n,\n                 \"SCORE3.integral.sum\"=SCORE3.integral.sum, \"SCORE3.integral.max\"=SCORE3.integral.max,\n                 \"SCORE3.1.edges.sum\"=SCORE3.1.edges.sum, \"SCORE3.1.edges.max\"=SCORE3.1.edges.max,\n                 \"Q.ew\"=Q.ew, \"Q.uw\"=Q.uw)\n\n  score <- score.complete\n\n  SCORE <- list(\"score\" = score,\n                \"SCORE3\" = SCORE3)\n\n  # return(score)\n  return(SCORE)\n\n} # end subsequent.test\n##\n\n\n\n# ## load saved SCORE3 list\n# corr.dat <- SCORE3$corr.dat\n# corr.sim <- SCORE3$corr.sim\n#\n# snps.assoc <- out$performance[[1]]$snps.assoc\n#\n# hist(corr.sim[[1]])\n# cd <- corr.dat[[1]][snps.assoc]\n# cd\n# sapply(c(1:length(cd)), function(e) length(which(corr.sim[[1]] > cd[e])))\n#\n# hist(corr.sim[[2]])\n# cd <- corr.dat[[2]][snps.assoc]\n# cd\n# sapply(c(1:length(cd)), function(e) length(which(corr.sim[[2]] > cd[e])))\n#\n# hist(corr.sim[[3]])\n# cd <- corr.dat[[3]][snps.assoc]\n# cd\n# sapply(c(1:length(cd)), function(e) length(which(corr.sim[[3]] > cd[e])))\n#\n# hist(corr.sim[[4]])\n# cd <- corr.dat[[4]][snps.assoc]\n# cd\n# sapply(c(1:length(cd)), function(e) length(which(corr.sim[[4]] > cd[e])))\n#\n# hist(corr.sim[[5]])\n# cd <- corr.dat[[5]][snps.assoc]\n# cd\n# sapply(c(1:length(cd)), function(e) length(which(corr.sim[[5]] > cd[e])))\n\n\n\n\n\n#\n#\n\n\n\n\n\n\n\n\n\n#\n\n\n\n\n\n#\n",
    "created" : 1471872537234.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1127433113",
    "id" : "3292F861",
    "lastKnownWriteTime" : 1473025452,
    "last_content_update" : 1473025452612,
    "path" : "~/treeWAS/pkg/R/subsequent.test.R",
    "project_path" : "R/subsequent.test.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}