{
    "contents" : "\n#############\n## utils.R ##\n#############\n\n## useful little functions that get used within other functions\n\n## NOTE: for package release should change all fns to .fns\n## here and within all other fns s.t. no documentation required\n## (unless we want to release these for public use?)\n\n#######################\n## get.unique.matrix ##\n#######################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Get unique rows/columns of a matrix with an index vector.\n#'\n#' A wrapper for the \\code{table.matrix} function that assigns consecutive\n#' row or column names to the output matrix's unique rows or columns.\n#'\n#' @param data A matrix or data.frame, potentially containing\n#' non-unique patterns in its rows or columns.\n#' @param MARGIN A single integer specifying the array margin to be held fixed.\n#' (To get unique \\emph{rows}, select \\code{MARGIN} = 1;\n#' for unique \\emph{columns}, select \\code{MARGIN} = 2.)\n#'\n#' @details An extension of the base \\code{unique.matrix} function that returns\n#' a unique matrix (by removing duplicate rows or columns) and also\n#' an index vector containing the indices (row or column numbers),\n#' in the matrix composed only of unique rows or columns,\n#' to which each row or column in the original matrix corresponds.\n#'\n#' @return A list with the following elements:\n#' \\itemize{\n#'    \\item{\\code{index} \\item{An index vector containing the indices (row numbers),\n#'          in a matrix composed only of unique rows,\n#'          to which each row in the original matrix maps.}}\n#'    \\item{\\code{unique.data} \\item{A new matrix\n#'          containing only the unique rows of the input matrix.}}\n#' }\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#'\n#' @export\n\n\n########################################################################\n## get unique SNPs column patterns: ##\nget.unique.matrix <- function(data, MARGIN=2){\n\n  ## Identify unique SNP row/column patterns:\n  tab.out <- table.matrix(data, MARGIN=MARGIN)\n  unique.data <- as.matrix(tab.out$unique.data)\n  index <- tab.out$index\n\n  if(MARGIN == 1){\n    row.names(unique.data) <- c(1:nrow(unique.data))\n    if(length(unique(index)) == nrow(data)){\n      index <- NULL\n      warning(\"Data inputted was already unique along the selected MARGIN.\n              No index will be returned, and unique.data will be identical to data.\")\n    }\n  }\n  if(MARGIN == 2){\n    colnames(unique.data) <- c(1:ncol(unique.data))\n    if(length(unique(index)) == ncol(data)){\n      index <- NULL\n      warning(\"Data inputted was already unique along the selected MARGIN.\n              No index will be returned, and unique.data will be identical to data.\")\n    }\n  }\n\n  ## Get output:\n  out <- list(unique.data=unique.data,\n              index=index)\n  return(out)\n} # end get.unique.matrix\n\n\n## assign new name to old name (NOT SURE THIS WORKS... CHECK!)\nget.unique.snps <- get.unique.matrix\n\n\n###################\n## get.tip.order ##\n###################\n## fn getting order of tips as plotted\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Get the order of the tip labels of a phylogenetic tree as plotted.\n#'\n#' Longer proper discription of function...\n#'\n#' @param tree An object of class phylo containing a tree\n#' whose tip order is desired to be known.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## load data\n#' data(dist)\n#' str(dist)\n#'\n#' ## basic use of fn\n#' fn(arg1, arg2)\n#'\n#' #' ## more elaborate use of fn\n#' fn(arg1, arg2)\n#'\n#' @import ape Hmisc\n\n########################################################################\n\nget.tip.order <- function(tree){\n\n  require(ape)\n  require(Hmisc)\n\n  tree2 <- read.tree(text=write.tree(tree))\n  if(all.is.numeric(tree2$tip.label)){\n    out <- as.numeric(tree2$tip.label)\n    out <- rev(out)\n  }else{\n    out <- sort(tree2$tip.label)\n    out <- sapply(c(1:length(tree$tip.label)), function(e)\n      which(out == tree$tip.label[e]))\n  }\n\n  return(out)\n\n} # end get.tip.order\n\n## OLD VERSION (pre-2016) --> NAs if tip labs not numeric!\n# get.tip.order <- function(tree){\n#   require(ape)\n#   tree2 <- read.tree(text=write.tree(tree))\n#   out <- as.numeric(tree2$tip.label)\n#   out <- rev(out)\n#   return(out)\n# } # end get.tip.order\n\n\n\n##################\n## table.matrix ##\n##################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Cross-tabulate the rows or columns of a matrix.\n#'\n#' A version of the base \\code{table} function designed for matrices.\n#' Taking a matrix as input, \\code{table.matrix} returns a contingency table,\n#' index vector, and unique matrix.\n#'\n#' @param data A matrix or data.frame, potentially containing\n#' non-unique patterns in its rows or columns.\n#' @param MARGIN A single integer specifying the array margin to be held fixed.\n#' (To get unique \\emph{rows}, select \\code{MARGIN} = 1;\n#' for unique \\emph{columns}, select \\code{MARGIN} = 2.)\n#'\n#' @details To apply this function to the \\emph{columns} of a matrix, simply\n#' transpose the matrix before executing the command, as in:\n#' \\code{table.matrix(t(data))}.\n#'\n#' @return A list with the following elements:\n#' \\itemize{\n#'    \\item{\\code{table} \\item{A contingency table of the counts of the\n#'          number of occurrences of each unique row in the matrix.}}\n#'    \\item{\\code{index} \\item{An index vector containing the indices (row numbers),\n#'          in a matrix composed only of unique rows,\n#'          to which each row in the original matrix maps.}}\n#'    \\item{\\code{unique.data} \\item{A new matrix\n#'          containing only the unique rows of the input matrix.}}\n#' }\n#'\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#'\n#' @examples\n#'\n#' ## load example data:\n#' data(\"snps.ace\")\n#' x <- snps.ace\n#'\n#' ## basic use of fn on rows of x:\n#' tab.out <- table.matrix(x)\n#'\n#' ## apply fn to columns of x:\n#' tab.out <- table.matrix(t(x))\n#'\n#' @export\n\n########################################################################\n\ntable.matrix <- function(data, MARGIN=1){\n\n  ## handle MARGIN argument:\n  if(is.character(MARGIN)){\n    MARGIN <- tolower(MARGIN)\n    if(MARGIN %in% c(\"row\", \"rows\", \"r\")){\n      MARGIN <- 1\n    }else{\n      if(MARGIN %in%\n         c(\"column\", \"columns\", \"col\", \"cols\", \"c\")){\n        MARGIN <- 2\n      }else{\n        stop(\"MARGIN argument should be either 1 or 2;\n             or, 'rows' or 'columns'.\")\n      }\n    }\n  }\n  ## for columns, transpose matrix at beginning and end:\n  if(MARGIN == 2) data <- t(data)\n\n\n  ## get df\n  if(!is.data.frame(data)){\n    data <- as.data.frame(data, stringsAsFactors = FALSE)\n  }\n  ## concatenate all rows into single elements\n  dat <- do.call(\"paste\", c(data, sep = \"\\r\"))\n  ## get unique rows\n  unique.inds <- !duplicated(dat)\n  ## keep only unique rows\n  levels <- dat[unique.inds]\n  ## make a factor in which each level\n  ## is the smushed single-element vector\n  ## of each unique row\n  cat <- factor(dat, levels = levels)\n  ## get n. unique levels\n  n.levels <- length(levels(cat))\n  ## get the unique index that\n  ## each original ind/row should map to:\n  map.to <- (as.integer(cat) - 1)\n  map.to <- map.to[!is.na(map.to)]\n  if(length(map.to)) map.to <- map.to + 1\n  ## get the number of inds at each unique level:\n  tab <- tabulate(map.to, n.levels)\n\n  ## get output\n  if(MARGIN == 1){\n    out <- list(table = tab,\n                index = map.to,\n                unique.data = data[unique.inds, ])\n  }\n  if(MARGIN == 2){\n    out <- list(table = tab,\n                index = map.to,\n                unique.data = as.data.frame(t(data)[, unique.inds]))\n  }\n\n  return(out)\n\n} # end table.matrix\n\n\n#########   ###   ###   ###   ###   ###   ###   ###   ###   ###   #########\n#########   ###   ###   ###   ###   ###   ###   ###   ###   ###   #########\n\n## NOTE: THESE ARE BEING RENAMED --> SET OF 4 FNS!\n## NEED TO KEEP OLD 2 FOR NOW UNTIL YOU CAN SEARCH THROUGH\n## ALL YOUR OTHER FNS FOR INSTANCES OF THEIR USE\n## AND REPLACE THE OLD FN NAMES W THE NEW!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n##################\n## .substrRight ##\n##################\n## truncate character string from right\n## ie. keep the LAST n characters of\n## (each element of) x\n\n#' @export\n\n.substrRight <- function(x, n){\n  sapply(x, function(e)\n    substr(e, (nchar(e)-n+1), nchar(e))\n  )\n} # end .substrRight\n\n\n#################\n## .substrLeft ##\n#################\n## truncate character string from left\n## ie. keep the FIRST n characters of\n## (each element of) x\n\n#' @export\n\n.substrLeft <- function(x, n){\n  sapply(x, function(e)\n    substr(e, 0, n)\n  )\n} # end .substrLeft\n\n#########   ###   ###   ###   ###   ###   ###   ###   ###   ###   #########\n\n###############\n## keepLastN ##\n###############\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Truncate to keep only the \\emph{last} N characters.\n#'\n#' Truncate an element, or each element of a vector, by\n#' removing all but the last N characters of each element.\n#'\n#' @param x A vector whose element(s) will be truncated.\n#' @param n An integer specifying the number of characters to \\emph{keep}.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n########################################################################\n\nkeepLastN <- function(x, n){\n  sapply(x, function(e)\n    substr(e, (nchar(e)-n+1), nchar(e))\n  )\n} # end keepLastN\n\n################\n## keepFirstN ##\n################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Truncate to keep only the \\emph{first} N characters.\n#'\n#' Truncate an element, or each element of a vector, by\n#' removing all but the first N characters of each element.\n#'\n#' @param x A vector whose element(s) will be truncated.\n#' @param n An integer specifying the number of characters to \\emph{keep}.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n########################################################################\n\nkeepFirstN <- function(x, n){\n  sapply(x, function(e)\n    substr(e, 1, n)\n  )\n} # end keepFirstN\n\n#################\n## removeLastN ##\n#################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Truncate to remove all of the \\emph{last} N characters.\n#'\n#' Truncate an element, or each element of a vector, by\n#' removing the last N characters of each element.\n#'\n#' @param x A vector whose element(s) will be truncated.\n#' @param n An integer specifying the number of characters to \\emph{remove}.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n########################################################################\n\nremoveLastN <- function(x, n){\n  sapply(x, function(e)\n    substr(e, 0, (nchar(e)-n))\n  )\n} # end removeLastN\n\n\n##################\n## removeFirstN ##\n##################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Truncate to remove all of the \\emph{first} N characters.\n#'\n#' Truncate an element, or each element of a vector, by\n#' removing the first N characters of each element.\n#'\n#' @param x A vector whose element(s) will be truncated.\n#' @param n An integer specifying the number of characters to \\emph{remove}.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n########################################################################\n\nremoveFirstN <- function(x, n){\n  sapply(x, function(e)\n    substr(e, n+1, nchar(e))\n  )\n} # end removeFirstN\n\n\n#########   ###   ###   ###   ###   ###   ###   ###   ###   ###   #########\n#########   ###   ###   ###   ###   ###   ###   ###   ###   ###   #########\n\n##################\n## .is.integer0 ##\n##################\n## mini fn testing for output==integer(0)\n\n#' @export\n\n.is.integer0 <- function(x){\n  is.integer(x) && length(x) == 0L\n} # end .is.integer0()\n\n\n########################\n## Parity-testing fns ##\n########################\n\n#' @export\n\n.is.even <- function(x) x %% 2 == 0\n\n#' @export\n\n.is.odd <- function(x) x %% 2 != 0\n\n\n#########################\n## selectBiallelicSNP: ##\n#########################\n## fn that returns the alternative nt| the nt input\n\n## NOTE-- while this is not inherently the\n## definition of a biallelic SNP,\n## it is currently suiting my purposes\n#### by fulfilling the function of\n## ensuring that sites always revert\n## back and forth between one state and ONE other,\n#### hence never creating any\n## triallelic sites or tetralellic sites\n## --> binary encoding guaranteed to work fine.\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param x A character vector of length 1 containing a nucleotide to be converted.\n#' @param DNA logical; if TRUE (default), uses DNA bases (ACGT), if FALSE, uses RNA bases (ACGU).\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n\n########################################################################\n\n\nselectBiallelicSNP <- function(x, DNA=TRUE){\n\n  out <- NULL\n\n  if(!is.null(x)){\n\n    x <- as.character(x)\n\n    ## for DNA encoding:\n    if(DNA==TRUE){\n      if(x==\"a\") out <- \"t\"\n      if(x==\"t\") out <- \"a\"\n      if(x==\"c\") out <- \"g\"\n      if(x==\"g\") out <- \"c\"\n\n      if(x==\"A\") out <- \"T\"\n      if(x==\"T\") out <- \"A\"\n      if(x==\"C\") out <- \"G\"\n      if(x==\"G\") out <- \"C\"\n    } # end DNA\n\n    ## for RNA encoding:\n    if(DNA==FALSE){\n      if(x==\"a\") out <- \"u\"\n      if(x==\"u\") out <- \"a\"\n      if(x==\"c\") out <- \"g\"\n      if(x==\"g\") out <- \"c\"\n\n      if(x==\"A\") out <- \"U\"\n      if(x==\"U\") out <- \"A\"\n      if(x==\"C\") out <- \"G\"\n      if(x==\"G\") out <- \"C\"\n    } # end RNA\n  } # end !is.null(x)\n\n  return(out)\n\n} # end selectBiallelicSNP\n#######################################################\n\n\n#####################\n## .switch.phen fn ##\n#####################\n\n#' @export\n\n.switch.phen <- function(x){\n  out <- NULL\n  ## A/B coding\n  if(x == \"A\") out <- \"B\"\n  if(x == \"B\") out <- \"A\"\n  ## R/S coding\n  if(x == \"R\") out <- \"S\"\n  if(x == \"S\") out <- \"R\"\n  return(out)\n} # end .switch.phen\n\n###############\n## .getFixed ##\n###############\n\n#' @export\n\n.getFixed <- function(locus, posi,\n                     exp.char=c(\"a\",\"t\",\"g\",\"c\"),\n                     polyThres=0.01){\n  vec <- as.character(locus)\n  vec[!vec %in% exp.char] <- NA\n  N <- sum(!is.na(vec)) # N: number of sequences\n  if(N==0 || sum(table(vec)/N >= polyThres )<2){\n    return(TRUE) # escape if untyped locus or no SNPs\n  }else{\n    return(FALSE)\n  }\n} # end getFixed\n",
    "created" : 1468521231693.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2173203950",
    "id" : "5C05F76F",
    "lastKnownWriteTime" : 1468953481,
    "path" : "~/treeWAS/pkg/R/utils.R",
    "project_path" : "R/utils.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}