{
    "contents" : "\n\n##############\n## phen.sim ##\n##############\n\n## TO DO ##\n## CAREFUL--phen.sim seems not to be working with trees other than those\n## produced with your coalescent.tree.sim fn (eg. rtree(100))!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param tree An phylo object.\n#' @param n.subs An integer controlling the phenotypic substition rate (see details).\n#' @param grp.min An optional numeric value < 0.5 specifying the minimum accepted proportion of terminal nodes\n#' to be in the minor phenotypic group. It may be useful to specify a \\code{grp.min} of,\n#' for example, 0.2 (the default) to prevent excessive imbalance in the phenotypic group sizes. However,\n#' it is important to note that (at least for the time being) \\code{grp.min} values closer to\n#' 0.5 are likely to cause the computational time of \\code{phen.sim} to increase substantially,\n#' as the function will run until acceptable group sizes are randomly generated.\n#' @param seed An optional integer used to set the seed and control the pseudo-random process used in\n#' \\code{phen.sim}, enabling the repeatable regeneration of identical output.\n#'\n#' @description The parameter n.subs controls the simulation of the phenotype by specifying\n#' the expected value of the number of phenotypic substitions to occur on the tree provided.\n#' The true number of phenotypic substitions is drawn from a Poisson distribution with parameter n.subs.\n#'\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## basic use of fn\n#' tree <- coalescent.tree.sim(n.ind = 100, seed = 1)\n#'\n#' ## plot output\n#' plot(tree)\n#'\n\n########################################################################\n\n\nphen.sim <- function(tree,\n                     n.subs = 15,\n                     grp.min = 0.2,\n                     seed = NULL){\n\n  if(!is.null(seed)) set.seed(seed)\n\n  ####################################\n  ## PHENOTYPE simulation procedure ## ~ sim.by.locus...\n  ####################################\n\n  ## simulate phenotype for root individual:\n  if(!is.null(n.subs)){\n    phen.root <- \"A\"\n  }else{\n    phen.root <- NULL\n  }\n\n  ## store the inputted desired number of phenotypic substitutions\n  n.phen.subs <- n.subs\n\n  ## make dummy variables in which to store the resulting n.mts variables:\n  lambda_p <- n.subs <- NA\n\n  ## ensure phen variables start as NULL\n  phen.branch <- phen.nodes <- phen.leaves <- NULL\n\n\n\n  #############################################################\n  ## If the user has specified a \"mt\" rate for the phenotype ##\n  #############################################################\n\n  ## (indicating that they want to generate a NEW phenotype for the tree provided)\n  if(!is.null(n.phen.subs)){\n\n    ## START WHILE LOOP HERE ###########\n\n    toRepeat <- TRUE\n\n    while(toRepeat == TRUE){\n\n      ## draw the number of mutations to occur:\n      n.subs <- rpois(n=1, lambda=n.phen.subs)\n      ## if n.subs==0 or ==1, re-sample\n      while(n.subs <= 1){\n        n.subs <- rpois(n=1, lambda=n.phen.subs)\n      }\n\n      ## draw the branches to which you will assign the\n      ## n.subs to occur for the phenotype (~ branch length):\n      phen.loci <- sample(c(1:length(tree$edge.length)),\n                          n.subs, replace=FALSE, prob=tree$edge.length)\n      ## rearrange phen.loci\n      phen.loci <- sort(phen.loci, decreasing=TRUE)\n\n\n      ###############################\n      ## For Loop to get PHENOTYPE ##\n      ###############################\n      ## get phenotype for all branches/ nodes in tree\n      ## (from root node (ie. tree$edge[nrow(tree$edge), 1]) down):\n      phen.nodes <- phen.branch <- list()\n\n      ## set phenotype for all branches and nodes to be phen.root:\n      phen.branch[1:length(tree$edge.length)] <- phen.root\n      names(phen.branch) <- paste(\"e\", c(1:length(phen.branch)), sep=\".\")\n      phen.nodes[1:length(unique(as.vector(unlist(tree$edge))))] <- phen.root\n      names(phen.nodes) <- paste(\"n\", c(1:length(phen.nodes)), sep=\".\")\n\n      #############################################################################\n\n      #############################################################################\n\n      ## get the node names for all individuals (terminal and internal)\n      all.inds <- sort(unique(as.vector(unlist(tree$edge))))\n\n      x <- rev(c(1:nrow(tree$edge)))\n\n      ## get phen of nodes\n      for(i in 1:length(x)){\n        if(x[i] %in% phen.loci){\n          phen.nodes[[tree$edge[x[i],2]]] <- .switch.phen(phen.nodes[[tree$edge[x[i],1]]])\n        }else{\n          ## if no phen subs occur on branch i, set phen of\n          ## downstream individual to be equal to ancestor's\n          phen.nodes[[tree$edge[x[i],2]]] <- phen.nodes[[tree$edge[x[i], 1]]]\n        }\n      } # end for loop\n\n      ## get phen of TERMINAL nodes (leaves)\n      n.ind <- tree$Nnode+1\n      phen.leaves <- as.factor(as.vector(unlist(phen.nodes[c(1:n.ind)])))\n      names(phen.leaves) <- paste(\"ind\", c(1:length(phen.leaves)), sep=\".\")\n\n\n      ## CHECK THAT MIN GRP.SIZE >= THRESHOLD ##\n      if(!is.null(grp.min)){\n        tab <- table(phen.leaves)\n        grp.thresh <- (tree$Nnode+1)*grp.min\n        if(min(tab) < grp.thresh){\n          toRepeat <- TRUE\n        }else{\n          toRepeat <- FALSE\n        }\n      }else{\n        toRepeat <- FALSE\n      }\n\n    } # end WHILE LOOP #########\n\n\n    ## get phen of branches\n    for(i in 1:length(x)){\n      ## Branches with ONE phenotype get labelled by that phenotype:\n      if(length(unique(phen.nodes[tree$edge[x[i],]])) == 1){\n        if(\"A\" %in% phen.nodes[tree$edge[x[i],]]){\n          phen.branch[[x[i]]] <- \"A\"\n        }else{\n          phen.branch[[x[i]]] <- \"B\"\n        }\n      }else{\n        ## Branches with TWO phenotypes get labelled as such, in ORDER:\n        temp <- as.vector(unlist(phen.nodes[tree$edge[x[i],]]))\n        if(temp[1] == \"A\"){\n          phen.branch[[x[i]]] <- c(\"A\", \"B\")\n        }else{\n          phen.branch[[x[i]]] <- c(\"B\", \"A\")\n        }\n      }\n    } # end for loop\n\n  } ## end PHEN sim procedure...\n\n  ## convert phen.nodes to factor\n  phen.nodes <- as.factor(as.vector(unlist(phen.nodes)))\n  if(!is.null(names(phen.leaves))){\n    names(phen.leaves) <- paste(\"ind\",\n                                c(1:length(phen.leaves)),\n                                sep=\".\")\n  }\n  if(!is.null(names(phen.nodes))){\n    names(phen.nodes) <- c(names(phen.leaves),\n                           paste(\"node\",\n                                 c((length(phen.leaves)+1):length(phen.nodes)),\n                                 sep=\".\"))\n  }\n  ## make output list\n  phen.list <- list(phen.leaves, phen.nodes, phen.branch, phen.loci)\n  names(phen.list) <- c(\"phen\", \"phen.nodes\", \"phen.edges\", \"phen.loci\")\n\n  return(phen.list)\n} # end phen.sim\n",
    "created" : 1460133939515.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "498750010",
    "id" : "3205DE08",
    "lastKnownWriteTime" : 1468529767,
    "path" : "~/treeWAS/pkg/R/phen.sim.R",
    "project_path" : "R/phen.sim.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}