{
    "contents" : "\n####################\n## coalescent.sim ##\n####################\n\n## a function for simulating trees under a fully-linked coalescent model.\n## optional simulation of a phenotype and phenotypically-associated SNPs is implemented.\n## optional use of a distribution to guide the substitution rate of the non-associated SNPs is implemented.\n\n## TO DO:\n## 1) (Re-)implement associated SNP randomization procedure...\n## want to implement procedures that combine the above options...\n## 2) Allow phenotypically-associated SNPs simulation to be optionally guided\n## by a user-inputted phenotype for the terminal nodes (--> would need to simulate\n## phenotypic substitutions from the terminal nodes UP to the root, the reverse\n## of the current procedure...)\n## 3) Implement assoc.options (currently using deprecated \"all\" option without requiring argument,\n## but would like to consider implementing alternative \"model\" option(s))\n\n\n## ARGUMENTS ##\n# n.ind <- 10 # n.genomes you want to end up with\n# gen.size <- 1000000 # bases\n# theta <- gen.size*2 # (if sim.by==\"branch\")# OR # 1*2 # (if sim.by==\"locus\")\n# biallelic <- TRUE # if TRUE, select ONLY complementary nt; if FALSE,\n#                select from 3 alternatives (ie. A/C/G/T-current nt)\n# seed <- 1 # allow user to control randomization to get reproducible results.\n# n.snps.assoc <- 5\n# assoc.option <- c(\"all\", \"model\") # deprecated (only \"all\" available)\n# sim.by <- c(\"locus\", \"branch\") # deprecated (only \"locus\" has all current protocols implemented)\n\n\n## EXAMPLE ##\n# out <- coalescent.sim(n.ind=100, gen.size=10000, sim.by=\"locus\",\n#                       theta=1*2, dist=NULL,\n#                       theta_p=15, phen=NULL,\n#                       n.snps.assoc=20, assoc.option=\"all\", assoc.prob=90,\n#                       haploid=TRUE, biallelic=TRUE, seed=1,\n#                       plot=TRUE, heatmap=FALSE, plot2=\"UPGMA\")\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param n.ind An integer specifying the number of individual genomes to simulate\n#' (ie. the number of terminal nodes in the tree).\n#' @param n.snps An integer specifying the number of genetic loci to simulate.\n#' @param n.subs Either an integer or a vector (containing a distribution) that is\n#' used to determine the number of substitutions\n#' to occur on the phylogenetic tree for each genetic locus (see details).\n#' @param n.snps.assoc An optional integer specifying the number of genetic loci\n#' @param assoc.prob An optional integer (> 0, <= 100) specifying the strength of the\n#' association between the n.snps.assoc loci and the phenotype (see details).\n#' @param n.phen.subs An integer specifying the expected number of phenotypic\n#' substitutions to occur on the phylogenetic tree (through the same process as\n#' the n.subs parameter when n.subs is an integer (see details)).\n#' @param phen An optional vector containing a phenotype for each of the\n#' n.ind individuals if no phenotypic simulation is desired.\n#' @param heatmap A logical indicating whether to produce a heatmap of the genetic distance\n#' between the simulated genomes of the n.ind individuals.\n#' @param reconstruct Either a logical indicating whether to attempt to reconstruct\n#' a phylogenetic tree using the simulated genetic data, or one of c(\"UPGMA\", \"nj\", \"ml\")\n#' to specify that tree reconstruction is desired by one of these three methods\n#' (Unweighted Pair Group Method with Arithmetic Mean, Neighbour-Joining, Maximum-Likelihood).\n#' @param seed An optional integer controlling the pseudo-random process of simulation. Two\n#' instances of coalescent.sim with the same seed and arguments will produce identical output.\n#'\n#' @details #### n.subs ####\n#' If the value of the n.subs parameter is set to an integer, this integer is\n#' used as the parameter of a Poisson distribution from which the number of substitutions to\n#' occur on the phylogenetic tree is drawn for each of the n.snps simulated genetic loci.\n#' If n.subs is a vector containing a distribution, this is used directly (in proportion to n.snps)\n#' to define the number of substitutions per site. For example, if n.subs=c(3000, 900, 70, 20, 0, 10)\n#' and n.snps=8000, then 6000 simulated sites will undergo exactly\n#' one substitution somewhere on the phylogenetic tree, 1800 will undergo two,\n#' 140 three, 40 four, 0 five, and 20 six.\n#' #### assoc.prob ####\n#' The assoc.prob parameter controls the strength of association through a process analagous to dilution.\n#' All n.snps.assoc loci are initially simulated to undergo a substitution\n#' every time the phenotype undergoes a substitution (ie. perfect association).\n#' The assoc.prob parameter then acts like a dilution factor, removing (100 - assoc.prob)%\n#' of the substitutions that occurred during simulation under perfect association.\n#'\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## load data\n#' data(dist)\n#' str(dist)\n#'\n#' ## basic use of fn\n#' fn(arg1, arg2)\n#'\n#' #' ## more elaborate use of fn\n#' fn(arg1, arg2)\n#'\n#' @import adegenet ape phangorn\n\n########################################################################\n\n############\n## NOTES: ##\n############\n## theta_p changed to n.phen.subs (and just n.subs in phen.sim.R)\n\n\n## OLD ARGS: ##\n# (n.ind=100, gen.size=10000, sim.by=\"locus\",\n#  theta=1*2, dist=NULL,\n#  n.phen.subs=15, phen=NULL,\n#  n.snps.assoc=5, assoc.option=\"all\", assoc.prob=90,\n#  haploid=TRUE, biallelic=TRUE, seed=NULL,\n#  plot=TRUE, heatmap=FALSE, plot2=\"UPGMA\")\n\n## NEW ARGS: ##\n# n.ind <- 100\n# n.snps <- 10000\n# n.subs <- 1\n# n.snps.assoc <- 10\n# assoc.prob <- 90\n# n.phen.subs <- 15\n# phen <- NULL\n# plot <- TRUE\n# heatmap <- FALSE\n# reconstruct <- FALSE\n# dist.dna.model <- \"JC69\"\n# grp.min <- 0.25\n# row.names <- NULL\n# seed <- 4\n\n\ncoalescent.sim <- function(n.ind=100,\n                           n.snps=10000,\n                           n.subs=1,\n                           n.snps.assoc=0,\n                           assoc.prob=100,\n                           n.phen.subs=15,\n                           phen=NULL,\n                           plot=TRUE,\n                           heatmap=FALSE,\n                           reconstruct=FALSE,\n                           dist.dna.model=\"JC69\",\n                           grp.min = NULL,\n                           row.names=NULL,\n                           seed=1){\n  ## load packages:\n  require(adegenet)\n  require(ape)\n  require(phangorn)\n\n  if(length(which(c(plot, heatmap, reconstruct)==TRUE))==1){\n    par(ask=FALSE)\n  }else{\n    par(ask=TRUE)\n  }\n\n  ################################\n  ## Simulate Phylogenetic Tree ##\n  ################################\n  tree <- coalescent.tree.sim(n.ind = n.ind, seed = seed)\n\n  ########################\n  ## Simulate Phenotype ##\n  ########################\n  if(is.null(phen)){\n    ## get list of phenotype simulation output\n    phen.list <- phen.sim(tree, n.subs = n.phen.subs, grp.min = grp.min, seed = seed)\n\n    ## get phenotype for terminal nodes only\n    phen <- phen.list$phen\n\n    ## get phenotype for all nodes,\n    ## terminal and internal\n    phen.nodes <- phen.list$phen.nodes\n\n    ## get the indices of phen.subs (ie. branches)\n    phen.loci <- phen.list$phen.loci\n  }else{\n    #############################\n    ## User-provided Phenotype ##\n    #############################\n    phen.nodes <- phen\n    phen.loci <- NULL\n  }\n\n  #################################\n  ## Plot Tree showing Phenotype ##\n  #################################\n  if(plot==TRUE){\n    phen.plot.col <- plot.phen(tree = tree,\n                              phen.nodes = phen.nodes,\n                              plot = plot)\n  }\n\n  ###################\n  ## Simulate SNPs ##\n  ###################\n\n  ## TO DO: #######################################\n  ## CHECK SNP SIMULATION FOR COMPUTATIONAL SPEED! #########################################################################################\n  #################################################\n  ## 10 --> 53 --> 12.5\n  ## Are the remaining extra 2.5 seconds still just a result of the while loop??\n  ## Or have I slowed anything down in the post-processing steps as well??????????????????\n\n  #   n.snps <- 10000 # 13.3\n  #   n.snps <- 100000 # 153.8\n  #   n.snps <- 1000000 # >> 1941.7 (stopped trying..)\n  #\n  #   system.time(\n  snps.list <- snp.sim(n.snps=n.snps,\n                       n.subs=n.subs,\n                       n.snps.assoc=n.snps.assoc,\n                       assoc.prob=assoc.prob,\n                       tree=tree,\n                       phen.loci=phen.loci,\n                       heatmap=heatmap,\n                       reconstruct=reconstruct,\n                       dist.dna.model=dist.dna.model,\n                       row.names = NULL,\n                       seed=seed)\n  # )\n\n  snps <- snps.list$snps\n  snps.assoc <- snps.list$snps.assoc\n\n  ################\n  ## Get Output ##\n  ################\n  out <- list(snps, snps.assoc, phen, phen.plot.col, tree)\n  names(out) <- c(\"snps\", \"snps.assoc\", \"phen\", \"phen.plot.col\", \"tree\")\n  return(out)\n\n} # end coalescent.sim\n",
    "created" : 1460133923966.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4013608434",
    "id" : "E2B81033",
    "lastKnownWriteTime" : 1468858326,
    "path" : "~/treeWAS/pkg/R/coalescent.sim.R",
    "project_path" : "R/coalescent.sim.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}