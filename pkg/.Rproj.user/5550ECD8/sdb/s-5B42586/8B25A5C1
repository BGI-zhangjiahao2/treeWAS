{
    "contents" : "\n\n#############\n## snp.sim ##\n#############\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param snps description.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#'\n#' @examples\n#' ## Example ##\n#'\n#' @import adegenet ape phangorn\n\n########################################################################\n\n## ARGUMENTS: ##\n\n## n.subs <- either an integer or a vector containing a distribution of n.subs-per-site\n## phen.loci <- a vector containing the indices of the edges on which phen subs occurred\n\n\nsnp.sim <- function(n.snps = 10000,\n                    n.subs = 1,\n                    snp.root = NULL,\n                    n.snps.assoc = 10,\n                    assoc.prob = 100,\n                    tree = coalescent.tree.sim(100),\n                    phen.loci = NULL,\n                    heatmap = FALSE,\n                    reconstruct = FALSE,\n                    dist.dna.model = \"JC69\",\n                    row.names = NULL,\n                    coaltree = TRUE,\n                    set=NULL,\n                    seed=1){\n\n  # require(adegenet)\n  # require(ape)\n  # require(phangorn)\n\n  ##################################\n  ## GET MUTATIONS' branch & loci ##\n  ##################################\n  n.ind <- tree$Nnode+1\n  gen.size <- n.snps\n  edges <- tree$edge\n\n  if(!is.null(seed)) set.seed(seed)\n\n  ## Simulate genotype for root individual: ##\n\n  ## For n.subs = n or = dist approaches:\n  gen.root <- sample(c(\"a\", \"c\", \"g\", \"t\"), gen.size, replace=TRUE)\n\n  ## For ACE/Pagel-test approach:\n  if(class(n.subs) == \"matrix\"){\n  ## Input = either:\n  ## one state (chosen by directly selecting the more likely state), or\n  ## two likelihoods (taken from fit.iQ$lik.anc[1,] from w/in fitPagel).\n\n  ## One state:\n  if(!is.null(snp.root)){\n    if(length(snp.root) == 1){\n      ## select only root state --> different SNP sim method (???)\n      if(snp.root == 0) gen.root <- \"a\"\n      if(snp.root == 1) gen.root <- \"t\"\n\n      ## select root state & assign this state to all nodes,\n      ## to be changed later by a modifiction of the existing SNP sim method...\n      #if(snp.root == 0) gen.root <- rep(\"a\", gen.size)\n      #if(snp.root == 1) gen.root <- rep(\"t\", gen.size)\n    }\n  }\n  }\n  ## get the sum of all branch lengths in the tree:\n  time.total <- sum(tree$edge.length)\n\n  ## make dummy variables in which to store the resulting n.mts variables:\n  L <- lambda <- n.mts <- new.nt <- NA\n\n  snps.assoc <- NULL\n\n  ## if n.snps.assoc is neither NULL nor 0:\n  if(is.null(n.snps.assoc)) n.snps.assoc <- 0\n  if(n.snps.assoc != 0){\n\n    ## get non.assoc gen.size\n    gen.size.ori <- gen.size\n    gen.size <- gen.size-n.snps.assoc\n\n    ## assign snps.assoc to be the last n.snps.assoc snps columns\n    snps.assoc <- c((gen.size+1):(gen.size+n.snps.assoc))\n  }\n\n  ###################\n  ## Handle n.subs ##\n  ###################\n\n  ## Either an integer\n  ## --> draw n.subs from a Poisson distribution w parameter n.subs\n  ## OR a vector (containing a distribution)\n  ## --> use this distribution to define n.subs-per-site\n\n  if(length(n.subs)==1){\n\n    #####################\n    ## NO DISTRIBUTION ##\n    #####################\n\n    ## if no distribution is inputted,\n    ## use normal simulation procedure\n    ## (ie. Poisson parameter 1):\n\n    ## draw the number of mutations to occur at each site:\n    n.mts <- rpois(n=gen.size, lambda=(n.subs))\n    ## for any n.mts==0, re-sample\n    for(i in 1:length(n.mts)){\n      while(n.mts[i]==0){\n        n.mts[i] <- rpois(n=1, lambda=(n.subs))\n      }\n    }\n\n    }else{\n\n      ###############################################\n      ## DISTRIBUTION or RATES (fitPagel Q matrix) ##\n      ###############################################\n\n      ##################\n      ## DISTRIBUTION ##\n      ##################\n\n      ## if a distribution is provided by the user,\n      ## we use this to determine the number of substitutions\n      ## to occur at what proportion of sites (note that\n      ## we may not be simulating the same number of sites)\n\n      dist <- n.subs\n\n      ## get dist.prop, a distribution containing the counts\n      ## of the number of SNPs to be simulated that will have\n      ## i many substitutions\n      dist.sum <- sum(dist)\n      dist.prop <- round((dist/dist.sum)*gen.size)\n      ## check that these counts sum to gen.size,\n      ## else add the remainder to the largest n.subs count\n      ## (OR should we just add these to the n.subs=1 set ??? ###\n      ## likely to be the same thing, but could not be...)\n      if(sum(dist.prop) != gen.size){\n        m <- which.max(dist.prop)\n        #m <- 1\n        if(sum(dist.prop) < gen.size){\n          dist.prop[m] <- dist.prop[m] + (gen.size - sum(dist.prop))\n        }\n        if(sum(dist.prop) > gen.size){\n          dist.prop[m] <- dist.prop[m] - (sum(dist.prop) - gen.size)\n        }\n      }\n\n      ## get rid of useless trailing 0s\n      while(dist.prop[length(dist.prop)] == 0){\n        dist.prop <- dist.prop[c(1:(length(dist.prop)-1))]\n      }\n\n      ## make n.mts, a vector of length ncol(snps)\n      n.mts <- rep(1111, gen.size)\n      loci.available <- c(1:gen.size)\n      ## assign dist.prop[i] elements of n.mts\n      ## to be the same as the n.subs\n      ## indicated by i, the given element of dist.prop\n      for(j in 1:length(dist.prop)){\n        ## provided there are not 0 sites to have this number of substitutions...\n        if(dist.prop[j] > 0){\n          if(length(loci.available) > 1){\n            ## assign dist.prop[i] elements of n.mts to be i\n            loci.selected <- sample(loci.available, dist.prop[j], replace = FALSE)\n            loci.available <- loci.available[-which(loci.available %in% loci.selected)]\n          }else{\n            ## if there is only 1 (the last) loci available,\n            ## we select this one:\n            loci.selected <- loci.available\n          }\n          n.mts[loci.selected] <- j\n        }\n      }\n      # } # end dist\n  } # end fitPagel or dist\n\n  ############################\n  ## Assign mts to branches ##\n  ############################\n\n  if(n.snps.assoc != 0){\n    ## for snps.assoc (the last n.snps.assoc snps, for now),\n    ## add n.mts == n.phen.loci s.t these sites mutate at each\n    ## and every phen.loci (for now, to be diluted later\n    ## according to assoc.prob if !=100)\n    n.mts <- c(n.mts, rep(length(phen.loci), n.snps.assoc))\n  }\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n  #############################################################################\n  ## GENERATE ALL SNPs FIRST, THEN REPLACE ANY NON-POLYMORPHIC IN WHILE LOOP ##\n  #############################################################################\n\n  #############################\n  ## GET NON-ASSOCIATED SNPS ##\n  #############################\n\n  ## for each site, draw the branches to which\n  ## you will assign the mts for this site\n  ## (~ branch length):\n\n  ## Get vector of FALSEs of length tree$edge.length:\n  null.vect <- rep(FALSE, length(tree$edge.length))\n\n  snps.loci <- sapply(c(1:length(n.mts)),\n                      function(e)\n                        replace(null.vect,\n                        sample(c(1:length(tree$edge.length)),\n                               n.mts[e],\n                               replace=FALSE,\n                               prob=tree$edge.length), TRUE))\n\n  ## rearrange snps.loci s.t it becomes a\n  ## list of length tree$edge.length,\n  ## each element of which contains the\n  ## locations of the mutations that will\n  ## occur on that branch\n  snps.loci <- sapply(c(1:nrow(snps.loci)),\n                       function(e) which(snps.loci[e,] == TRUE))\n\n\n  ## get the node names for all individuals (terminal and internal)\n  all.inds <- sort(unique(as.vector(unlist(tree$edge))))\n  # we will store the output in a list called genomes:\n  genomes <- list()\n  ## we start w all inds having same genotype as root:\n  for(i in all.inds){\n    genomes[[all.inds[i]]] <- gen.root\n  }\n  ## store replacement nts in list new.nts:\n  new.nts <- list()\n  ## distinguish btw list of loci and unique list\n  snps.loci.ori <- snps.loci\n  ## will need to treat repeat loci differently...\n  snps.loci.unique <- lapply(snps.loci, unique)\n  ## the last individual in the first column of tree$edge\n  ## (ie. ind.length(tree$tip.label)+1 ) is our root individual:\n  x <- rev(c(1:nrow(tree$edge)))\n\n  if(coaltree == FALSE){\n    ## use normal/reverse (top:bottom) edge mat:\n    x <- 1:nrow(tree$edge)\n  }\n\n  #############################\n  ## For Loop to get new nts ##\n  #############################\n  for(i in x){\n    ## for all genomes other than root, we mutate the\n    ## genome of the node preceding it, according to snps.loci.\n    ## Draw new nts for each locus selected for mutation:\n    if(!.is.integer0(snps.loci.unique[[i]])){\n      new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)\n        selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                       %in% genomes[[tree$edge[i,1]]]\n                                                       [snps.loci.unique[[i]][e]])]))\n      ## if any loci are selected for multiple mutations\n      ## within their given branch length:\n      if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){\n        ## identify which loci are repeaters\n        repeats <- table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]\n        ## how many times they repeat\n        n.reps <- repeats - 1\n        ## the positions of these loci in the vector of snps loci\n        toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))\n        ## run chain of re-sampling to end in our new nt for repeater loci:\n        foo <- list()\n        for(j in 1:length(toRepeat)){\n          foo[[j]] <- new.nts[[i]][toRepeat[j]]\n          for(k in 1:n.reps[j]){\n            if(k==1){\n              foo[[j]][k] <- selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                                            %in% foo[[j]][1])])\n\n            }else{\n              foo[[j]][k] <- selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                                            %in% foo[[j]][k-1])])\n            }\n          }\n          ## retain only the last nt selected\n          out <- sapply(c(1:length(foo)),\n                        function(e) foo[[e]][length(foo[[e]])])\n        }\n        ## for the loci with repeated mts, replace these positions\n        ## in new.nts with the corresponding elements of out, above.\n        new.nts[[i]][toRepeat] <- out\n      } # end of if statement for repeaters\n\n      ## update ancestral genotype with new.nts:\n      temp <- genomes[[tree$edge[i,1]]]\n      temp[snps.loci.unique[[i]]] <- new.nts[[i]]\n      genomes[[tree$edge[i,2]]] <- temp\n\n    }else{\n      ## if no mts occur on branch, set genotype of\n      ## downstream individual to be equal to ancestor's\n      genomes[[tree$edge[i,2]]] <- genomes[[tree$edge[i,1]]]\n    }\n  } # end of for loop selecting new nts at mutator loci\n\n  ####################################################\n  ## CHECK IF ALL LOCI ARE POLYMORPHIC (|polyThres) ##\n  ####################################################\n\n  ## temporarily assemble non-associated loci into matrix:\n  temp.ori <- do.call(\"rbind\", genomes)\n\n  ## keep only rows containing terminal individuals:\n  temp.ori <- temp.ori[1:n.ind, ]\n\n  #########################\n  ## Get UNIQUE snps.rec ##\n  #########################\n  temp <- get.unique.matrix(temp.ori, MARGIN=2)\n  temp.unique <- temp$unique.data\n  index <- temp$index\n\n  if(ncol(temp.unique) == ncol(temp.ori)){\n    all.unique <- TRUE\n  }else{\n    all.unique <- FALSE\n  }\n\n  ## work w only unique snps:\n  temp <- temp.unique\n\n  #   ## Make loci list (in case you need it later (ie. if any loci not polymorphic))\n  #   loci <- list()\n  #   for(i in 1:ncol(temp)){\n  #     loci[[i]] <- temp[,i]\n  #   }\n\n  ## identify n.minor.allele required to meet polyThres:\n  polyThres <- 0.01\n  n.min <- n.ind*polyThres\n\n  ## make a list of any NON-polymorphic loci:\n  toRepeat <- list()\n  for(i in 1:ncol(temp)){\n    if(any(table(temp[,i]) < n.min) | length(table(temp[,i])) == 1){\n      toRepeat[[length(toRepeat)+1]] <- i\n    }\n  }\n  if(length(toRepeat) > 0){\n    toRepeat <- as.vector(unlist(toRepeat))\n  }\n\n\n\n\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n  #################################################################\n  ## REPLACE ANY NON-POLYMORPHIC LOCI & GENERATE ASSOCIATED SNPS ##\n  #################################################################\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n\n\n  #################################################\n  ## REPLACE NON-POLYMORPHIC NON-ASSOCIATED SNPS ##\n  #################################################\n\n  # toRepeat <- 1:length(n.mts)\n  # loci <- list()\n\n  ######################################\n  ## while loop STARTS here: ###########\n  ######################################\n  ## AGAIN--NEED TO DOUBLE CHECK: No problems with seed? #############\n\n  # counter <- 0\n  while(length(toRepeat) > 0){\n\n  for(i in toRepeat){\n    ## get the lth element of n.mts to work with:\n    n.mt <- n.mts[i]\n\n    ## for each site, draw the branches to which\n    ## you will assign the mts for this site\n    ## (~ branch length):\n\n    subs.edges <- sample(c(1:length(tree$edge.length)),\n                         n.mt,\n                         replace=FALSE,\n                         prob=tree$edge.length)\n\n    ## TO DO: COULD REPLACE (all instances!!!) LATER WITH:\n    ## Get vector of FALSEs of length tree$edge.length:\n    #     null.vect <- rep(FALSE, length(tree$edge.length))\n    #     subs.edges <- replace(null.vect,\n    #                           sample(c(1:length(tree$edge.length)),\n    #                                  n.mt,\n    #                                  replace=FALSE,\n    #                                  prob=tree$edge.length), TRUE)\n\n\n    ## get nt for root at this locus:\n    root.nt <- gen.root[i]\n\n    ## get nt for each individual at this locus\n    temp[,i] <- .get.locus(subs.edges = subs.edges,\n                            root.nt = root.nt,\n                            tree = tree,\n                            coaltree = coaltree)[1:n.ind]\n\n  } # end FOR LOOP for NON-associated SNPs\n\n  ######################################\n  ##### while loop CHECK here: #########\n  ######################################\n  ## CHECK IF ALL LOCI ARE POLYMORPHIC (|polyThres)\n\n  ## identify n.minor.allele required to meet polyThres:\n  polyThres <- 0.01\n  n.min <- n.ind*polyThres\n\n  ## make a list of any NON-polymorphic loci:\n  toRepeat.ori <- toRepeat\n  temp.toRepeat <- temp[, toRepeat.ori]\n\n\n  toRepeat <- list()\n  ## if temp.toRepeat is a true matrix:\n  if(!is.matrix(temp.toRepeat)){\n    if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){\n      toRepeat[[length(toRepeat)+1]] <- toRepeat.ori\n    }\n  }else{\n    if(ncol(temp.toRepeat) > 0){\n      for(i in 1:ncol(temp.toRepeat)){\n        if(any(table(temp.toRepeat[,i]) < n.min) | length(table(temp.toRepeat[,i])) == 1){\n          toRepeat[[length(toRepeat)+1]] <- toRepeat.ori[i]\n        }\n      }\n    }else{\n      if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){\n        toRepeat[[length(toRepeat)+1]] <- toRepeat.ori\n      }\n    }\n  }\n  if(length(toRepeat) > 0){\n    toRepeat <- as.vector(unlist(toRepeat))\n  }\n\n  # counter <- counter+1\n  # print(\"COUNTER\"); print(counter)\n\n  } # end of while loop\n  ######################################\n  ## while loop ENDS here: #############\n  ######################################\n\n\n  ## GET ALL NON-UNIQUE SNPS COLUMNS: ##\n\n  if(all.unique == TRUE){\n    temp.complete <- temp\n  }else{\n    temp.complete <- temp[, index]\n  }\n\n  colnames(temp.complete) <- colnames(temp.ori)\n  temp <- temp.complete\n\n\n\n\n  #########################\n  ## GET ASSOCIATED SNPS ##\n  #########################\n\n  ## Need to treat ASSOCIATED SNPs differently:\n  ## (non.assoc.snps do NOT need to pass the \"while\" check;\n  ## they just need to match phen.loci at this point.)\n  if(n.snps.assoc != 0){\n    ## get snps.loci for the ASSOCIATED snps (ie. set to phen.loci) ##\n    for(i in 1:n.snps.assoc){\n      ## recall: phen.loci contains the tree EDGES on which phen subs occur\n      subs.edges <- phen.loci\n\n      ## get nt for root at this locus:\n      root.nt <- gen.root[snps.assoc[i]]\n\n      ## get nt for each individual at this locus\n      ## assign to (and replace) the snps.assoc elements of loci\n      temp[, snps.assoc[i]] <- .get.locus(subs.edges = subs.edges,\n                                          root.nt = root.nt,\n                                          tree = tree,\n                                          coaltree = coaltree)[1:n.ind]\n    }\n  } # end of snps.assoc generation\n\n\n  ###########################################\n  ## GET COMPLETE SNPS MATRIX (\"genomes\"): ##\n  ###########################################\n\n  ## Create genomes matrix:\n  genomes <- temp\n  ## keep only rows containing terminal individuals:\n  genomes <- genomes[1:n.ind, ]\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n\n\n  ###############################################\n  ## MODIFY SNPS.ASSOC ACCORDING TO ASSOC.PROB ##\n  ###############################################\n\n  if(n.snps.assoc != 0){\n    ## if we have any imperfect associations... ##\n    if(any(assoc.prob != 100)){\n      ## check length\n      if(length(assoc.prob) != n.snps.assoc){\n        ## if only 1 prob value given...\n        if(length(assoc.prob) == 1){\n          ## ... assume uniform assoc.prob;\n          assoc.prob <- rep(assoc.prob, n.snps.assoc)\n          ## no warning needed\n        }else{\n          ## BUT if assoc.prob of random length:\n          ## repeat until of length n.snps.assoc\n          assoc.prob <- rep(assoc.prob, length.out=n.snps.assoc)\n          ## and print warning (only if not of length n.snps.assoc OR 1)\n          warning(\"assoc.prob not of length n.snps.assoc;\n                  sequence will be repeated until correct length is reached.\")\n        }\n        } # end checks\n\n      ## for each associated SNP,\n      ## we undo some associations | assoc.prob for that snp.assoc\n      for(i in 1:n.snps.assoc){\n\n        ## re-pseudo-randomise seed:\n        if(!is.null(seed)){\n          seed.i <- seed*i*10\n          set.seed(seed.i)\n        }\n\n        prob <- assoc.prob[i]\n        ## only if the association is imperfect\n        if(prob != 100){\n          ## draw genomes to change at snps.assoc[i]\n          n.toChange <- round(nrow(genomes)*(1 - (prob/100)))\n          toChange <- sample(c(1:nrow(genomes)), n.toChange)\n\n          ## change those genomes at rows toChange, loci snps.assoc[i]\n          for(j in 1:length(toChange)){\n            genomes[toChange[j], snps.assoc[i]] <-\n              selectBiallelicSNP(genomes[toChange[j], snps.assoc[i]])\n          } # end for loop\n        }\n      } # end for loop\n    } # end any assoc.prob != 100\n  } # end modification | assoc.prob\n\n\n  ##############################\n  ## PLOTS & TREECONSTRUCTION ##\n  ##############################\n  if(heatmap == TRUE || reconstruct!=FALSE){\n    dna <- as.DNAbin(genomes)\n    rownames(dna) <- c(1:nrow(genomes))\n  }\n\n  #############\n  ## HEATMAP ##\n  #############\n  if(heatmap==TRUE){\n    heatmap.DNAbin(dna=dna,\n                   dist.dna.model=dist.dna.model)\n  }\n\n  ##########################################\n  ## PLOT 2: RECONSTRUCTING THE PHYLOGENY ##\n  ##########################################\n  tree.reconstructed <- NULL\n  if(reconstruct!=FALSE){\n    if(reconstruct==TRUE){\n      warning(\"reconstruct should be one of 'UPGMA', 'nj', 'ml'. Choosing 'UPGMA'.\")\n    }\n\n    tree.reconstructed <- tree.reconstruct(dna[1:n.ind,],\n                                         method=reconstruct,\n                                         dist.dna.model=dist.dna.model,\n                                         plot=TRUE)\n  }\n\n  ##################\n  ## CONVERT SNPS ##\n  ##################\n\n  ## Convert from nts in genomes (for all nodes) to binary SNPs (for terminal nodes only):\n\n  ## Keep only rows containing terminal individuals?:\n  ## (NOTE -- Consider moving this to AFTER snps.assoc assoc.prob section!)\n  # genomes <- genomes[1:n.ind, ]\n\n  ## working with snps in matrix form\n  snps <- genomes\n\n  ## NO LONGER NEED THIS SECTION? ##\n  gen.size <- ncol(snps)\n\n  ## get snps as DNAbin\n  ploidy <- 1\n  snps.bin <- as.DNAbin(snps, ploidy=ploidy)\n  ## get snps as genind\n  #source(\"C:/Users/caitiecollins/adegenet/R/sequences.R\")\n  snps.gen <- DNAbin2genind(snps.bin, polyThres=0.01)\n  ## get snps as binary matrix\n  snps <- snps.gen@tab\n\n  ## correct genind for ploidy:\n  snps <- snps[,seq(1, ncol(snps), 2)]\n\n  ## assign snps row and column names:\n  colnames(snps) <- 1:ncol(snps)\n  rownames(snps) <- 1:nrow(snps)\n\n\n  if(!is.null(snps.assoc)){\n\n    ## NO LONGER NEED THIS CHECK FOR POLYMORPH HERE:\n    ## identify any columns of snps.bin that\n    ## do NOT meet DNAbin2genind polyThres\n    ## /are NOT SNPs\n    #     x <- snps.bin\n    #     if(is.list(x)) x <- as.matrix(x)\n    #     if(is.null(colnames(x))) colnames(x) <- 1:ncol(x)\n    #\n    #     temp <- lapply(1:ncol(x), function(i)\n    #       .getFixed(x[,i], i)) # process all loci, return a list\n    #     fixed.loci <- which(temp==TRUE) ## identify loci that are NOT SNPs\n\n    ## update snps.assoc to reflect true loci\n    gen.size.final <- ncol(snps)\n    snps.assoc.loci.ori <- c((gen.size.final-(n.snps.assoc-1)):gen.size.final)\n\n    #########################################\n    ## RANDOMIZE SNPS.ASSOC LOCI POSITIONS ##\n    #########################################\n\n    ## Re-enabled snps.assoc loci \"randomization\" by\n    ## just drawing indices and shuffling the columns accordingly...\n    ## draw which SNPs will be associated to the phenotype\n    snps.assoc.loci <- sort(sample(c(1:gen.size.final),\n                                   n.snps.assoc,\n                                   replace=FALSE))\n\n    snps.indices <- c(1:gen.size.final)\n    snps.ori <- snps\n\n    snps.non.assoc <- snps[,c(1:(gen.size.final-n.snps.assoc))]\n    snps.assoc <- snps[,snps.assoc.loci.ori]\n    snps.new <- matrix(99, nrow=nrow(snps), ncol=gen.size.final)\n    snps.new[,snps.indices[-snps.assoc.loci]] <- snps.non.assoc\n    snps.new[,snps.assoc.loci] <- snps.assoc\n    snps <- snps.new\n    snps.assoc <- snps.assoc.loci\n\n  } # end snps.assoc randomization\n\n  ###############################\n  ## Assign row & column names ##\n  ###############################\n\n  ## assign/generate row.names\n  if(!is.null(row.names)){\n    if(length(row.names) == nrow(snps)){\n      rownames(snps) <- row.names\n    }else{\n      if(is.null(rownames(snps))) rownames(snps) <- c(1:nrow(snps))\n    }\n  }else{\n    if(is.null(rownames(snps))) rownames(snps) <- c(1:nrow(snps))\n  }\n\n  ## generate column names:\n  colnames(snps) <- 1:ncol(snps)\n\n\n  #################################################\n  ## SIM SET 2 (complementary clade-wise assoc): ##\n  #################################################\n  sets <- NULL\n  if(!is.null(snps.assoc)){\n    if(!is.null(set)){\n      if(set == 2){\n\n        ## Want to divide tree into 2 sets of clades btw 1/3:2/3 and 1/2:1/2\n        clades <- tab <- grp.options <- sets.complete <- list()\n\n        min.size <- ceiling((tree$Nnode+1)*(1/3))\n        max.size <- floor((tree$Nnode+1)*(2/3))\n        grp1 <- tree$Nnode+1\n\n        ## get 2 sets of clades:\n\n        ##############\n        ## coaltree ##\n        ##############\n\n        if(coaltree == TRUE){\n          ## Get tree as hclust tree:\n          tree.hc <- as.hclust.phylo(tree)\n\n          i <- 2\n          counter <- 0\n          #######################################\n          ## WHILE LOOP to get size of clades: ##\n          #######################################\n          while(grp1 < min.size | grp1 > max.size){\n            clades[[i]] <- cutree(tree.hc, k=i)\n            tab[[i]] <- table(clades[[i]])\n            # grp.opts <- grp.options[[i]] <- sapply(c(1:(i-1)), function(e) sum(tab[[i]][1:e]))\n            grp.opts <- grp.options[[i]] <- sapply(c(1:(i)), function(e) sum(tab[[i]][1:e]))\n            ## make grp1 first clade in grp.options:\n            group1 <- grp.opts[1]\n            ## remove first clade from options:\n            grp.opts <- grp.opts[-1]\n            ## and record n.grps:\n            n.grp <- 1\n            ## try to identify a (set of) clade(s) that's big enough (but not too big):\n            while(group1 < min.size){\n              group1 <- sum(group1, grp.opts[1])\n              grp.opts <- grp.opts[-1]\n              n.grp <- n.grp+1\n            }\n            sets.complete[[i]] <- replace(clades[[i]], which(clades[[i]] %in% (1:n.grp)), 1)\n            sets.complete[[i]] <- replace(sets.complete[[i]], which(!clades[[i]] %in% (1:n.grp)), 2)\n            grp1 <- sum(grp.options[[i]][1:n.grp])\n            k <- i\n            i <- i+1\n            counter <- counter+1\n          } # end while loop\n          ###########\n\n          sets <- sets.complete[[length(sets.complete)]]\n\n          ###########\n\n        }else{\n          ###########\n          ## rtree ##\n          ###########\n          dec <- grp <- sets.temp <- sets.complete <- list()\n\n          inds <- c(1:(tree$Nnode+1))\n          new.root <- tree$edge[1,1] # initial root\n\n          counter <- 0\n          #######################################\n          ## WHILE LOOP to get size of clades: ##\n          #######################################\n          while(grp1 < min.size | grp1 > max.size){\n\n            ## get all descendants of root node:\n            all.dec <- .getDescendants(tree, node=new.root)\n\n            ## get all descendants in first 2 major clades:\n            dec[[1]] <- .getDescendants(tree, node=all.dec[1])\n            dec[[2]] <- .getDescendants(tree, node=all.dec[2])\n\n            ## get terminal inds only:\n            sets.temp[[1]] <- dec[[1]][which(dec[[1]] %in% inds)]\n            sets.temp[[2]] <- dec[[2]][which(dec[[2]] %in% inds)]\n\n            grp[[1]] <- length(sets.temp[[1]])\n            grp[[2]] <- length(sets.temp[[2]])\n\n            max.grp <- which.max(c(grp[[1]], grp[[2]]))\n            new.root <- all.dec[max.grp]\n\n            set1 <- sets.temp[[max.grp]]\n\n            sets <- rep(2, length(inds))\n            sets <- replace(sets, set1, 1)\n            # names(sets) <- rownames(snps)\n            names(sets) <- removeFirstN(tree$tip.label, 1) ## assuming all rtrees preface their tip.labs w \"t\"...\n\n            counter <- counter+1\n\n            grp1 <- grp[[max.grp]]\n\n          } # end while loop\n\n        } # end rtree\n\n        ###########################\n        ## BOTH coaltree & rtree ##\n        ###########################\n\n        set1 <- names(sets)[which(sets == 1)]\n        set2 <- names(sets)[which(sets == 2)]\n        ###########\n\n        ########################\n        ## MODIFY SNPS.ASSOC: ##\n        ########################\n        snps.assoc.set1 <- 1:round(length(snps.assoc)/2)\n        snps.assoc.set2 <- (round(length(snps.assoc)/2)+1):length(snps.assoc)\n\n        ## replace set1 snps with 0 at all inds in clade.set1:\n        for(e in 1:length(snps.assoc.set1)){\n          if(coaltree == TRUE){\n            snps[which(rownames(snps) %in% set1), snps.assoc[snps.assoc.set1[e]]] <- 0\n          }else{\n            snps[which(rownames(snps) %in% set1), snps.assoc[snps.assoc.set1[e]]] <- 0\n          }\n        }\n        ## replace set2 snps with 0 at all inds in clade.set2:\n        for(e in 1:length(snps.assoc.set2)){\n          snps[which(rownames(snps) %in% set2), snps.assoc[snps.assoc.set2[e]]] <- 0\n        }\n      }\n    }\n  } # end sim set 2\n\n\n  ##################\n  ## get RESULTS: ##\n  ##################\n  out <- list(snps, snps.assoc, tree.reconstructed, sets)\n  names(out) <- c(\"snps\", \"snps.assoc\", \"tree.reconstructed\", \"sets\")\n\n  return(out)\n\n} # end snp.sim\n\n\n\n\n\n\n\n\n\n\n\n\n################\n## .get.locus ##\n################\n.get.locus <- function(subs.edges, root.nt, tree, coaltree=TRUE){\n\n  ## convert subs.edges into appropriate format:\n  snps.loci <- list()\n  snps.loci[[1]] <- subs.edges\n\n  ## rearrange snps.loci s.t it becomes a\n  ## list of length tree$edge.length,\n  ## each element of which contains the\n  ## locations of the mutations that will\n  ## occur on that branch\n  snps.loci <- sapply(c(1:length(tree$edge.length)),\n                      function(f)\n                        seq_along(snps.loci)[sapply(snps.loci,\n                                                    function(e) f %in% e)])\n\n\n  # we will store the output in a list called locus:\n  locus <- list()\n  ## get the node names for all individuals (terminal and internal)\n  all.inds <- sort(unique(as.vector(unlist(tree$edge))))\n  ## we start w all inds having same genotype as root:\n  for(j in all.inds){\n    locus[[j]] <- root.nt\n  }\n\n  ## store replacement nts in list new.nts:\n  new.nts <- list()\n  ## distinguish btw list of loci and unique list\n  snps.loci.ori <- snps.loci\n  ## will need to treat repeat loci differently...\n  snps.loci.unique <- lapply(snps.loci, unique)\n  ## the last individual in the first column of tree$edge\n  ## (ie. ind.length(tree$tip.label)+1 ) is our root individual:\n  x <- rev(c(1:nrow(tree$edge)))\n\n  if(coaltree == FALSE){\n    ## use normal/reverse (top:bottom) edge mat:\n    x <- 1:nrow(tree$edge)\n  }\n\n  #############################\n  ## For Loop to get new nts ##\n  #############################\n  for(i in x){\n    ## for all locus other than root, we mutate the\n    ## genome of the node preceding it, according to snps.loci.\n    ## Draw new nts for each locus selected for mutation:\n    if(!.is.integer0(snps.loci.unique[[i]])){\n      new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)\n        selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                       %in% locus[[tree$edge[i,1]]]\n                                                       [snps.loci.unique[[i]][e]])]))\n      ## if any loci are selected for multiple mutations\n      ## within their given branch length:\n      if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){\n        ## identify which loci are repeaters\n        repeats <-table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]\n        ## how many times they repeat\n        n.reps <- repeats - 1\n        ## the positions of these loci in the vector of snps loci\n        toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))\n        ## run chain of re-sampling to end in our new nt for repeater loci:\n        foo <- list()\n        for(j in 1:length(toRepeat)){\n          foo[[j]] <- new.nts[[i]][toRepeat[j]]\n          for(k in 1:n.reps[j]){\n            if(k==1){\n              foo[[j]][k] <- selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                                            %in% foo[[j]][1])])\n\n            }else{\n              foo[[j]][k] <- selectBiallelicSNP(c(\"a\", \"c\", \"g\", \"t\")[which(c(\"a\", \"c\", \"g\", \"t\")\n                                                                            %in% foo[[j]][k-1])])\n            }\n          }\n          ## retain only the last nt selected\n          out <- sapply(c(1:length(foo)),\n                        function(e) foo[[e]][length(foo[[e]])])\n        }\n        ## for the loci with repeated mts, replace these positions\n        ## in new.nts with the corresponding elements of out, above.\n        new.nts[[i]][toRepeat] <- out\n      } # end of if statement for repeaters\n\n      ## update ancestral genotype with new.nts:\n      temp <- locus[[tree$edge[i,1]]]\n      temp[snps.loci.unique[[i]]] <- new.nts[[i]]\n      locus[[tree$edge[i,2]]] <- temp\n\n    }else{\n      ## if no mts occur on branch, set genotype of\n      ## downstream individual to be equal to ancestor's\n      locus[[tree$edge[i,2]]] <- locus[[tree$edge[i,1]]]\n    }\n  } # end of for loop selecting new nts at mutator loci\n\n  ## turn locus into a vector for easier post-handling\n  locus <- as.vector(unlist(locus))\n\n  return(locus)\n\n} # end .get.locus\n",
    "created" : 1476486397146.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4233345629",
    "id" : "8B25A5C1",
    "lastKnownWriteTime" : 1476506770,
    "path" : "C:/Users/Caitlin/treeWAS/pkg/R/snp.sim.R",
    "project_path" : "R/snp.sim.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : true,
    "type" : "r_source"
}