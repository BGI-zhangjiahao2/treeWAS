{
    "contents" : "\n\n#############\n## snp.sim ##\n#############\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param snps description.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#'\n#' @examples\n#' ## Example ##\n#'\n#' @import adegenet ape phangorn\n\n########################################################################\n\n## ARGUMENTS: ##\n\n## n.subs <- either an integer or a vector containing a distribution of n.subs-per-site\n## phen.loci <- a vector containing the indices of the edges on which phen subs occurred\n\n# snps <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_snps.Rdata\"))\n# phen <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_phen.Rdata\"))\n# perf <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_performance.Rdata\"))\n# snps.assoc <- perf$snps.assoc\n#\n# res <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_res.Rdata\"))\n# tree <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_tree.Rdata\"))\n# tree <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_Q.corr_unweighted/set3_9_tree.Rdata\"))\n# tree <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set3/08.2016/set3_9_tree.Rdata\"))\n\n# phen.rec <- res$dat$phen.rec\n# snps.rec <- res$dat$snps.rec\n#\n# plot.phen(tree, phen.nodes=phen.rec, snp.nodes=snps.rec[,i])\n#\n# ## NOTE-- snps.rec has inverted snps numbering (ie. 0,1 --> 2,1)\n# ## AND kept plink version w added columns:\n# snps <- snps[, seq.int(1, ncol(snps), 2)]\n# rownames(snps) <- c(1:nrow(snps))\n# colnames(snps) <- c(1:ncol(snps))\n# str(snps)\n\n###########################################\n## trying to get RATES out of Q probs... ##\n###########################################\n# SCORE3 <- get(load(\"C:/Cait 2016/Work/Xavier/Sims/set3/set3_9_score3.Rdata\"))\n#\n# Q.ew <- SCORE3$corr.dat[[13]]\n# Q.uw <- SCORE3$corr.dat[[14]]\n#\n# score3 <- SCORE3$corr.dat[[6]]\n#\n# i <- snps.assoc[3]\n#\n# #######################\n# ## UN-edge-weighted: ##\n# #######################\n#\n# Qi <- Q.uw[[i]]\n#\n# ## get NUMBERS of subs:\n# Qi.subs <- Qi*length(score3[[i]][!is.na(score3[[i]])])\n# # NOTICE much heavier diagonal :)\n#\n# ## re-weight by ROW?:\n# temp <- t(sapply(c(1:nrow(Qi.subs)),\n#                function(e)\n#                  Qi.subs[e,]/sum(Qi.subs[e,])))\n# colnames(temp) <- rownames(temp) <- colnames(Qi.subs)\n# temp.uw <- temp\n# temp.uw\n#\n# ## all rows should sum to 1:\n# sum(temp.uw[1,])\n#\n#\n# ####################\n# ## EDGE-weighted: ##\n# ####################\n# # i <- snps.assoc[1]\n#\n# Qi <- Q.ew[[i]]\n#\n# ## get sum of edge lengths with these subs:\n# Qi.ew <- Qi*sum(tree$edge.length[!is.na(score3[[i]])])\n# # NOTICE much heavier diagonal :)\n#\n# sum(tree$edge.length)\n# sum(tree$edge.length[!is.na(score3[[i]])])\n# sum(Qi.ew)\n#\n# ## re-weight by ROW?:\n# temp <- t(sapply(c(1:nrow(Qi.ew)),\n#                  function(e)\n#                    Qi.ew[e,]/sum(Qi.ew[e,])))\n# colnames(temp) <- rownames(temp) <- colnames(Qi.ew)\n# temp.ew <- temp\n# temp.ew\n#\n# ## all rows should sum to 1:\n# sum(temp.ew[1,])\n#\n# #############\n# ## Q.corr: ##\n# #############\n#\n# ## Q.corr (original): ##\n# Q.corr <- matrix(c(2, 0.75, 0.75, 1, 3, 0.5, 0.25,  3, 3, 0.25, 0.5, 3, 1, 0.75, 0.75, 2),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# ## re-weight by ROW?:\n# temp <- t(sapply(c(1:nrow(Q.corr)),\n#                  function(e)\n#                    Q.corr[e,]/sum(Q.corr[e,])))\n# colnames(temp) <- rownames(temp) <- colnames(Q.corr)\n# temp.corr <- temp\n# temp.corr\n#\n# ## NEW Q.corr ( --> reduced n.subs??)\n# Q <- matrix(c(0.6, 0.1, 0.1, 0.2, 0.4, 0.15, 0.05,  0.4, 0.4, 0.05, 0.15, 0.4, 0.2, 0.1, 0.1, 0.6),\n#             nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n# Q\n# Q.new1 <- Q.new\n#\n# ## 2nd NEW Q.corr ( --> reduced n.subs??)\n# Q <- matrix(c(0.7, 0.05, 0.05, 0.2, 0.45, 0.1, 0.0,  0.45, 0.45, 0.0, 0.1, 0.45, 0.2, 0.05, 0.05, 0.7),\n#             nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n# Q\n# Q.new2 <- Q.new <- Q\n#\n############################\n\n############\n## Q.inst ##\n############\n## IGNORE !!\n# Q.inst <- matrix(c(0, 0.5, 0.5, 0, 2, 0, 0,  2, 2, 0, 0, 2, 0, 0.5, 0.5, 0),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n# Q.inst\n# Q <- Q.inst\n#################################\n\n##########################\n## Q.new3 (w/ matexpo!) ##\n##########################\n## if Q contains RATES --> P contains probs\n# Q.new3 <- matrix(c(0, 0.5, 0.5, 1,\n#                    2, 0, 0.25,  2,\n#                    2, 0.25, 0, 2,\n#                    1, 0.5, 0.5, 0),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# Q.mat <- matrix(c(-1*s, 0.5*s, 0.5*s, 0,\n#                   2*s, -4*s, 0, 2*s,\n#                   2*s, 0, -4*s, 2*s,\n#                   0, 0.5*s, 0.5*s, -1*s),\n#                 nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# af <- 4\n# s <- 0.5\n# Q.mat <- matrix(c(NA, 1*s, 1*s, 0,\n#                   1*af*s, NA, 0, 1*af*s,\n#                   1*af*s, 0, NA, 1*af*s,\n#                   0, 1*s, 1*s, NA),\n#                 nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# ## GET PROBABILITY MATRIX:\n# diag(Q.mat) <- sapply(c(1:nrow(Q.mat)), function(e) -sum(Q.mat[e, c(1:ncol(Q.mat))[-e]]))\n# Q <- Q.mat\n# Q.new3 <- Q.mat\n# Q.mat\n#\n# ## get conditional probs for each edge w matexpo! ##\n# ## (run within code...)\n# x <- rev(1:nrow(tree$edge))\n# Qt <- list()\n# for(e in x){\n#   Qt[[e]] <- matexpo(Q*tree$edge.length[e])\n# }\n# e <- x[1]\n# P <- Qt[[e]]\n# rownames(P) <- rownames(Q)\n# colnames(P) <- colnames(Q)\n# P\n\n## CHECK -- Does expm (pkg \"Matrix\") give same results as matexpo?? ## (YES)\n\n##########################\n## Q.new4 (w/ matexpo!) ##\n##########################\n## if Q contains RATES --> P contains probs\n\n## ?? -- (WHY) DOES THE BL:TR DIAGONAL NEED TO BE ALL ZEROS???? ################################    ####        ####        ####    ??????????       ####\n# s <- 1\n# Q.new4 <- matrix(c(-2*s, 0.5*s, 0.5*s, 1*s,\n#                    2*s, -4.25*s, 0.25*s,  2*s,\n#                    2*s, 0.25*s, -4.25*s, 2*s,\n#                    1*s, 0.5*s, 0.5*s, -2*s),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n\n# s <- 1\n# Q.new4 <- matrix(c(-1*s, 0.5*s, 0.5*s, 0,\n#                    2*s, -4*s, 0, 2*s,\n#                    2*s, 0, -4*s, 2*s,\n#                    0, 0.5*s, 0.5*s, -1*s),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# Q.new4\n# Q <- Q.new4\n#\n# ## GET PROBABILITY MATRIX:\n# ## get conditional probs for each edge w matexpo! ##\n# ## (run within code...)\n# x <- rev(1:nrow(tree$edge))\n# Qt <- list()\n# for(e in x){\n#   Qt[[e]] <- matexpo(Q*tree$edge.length[e])\n# }\n# e <- x[2]\n# P <- Qt[[e]]\n# rownames(P) <- rownames(Q)\n# colnames(P) <- colnames(Q)\n# P\n\n\n\n\n####################\n\n#########################\n## Q.xav (w/ matexpo!) ##\n#########################\n## if Q contains RATES --> P contains probs\n\n# ## s = substitution rate\n# s <- 1\n# ## NOT SURE IF ROW/COLNAMES ARE RIGHT FOR THIS ONE:\n# Q.xav <- matrix(c(-2*s, 1*s, 1*s, 0,\n#                    2*s, -4*s, 0,  2*s,\n#                    2*s, 0, -4*s, 2*s,\n#                    0, 1*s, 1*s, -2*s),\n#                  nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n# Q <- Q.xav\n# Q.xav\n#\n# #########\n#\n# ##  NOT SURE HOW TO INTERPRET/PREDICT THE RELATIVE EFFECTS OF ASSOC.FACTOR AND N.SUBS\n# ## (ie AF, S) ON ASSOC STRENGTH AND N.SUBS PER TREE (AND HOW SUB PROBS VARY W BRANCH LENGTH)\n# ## ALSO -- (WHY) DO THE DIAGONALS NEED TO BE NEG AND 0?\n# ## (CONSIDERING WE WANT TO SIM SOME SIMULTANEOUS SUBS..)\n# ## (SEEMS LIKE THE 0-DIAGONAL HAS NO IMPACT WHETHER IT'S 0S OR OTHER VALUES?)\n#\n# af <- 6 # association factor\n# s <- 20 # n.subs\n#\n# # Q.mat <- matrix(c(NA, 1*s, 1*s, 0,\n# #                   1*af*s, NA, 0, 1*af*s,\n# #                   1*af*s, 0, NA, 1*af*s,\n# #                   0, 1*s, 1*s, NA),\n# #                 nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# Q.mat <- matrix(c(NA, 1*s, 1*s, 0,\n#                   1*af*s, NA, 0, 1*af*s,\n#                   1*af*s, 0, NA, 1*af*s,\n#                   0, 1*s, 1*s, NA),\n#                 nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n#\n# diag(Q.mat) <- sapply(c(1:nrow(Q.mat)), function(e) -sum(Q.mat[e, c(1:ncol(Q.mat))[-e]]))\n#\n# Q <- Q.mat\n# Q\n#\n#\n# ## GET PROBABILITY MATRIX:\n#\n# ## get conditional probs for each edge w matexpo! ##\n# ## (run within code...)\n# x <- rev(1:nrow(tree$edge))\n# Qt <- list()\n# for(e in x){\n#   Qt[[e]] <- matexpo(Q*tree$edge.length[e])\n# }\n# e <- x[112]\n# P <- Qt[[e]]\n# rownames(P) <- rownames(Q)\n# colnames(P) <- colnames(Q)\n# P\n\n\n#####################\n\n# ######################################################\n# ## WANT -- 15 subs/tree (thus 183 no-sub branches): ##\n# ######################################################\n# # probs.e <- round((tree$edge.length/sum(tree$edge.length)),3)\n# probs.e <- (tree$edge.length/sum(tree$edge.length))\n#\n# ## IDEA -- multiply all 3 non-stay-the-same cells of Q by above (or make it s.t. these cells are x% of the row sum)\n# ## EG -- if you would expect 1.4/15 subs to occur on edge 1\n#\n# ## --> Need to find Pr(at least one sub occurs on branch e)\n# ## bc we are/were working with sampling WITHOUT replacement w probs proportional to edge.length\n#\n# ## Pr(no sub on branch 198) =\n# (1-probs.e[198])^15 # 0.022\n# ## Therefore: Pr(at least one sub on branch 198) =\n# 1 - (1-probs.e[198])^15 # 0.98\n\n## Then -- need to re-work probs from Q s.t Pr(stay the same) = 0.02 and Pr(sub) sums to 0.98\n\n\n\n# tree <- get(load(\"/media/caitiecollins/88CC9BCECC9BB4C2/Cait 2016/Work/Xavier/Sims/set1/set1_31_tree.Rdata\"))\n\n# ## ARGS (Eg): ##\n# n.snps = 1000\n# n.subs = 1\n# snp.root = NULL\n# n.snps.assoc = 10\n# assoc.prob = 100\n# # ## dependent/corr' transition rate/prob mat:\n# # # Q = matrix(c(2, 0.75, 0.75, 1, 3, 0.5, 0.25,  3, 3, 0.25, 0.5, 3, 1, 0.75, 0.75, 2),\n# # #            nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2))\n# ### tree = coalescent.tree.sim(100)\n# phen.loci = NULL\n# n.phen.subs <- 15\n# heatmap = FALSE\n# reconstruct = FALSE\n# dist.dna.model = \"JC69\"\n# grp.min <- 0.25\n# row.names = NULL\n# set=3\n# seed=1\n\nsnp.sim.Q <- function(n.snps = 10000,\n                      n.subs = 1,\n                      snp.root = NULL,\n                      n.snps.assoc = 10,\n                      assoc.prob = 100,\n                      ## dependent/corr' transition rate/prob mat:\n                      Q = matrix(c(2, 0.75, 0.75, 1, 3, 0.5, 0.25,  3, 3, 0.25, 0.5, 3, 1, 0.75, 0.75, 2),\n                                 nrow=4, byrow=T, dimnames=rep(list(c(\"0|0\", \"0|1\", \"1|0\", \"1|1\")), 2)),\n                      tree = coalescent.tree.sim(100),\n                      n.phen.subs = 15,\n                      phen.loci = NULL,\n                      heatmap = FALSE,\n                      reconstruct = FALSE,\n                      dist.dna.model = \"JC69\",\n                      grp.min = 0.25,\n                      coaltree = TRUE,\n                      row.names = NULL,\n                      set=3,\n                      seed=1){\n\n  # require(adegenet)\n  # require(ape)\n  # require(phangorn)\n\n  ##################################\n  ## GET MUTATIONS' branch & loci ##\n  ##################################\n  n.ind <- tree$Nnode+1\n  gen.size <- n.snps\n  edges <- tree$edge\n\n  if(!is.null(seed)) set.seed(seed)\n\n  ## Simulate genotype (& phen) for root individual: ##\n\n  ## if snp.root given:\n  if(!is.null(snp.root)){\n    if(length(snp.root) == 1){\n      ## select only root state --> different SNP sim method (???)\n      if(as.character(snp.root) == \"0\") gen.root <- rep(\"0\", gen.size)\n      if(as.character(snp.root) == \"1\") gen.root <- rep(\"1\", gen.size)\n    }else{\n      ## if snp.root provided for all loci:\n      if(length(snp.root) == gen.size){\n        gen.root <- as.character(snp.root)\n      }else{\n        warning(\"snp.root should either be of length 1 or length n.snps; ignoring.\")\n      }\n    }\n  }\n\n  ## For n.subs = n or = dist approaches:\n  # gen.root <- sample(c(\"a\", \"c\", \"g\", \"t\"), gen.size, replace=TRUE)\n  gen.root <- sample(c(\"0\", \"1\"), gen.size, replace=TRUE)\n  phen.root <- sample(c(\"0\", \"1\"), 1)\n\n  ## get the sum of all branch lengths in the tree:\n  time.total <- sum(tree$edge.length)\n\n  ## make dummy variables in which to store the resulting n.mts variables:\n  L <- lambda <- n.mts <- new.nt <- NA\n\n  snps.assoc <- NULL\n\n  ## if n.snps.assoc is neither NULL nor 0:\n  if(is.null(n.snps.assoc)) n.snps.assoc <- 0\n  if(n.snps.assoc != 0){\n\n    ## get non.assoc gen.size\n    gen.size.ori <- gen.size\n    gen.size <- gen.size-n.snps.assoc\n\n    ## assign snps.assoc to be the last n.snps.assoc snps columns\n    snps.assoc <- c((gen.size+1):(gen.size+n.snps.assoc))\n  }\n\n  ###################\n  ## Handle n.subs ##\n  ###################\n\n  ## Either an integer\n  ## --> draw n.subs from a Poisson distribution w parameter n.subs\n  ## OR a vector (containing a distribution)\n  ## --> use this distribution to define n.subs-per-site\n\n  if(length(n.subs)==1){\n\n    #####################\n    ## NO DISTRIBUTION ##\n    #####################\n\n    ## if no distribution is inputted,\n    ## use normal simulation procedure\n    ## (ie. Poisson parameter 1):\n\n    ## draw the number of mutations to occur at each site:\n    n.mts <- rpois(n=gen.size, lambda=(n.subs))\n    ## for any n.mts==0, re-sample\n    for(i in 1:length(n.mts)){\n      while(n.mts[i]==0){\n        n.mts[i] <- rpois(n=1, lambda=(n.subs))\n      }\n    }\n\n  }else{\n\n    ###############################################\n    ## DISTRIBUTION or RATES (fitPagel Q matrix) ##\n    ###############################################\n\n    ##################\n    ## DISTRIBUTION ##\n    ##################\n\n    ## if a distribution is provided by the user,\n    ## we use this to determine the number of substitutions\n    ## to occur at what proportion of sites (note that\n    ## we may not be simulating the same number of sites)\n\n    dist <- n.subs\n\n    ## get dist.prop, a distribution containing the counts\n    ## of the number of SNPs to be simulated that will have\n    ## i many substitutions\n    dist.sum <- sum(dist)\n    dist.prop <- round((dist/dist.sum)*gen.size)\n    ## check that these counts sum to gen.size,\n    ## else add the remainder to the largest n.subs count\n    ## (OR should we just add these to the n.subs=1 set ??? ###\n    ## likely to be the same thing, but could not be...)\n    if(sum(dist.prop) != gen.size){\n      m <- which.max(dist.prop)\n      #m <- 1\n      if(sum(dist.prop) < gen.size){\n        dist.prop[m] <- dist.prop[m] + (gen.size - sum(dist.prop))\n      }\n      if(sum(dist.prop) > gen.size){\n        dist.prop[m] <- dist.prop[m] - (sum(dist.prop) - gen.size)\n      }\n    }\n\n    ## get rid of useless trailing 0s\n    while(dist.prop[length(dist.prop)] == 0){\n      dist.prop <- dist.prop[c(1:(length(dist.prop)-1))]\n    }\n\n    ## make n.mts, a vector of length ncol(snps)\n    n.mts <- rep(1111, gen.size)\n    loci.available <- c(1:gen.size)\n    ## assign dist.prop[i] elements of n.mts\n    ## to be the same as the n.subs\n    ## indicated by i, the given element of dist.prop\n    for(j in 1:length(dist.prop)){\n      ## provided there are not 0 sites to have this number of substitutions...\n      if(dist.prop[j] > 0){\n        if(length(loci.available) > 1){\n          ## assign dist.prop[i] elements of n.mts to be i\n          loci.selected <- sample(loci.available, dist.prop[j], replace = FALSE)\n          loci.available <- loci.available[-which(loci.available %in% loci.selected)]\n        }else{\n          ## if there is only 1 (the last) loci available,\n          ## we select this one:\n          loci.selected <- loci.available\n        }\n        n.mts[loci.selected] <- j\n      }\n    }\n    # } # end dist\n  } # end fitPagel or dist\n\n  ############################\n  ## Assign mts to branches ##\n  ############################\n\n  if(n.snps.assoc != 0){\n    ## for snps.assoc (the last n.snps.assoc snps, for now),\n    ## add n.mts == n.phen.loci s.t these sites mutate at each\n    ## and every phen.loci (for now, to be diluted later\n    ## according to assoc.prob if !=100)\n    n.mts <- c(n.mts, rep(length(phen.loci), n.snps.assoc))\n  }\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n  #############################################################################\n  ## GENERATE ALL SNPs FIRST, THEN REPLACE ANY NON-POLYMORPHIC IN WHILE LOOP ##\n  #############################################################################\n\n  #############################\n  ## GET NON-ASSOCIATED SNPS ##\n  #############################\n\n  ## for each site, draw the branches to which\n  ## you will assign the mts for this site\n  ## (~ branch length):\n\n  ## Get vector of FALSEs of length tree$edge.length:\n  null.vect <- rep(FALSE, length(tree$edge.length))\n\n  snps.loci <- sapply(c(1:length(n.mts)),\n                      function(e)\n                        replace(null.vect,\n                                sample(c(1:length(tree$edge.length)),\n                                       n.mts[e],\n                                       replace=FALSE,\n                                       prob=tree$edge.length), TRUE))\n\n  ## rearrange snps.loci s.t it becomes a\n  ## list of length tree$edge.length,\n  ## each element of which contains the\n  ## locations of the mutations that will\n  ## occur on that branch\n  snps.loci <- sapply(c(1:nrow(snps.loci)),\n                      function(e) which(snps.loci[e,] == TRUE))\n\n\n  ## get the node names for all individuals (terminal and internal)\n  all.inds <- sort(unique(as.vector(unlist(tree$edge))))\n  # we will store the output in a list called genomes:\n  genomes <- list()\n  ## we start w all inds having same genotype as root:\n  for(i in all.inds){\n    genomes[[all.inds[i]]] <- gen.root\n  }\n  ## store replacement nts in list new.nts:\n  new.nts <- list()\n  ## distinguish btw list of loci and unique list\n  snps.loci.ori <- snps.loci\n  ## will need to treat repeat loci differently...\n  snps.loci.unique <- lapply(snps.loci, unique)\n  ## the last individual in the first column of tree$edge\n  ## (ie. ind.length(tree$tip.label)+1 ) is our root individual:\n  x <- rev(c(1:nrow(tree$edge)))\n\n  if(coaltree == FALSE){\n    ## use normal/reverse (top:bottom) edge mat:\n    x <- 1:nrow(tree$edge)\n  }\n\n  #############################\n  ## For Loop to get new nts ##\n  #############################\n  for(i in x){\n    ## for all genomes other than root, we mutate the\n    ## genome of the node preceding it, according to snps.loci.\n    ## Draw new nts for each locus selected for mutation:\n    if(!.is.integer0(snps.loci.unique[[i]])){\n      new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)\n        selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                             %in% genomes[[tree$edge[i,1]]]\n                                             [snps.loci.unique[[i]][e]])]))\n      ## if any loci are selected for multiple mutations\n      ## within their given branch length:\n      if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){\n        ## identify which loci are repeaters\n        repeats <- table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]\n        ## how many times they repeat\n        n.reps <- repeats - 1\n        ## the positions of these loci in the vector of snps loci\n        toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))\n        ## run chain of re-sampling to end in our new nt for repeater loci:\n        foo <- list()\n        for(j in 1:length(toRepeat)){\n          foo[[j]] <- new.nts[[i]][toRepeat[j]]\n          for(k in 1:n.reps[j]){\n            if(k==1){\n              foo[[j]][k] <- selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                                                  %in% foo[[j]][1])])\n\n            }else{\n              foo[[j]][k] <- selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                                                  %in% foo[[j]][k-1])])\n            }\n          }\n          ## retain only the last nt selected\n          out <- sapply(c(1:length(foo)),\n                        function(e) foo[[e]][length(foo[[e]])])\n        }\n        ## for the loci with repeated mts, replace these positions\n        ## in new.nts with the corresponding elements of out, above.\n        new.nts[[i]][toRepeat] <- out\n      } # end of if statement for repeaters\n\n      ## update ancestral genotype with new.nts:\n      temp <- genomes[[tree$edge[i,1]]]\n      temp[snps.loci.unique[[i]]] <- new.nts[[i]]\n      genomes[[tree$edge[i,2]]] <- temp\n\n    }else{\n      ## if no mts occur on branch, set genotype of\n      ## downstream individual to be equal to ancestor's\n      genomes[[tree$edge[i,2]]] <- genomes[[tree$edge[i,1]]]\n    }\n  } # end of for loop selecting new nts at mutator loci\n\n  ####################################################\n  ## CHECK IF ALL LOCI ARE POLYMORPHIC (|polyThres) ##\n  ####################################################\n\n  ## temporarily assemble non-associated loci into matrix:\n  temp.ori <- do.call(\"rbind\", genomes)\n\n  ## keep only rows containing terminal individuals:\n  temp.ori <- temp.ori[1:n.ind, ]\n\n  #########################\n  ## Get UNIQUE snps.rec ##\n  #########################\n  temp <- get.unique.matrix(temp.ori, MARGIN=2)\n  temp.unique <- temp$unique.data\n  index <- temp$index\n\n  if(ncol(temp.unique) == ncol(temp.ori)){\n    all.unique <- TRUE\n  }else{\n    all.unique <- FALSE\n  }\n\n  ## work w only unique snps:\n  temp <- temp.unique\n\n  #   ## Make loci list (in case you need it later (ie. if any loci not polymorphic))\n  #   loci <- list()\n  #   for(i in 1:ncol(temp)){\n  #     loci[[i]] <- temp[,i]\n  #   }\n\n  ## identify n.minor.allele required to meet polyThres:\n  polyThres <- 0.01\n  n.min <- n.ind*polyThres\n\n  ## make a list of any NON-polymorphic loci:\n  toRepeat <- list()\n  for(i in 1:ncol(temp)){\n    if(any(table(temp[,i]) < n.min) | length(table(temp[,i])) == 1){\n      toRepeat[[length(toRepeat)+1]] <- i\n    }\n  }\n  if(length(toRepeat) > 0){\n    toRepeat <- as.vector(unlist(toRepeat))\n  }\n\n\n  gc()\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n  #################################################################\n  ## REPLACE ANY NON-POLYMORPHIC LOCI & GENERATE ASSOCIATED SNPS ##\n  #################################################################\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n\n\n  #################################################\n  ## REPLACE NON-POLYMORPHIC NON-ASSOCIATED SNPS ##\n  #################################################\n\n  # toRepeat <- 1:length(n.mts)\n  # loci <- list()\n\n  ######################################\n  ## while loop STARTS here: ###########\n  ######################################\n  ## AGAIN--NEED TO DOUBLE CHECK: No problems with seed? #############\n\n  # counter <- 0\n  while(length(toRepeat) > 0){\n\n    for(i in toRepeat){\n      ## get the lth element of n.mts to work with:\n      n.mt <- n.mts[i]\n\n      ## for each site, draw the branches to which\n      ## you will assign the mts for this site\n      ## (~ branch length):\n\n      subs.edges <- sample(c(1:length(tree$edge.length)),\n                           n.mt,\n                           replace=FALSE,\n                           prob=tree$edge.length)\n\n      ## TO DO: COULD REPLACE (all instances!!!) LATER WITH:\n      ## Get vector of FALSEs of length tree$edge.length:\n      #     null.vect <- rep(FALSE, length(tree$edge.length))\n      #     subs.edges <- replace(null.vect,\n      #                           sample(c(1:length(tree$edge.length)),\n      #                                  n.mt,\n      #                                  replace=FALSE,\n      #                                  prob=tree$edge.length), TRUE)\n\n\n      ## get nt for root at this locus:\n      root.nt <- gen.root[i]\n\n      ## get nt for each individual at this locus\n      temp[,i] <- .get.locus01(subs.edges = subs.edges,\n                               root.nt = root.nt,\n                               tree = tree,\n                               coaltree = coaltree)[1:n.ind]\n\n    } # end FOR LOOP for NON-associated SNPs\n\n    ######################################\n    ##### while loop CHECK here: #########\n    ######################################\n    ## CHECK IF ALL LOCI ARE POLYMORPHIC (|polyThres)\n\n    ## identify n.minor.allele required to meet polyThres:\n    polyThres <- 0.01\n    n.min <- n.ind*polyThres\n\n    ## make a list of any NON-polymorphic loci:\n    toRepeat.ori <- toRepeat\n    temp.toRepeat <- temp[, toRepeat.ori]\n\n    toRepeat <- list()\n    ## if temp.toRepeat is a true matrix:\n    if(!is.matrix(temp.toRepeat)){\n      if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){\n        toRepeat[[length(toRepeat)+1]] <- toRepeat.ori\n      }\n    }else{\n    if(ncol(temp.toRepeat) > 0){\n      for(i in 1:ncol(temp.toRepeat)){\n        if(any(table(temp.toRepeat[,i]) < n.min) | length(table(temp.toRepeat[,i])) == 1){\n          toRepeat[[length(toRepeat)+1]] <- toRepeat.ori[i]\n        }\n      }\n    }else{\n      if(any(table(temp.toRepeat) < n.min) | length(table(temp.toRepeat)) == 1){\n        toRepeat[[length(toRepeat)+1]] <- toRepeat.ori\n      }\n    }\n    }\n    if(length(toRepeat) > 0){\n      toRepeat <- as.vector(unlist(toRepeat))\n    }\n\n    # counter <- counter+1\n    # print(\"COUNTER\"); print(counter)\n\n  } # end of while loop\n  ######################################\n  ## while loop ENDS here: #############\n  ######################################\n\n\n  ## GET ALL NON-UNIQUE SNPS COLUMNS: ##\n\n  if(all.unique == TRUE){\n    temp.complete <- temp\n  }else{\n    temp.complete <- temp[, index]\n  }\n\n  colnames(temp.complete) <- colnames(temp.ori)\n  temp <- temp.complete\n\n\n\n\n\n  #########################\n  ## GET ASSOCIATED SNPS ##\n  #########################\n\n  ## Need to treat ASSOCIATED SNPs differently:\n  ## (non.assoc.snps do NOT need to pass the \"while\" check;\n  ## they just need to match phen.loci at this point.)\n\n  snps.assoc.nodes <- phen.nodes <- NULL\n\n  if(n.snps.assoc != 0){\n\n    snps.assoc.nodes <- list()\n    N.OVERLAP <- list()\n\n    Qt <- list()\n\n    ## get snps.loci for FIRST ASSSOCIATED snp WITH PHEN.loci:\n    i <- 1\n\n    edges <- tree$edge\n\n    x <- rev(c(1:nrow(edges)))\n\n    if(coaltree == FALSE){\n      ## use normal/reverse (top:bottom) edge mat:\n      x <- 1:nrow(edges)\n    }\n\n    root.nt <- gen.root[snps.assoc[i]]\n\n\n    ## Need to update tree$edge.length probs to mirror sampling without replacement...\n    ## BUT only remove branches from the calculation once they have had a sub on them...?\n    N.SUBS.TOTAL <- 15\n    # N.SUBS.TOTAL <- rpois(1, n.phen.subs)  ############\n\n    ################\n    ## WHILE LOOP ##\n    ################\n    toRepeat <- TRUE\n    ## WHILE LOOP STARTS HERE:\n    while(toRepeat){ ############################\n\n      snp.node <- phen.node <- as.list(rep(NA, length(unique(as.vector(edges)))))\n\n      snp.node[[edges[x[1], 1]]] <- root.nt\n      phen.node[[edges[x[1], 1]]] <- phen.root\n\n      # probs.e <- round((tree$edge.length/sum(tree$edge.length)),3)\n      # probs.e <- (tree$edge.length/sum(tree$edge.length))\n      probs.e <- NULL\n\n      N.SUBS.COUNTER <- 0\n\n      ##################\n      ## FOR (e) LOOP ##\n      ##################\n      ## go from last to first edge in edges:\n      for(e in x){\n\n        # print(\"E\"); print(e)\n\n        probs <- NULL\n        toKeep <- toSub <- NULL\n\n        ######################################################\n        ## WANT -- 15 subs/tree (thus 183 no-sub branches): ##\n        ######################################################\n        ## IDEA -- multiply all 3 non-stay-the-same cells of Q by above (or make it s.t. these cells are x% of the row sum)\n        ## EG -- if you would expect 1.4/15 subs to occur on edge 1\n\n        ## --> Need to find Pr(at least one sub occurs on branch e)\n        ## bc we are/were working with sampling WITHOUT replacement w probs proportional to edge.length\n\n        ## Pr(no sub on branch 198) =\n        # (1-probs.e[e])^15 # 0.022\n        ## Therefore: Pr(at least one sub on branch 198) =\n\n        # Pr.sub <- 1 - ((1-probs.e[e])^N.SUBS.TOTAL) # 0.98\n        # print(paste(\"Edge\", e, \"Pr.sub\", Pr.sub, sep=\" \"))\n\n        #         if(probs.e[e] < sum(tree$edge.length)/5000){\n        #           Pr.sub <- 0.1\n        #         }else{\n        #           Pr.sub <- NULL\n        #         }\n\n        #         if(N.SUBS.COUNTER == N.SUBS.TOTAL){\n        #           Pr.sub <- 0\n        #         }else{\n        #           Pr.sub <- NULL\n        #         }\n\n        # Pr.sub <- NULL\n\n        ## UNLESS -- N.SUBS.TOTAL has been reached...\n        ## in which case, we stay the same by force:\n        # if(N.SUBS.COUNTER == N.SUBS.TOTAL) Pr.sub <- 0\n\n        ## Then -- need to re-work probs from Q s.t Pr(stay the same) = 0.02 and Pr(sub) sums to 0.98\n\n        ## REMOVED COMMENTED-OUT ALTERNATIVE CODE (may be required if any other commented-out bits are revived...)\n        ## TO RECOVER: SEE GIT COMMIT ON ## 2016-09-02 ##\n\n        ## get conditional probs for each edge w matexpo! ##\n        ## (run within code...)\n        Qt[[e]] <- matexpo(Q*tree$edge.length[e])\n\n        P <- Qt[[e]]\n        rownames(P) <- rownames(Qt[[e]]) <- rownames(Q)\n        colnames(P) <- colnames(Qt[[e]]) <- colnames(Q)\n\n        ##############################\n        ## SNP.anc = 0 Phen.anc = 0 ##\n        ##############################\n        if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"0\"){\n          probs <- P[1,]\n        }\n        ##############################\n        ## SNP.anc = 0 Phen.anc = 1 ##\n        ##############################\n        if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"1\"){\n          probs <- P[2,]\n        }\n        ##############################\n        ## SNP.anc = 1 Phen.anc = 0 ##\n        ##############################\n        if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"0\"){\n          probs <- P[3,]\n        }\n        ##############################\n        ## SNP.anc = 1 Phen.anc = 1 ##\n        ##############################\n        if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"1\"){\n          probs <- P[4,]\n        }\n\n        SP.dec <- sample(colnames(Q), 1, prob = probs)\n\n        S.dec <- keepFirstN(SP.dec, 1)\n        P.dec <- keepLastN(SP.dec, 1)\n        names(S.dec) <- names(P.dec) <- NULL\n\n        snp.node[[edges[e, 2]]] <- S.dec\n        phen.node[[edges[e, 2]]] <- P.dec\n\n        ## Did a PHEN sub occur?\n        phen.sub <- FALSE\n        if(phen.node[[edges[e, 1]]] != phen.node[[edges[e, 2]]]) phen.sub <- TRUE\n        # SP.dec %in% colnames(Q)[toSub] ## Did EITHER a phen sub AND/OR a snps sub occur?\n\n        # print(\"EDGE\"); print(e)\n        ## If a sub has occurred on branch e, add it to the n.subs counter\n        if(phen.sub){\n          N.SUBS.COUNTER <- N.SUBS.COUNTER+1\n          # print(\"TRUE\")\n        }\n        # print(\"N.SUBS.COUNTER\"); print(N.SUBS.COUNTER)\n\n        ## Update/reduce edge length probs set...\n        ## (until we reach N.SUBS.TOTAL, then stop reducing edge.length probs):\n        #         if(N.SUBS.COUNTER < N.SUBS.TOTAL){\n        #           ## if on last edge, make prob sub = 1\n        #           if(e == 1){\n        #             probs.e <- 1\n        #           }else{\n        #             ## else, reduce probs to be weights of remaining edges:\n        #             probs.e <- probs.e[1:(e-1)]/sum(probs.e[1:(e-1)])\n        #           }\n        #         }\n\n      } # end for (e) loop\n\n\n      ## STORE FIRST SNPS.ASSOC:\n      snps.assoc.nodes[[i]] <- as.vector(unlist(snp.node))\n\n      ## STORE PHEN (FOR ALL NODES):\n      phen.nodes <- as.vector(unlist(phen.node))\n      names(phen.nodes) <- c(1:length(phen.nodes))\n\n      phen <- phen.nodes[1:n.ind]\n\n      # ## TEMP -- CHECK w PLOT:\n      # plot.phen(tree, phen.nodes=phen.nodes, snp.nodes=snps.assoc.nodes[[i]])\n      # cor(as.numeric(phen.nodes[1:n.ind]), as.numeric(snps.assoc.nodes[[i]][1:n.ind]))\n      N.overlap <- length(which(phen.nodes[1:n.ind] == snps.assoc.nodes[[i]][1:n.ind]))\n      N.overlap <- max(N.overlap, (n.ind-N.overlap))\n      N.OVERLAP[[i]] <- N.overlap\n      #######################################################################\n\n\n      ## CHECK THAT MIN GRP.SIZE >= THRESHOLD ##\n      if(!is.null(grp.min)){\n        tab <- table(phen)\n        grp.thresh <- (tree$Nnode+1)*grp.min\n        if(min(tab) < grp.thresh){\n          toRepeat <- TRUE\n        }else{\n          toRepeat <- FALSE\n        }\n      }else{\n        toRepeat <- FALSE\n      }\n\n    } # end WHILE LOOP #########\n\n    print(\"N.SUBS.COUNTER\"); print(N.SUBS.COUNTER)\n    print(\"N.overlap\"); print(N.overlap[[i]])\n\n    ### TEMP -- CHECK:\n    # phen.node.ori <- phen.node\n    # phen.rec <- as.vector(unlist(phen.node))\n    # snp.rec <- as.vector(unlist(snps.assoc.nodes[[3]]))\n    # plot.phen(tree, phen.nodes=phen.rec, snp.nodes=snp.rec)\n    # title(\"set3_1 phen vs. snps.assoc3\", line=0)\n    #\n    # cor(as.numeric(snp.rec[1:n.ind]), as.numeric(phen.rec[1:n.ind])) # 0.46 0.63 0.48\n    # length(which(as.numeric(snp.rec[1:n.ind]) == as.numeric(phen.rec[1:n.ind])))/n.ind # 0.74 0.81 0.75\n    ######\n\n    ## get snps.loci for the REMAINING ASSOCIATED snps (ie. 2:n.assoc, conditional on phen) ##\n    for(i in 2:n.snps.assoc){\n      ## get nt for root at this locus:\n      root.nt <- gen.root[snps.assoc[i]]\n\n      snp.node <- as.list(rep(NA, length(unique(as.vector(edges)))))\n\n      snp.node[[edges[x[1], 1]]] <- root.nt\n\n      ## go from last to first edge in edges:\n      for(e in x){\n\n        probs <- NULL\n        # if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"0\") probs <- Q[1,]\n        # if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"1\") probs <- Q[2,]\n        # if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"0\") probs <- Q[3,]\n        # if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"1\") probs <- Q[4,]\n\n        P <- Qt[[e]]\n\n        if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"0\") probs <- P[1,]\n        if(snp.node[[edges[e, 1]]] == \"0\" & phen.node[[edges[e, 1]]] == \"1\") probs <- P[2,]\n        if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"0\") probs <- P[3,]\n        if(snp.node[[edges[e, 1]]] == \"1\" & phen.node[[edges[e, 1]]] == \"1\") probs <- P[4,]\n\n        ## Now we KNOW, A PRIORI, the phen.node for the DESCENDANT!\n        probs.mod <- replace(probs, which(!keepLastN(colnames(Q), 1) == phen.node[[edges[e, 2]]]), 0)\n        SP.dec <- sample(colnames(Q), 1, prob = probs.mod)\n\n        S.dec <- keepFirstN(SP.dec, 1)\n        names(S.dec) <- NULL\n\n        snp.node[[edges[e, 2]]] <- S.dec\n\n      } # end for (e) loop\n\n      ## STORE SNPS.ASSOC (FOR ALL NODES):\n      snps.assoc.nodes[[i]] <- as.vector(unlist(snp.node))\n\n      ## Get proportion overlap btw phen and snps.assoc.i:\n      N.overlap <- length(which(phen.nodes[1:n.ind] == snps.assoc.nodes[[i]][1:n.ind]))\n      N.overlap <- max(N.overlap, (n.ind-N.overlap))\n      N.OVERLAP[[i]] <- N.overlap\n\n    } # end for loop\n\n    ## Bind SNPs.ASSOC into matrix:\n    snps.assoc.nodes <- do.call(\"cbind\", snps.assoc.nodes)\n\n\n    ###################################################\n    ## TEMP -- COMPARE PHEN & ALL SNPS.ASSOC w PLOT: ##\n    ###################################################\n    par(mfrow=c(2,6))\n    plot.phen(tree, phen.nodes=phen.nodes, main.title=\"phen\")\n    for(i in 1:5){\n      plot.phen(tree, phen.nodes=snps.assoc.nodes[,i], RTL = TRUE,\n                main.title=paste(\"snp.assoc\", i, sep=\" \"))\n      title(N.OVERLAP[[i]], line=0, font.main=1)\n    }\n    plot.phen(tree, phen.nodes=phen.nodes, main.title=\"phen\")\n    for(i in 6:10){\n      plot.phen(tree, phen.nodes=snps.assoc.nodes[,i], RTL = TRUE,\n                main.title=paste(\"snp.assoc\", i, sep=\" \"))\n      title(N.OVERLAP[[i]], line=0, font.main=1)\n    }\n\n\n    par(mfrow=c(1,1)) # end temp panel plot\n\n    gc()\n\n  } # end of snps.assoc generation\n\n\n\n\n  ############\n  ## IDEAS: ##   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n  ############\n\n  ## (? -- Do we need to double check all snps.assoc are polymorphic?? --> If not, would prob have to/ want to re-run from snps.assoc[1]... )\n  ## Use Q method (w Q.uncorr (all rates equal, or maintained > change state)) to simulate remainder of (ie non-assoc) snps?? (check comp time diff first..)\n  ## Tweak Q.corr to be used for sets 1 and 2 as well??\n\n  ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n  ##############################################  ## OLD METHOD ##\n  # if(n.snps.assoc != 0){\n  #   ## get snps.loci for the ASSOCIATED snps (ie. set to phen.loci) ##\n  #   for(i in 1:n.snps.assoc){\n  #     ## recall: phen.loci contains the tree EDGES on which phen subs occur\n  #     subs.edges <- phen.loci\n  #\n  #     ## get nt for root at this locus:\n  #     root.nt <- gen.root[snps.assoc[i]]\n  #\n  #     ## get nt for each individual at this locus\n  #     ## assign to (and replace) the snps.assoc elements of loci\n  #     loci[[snps.assoc[i]]] <- .get.locus01(subs.edges = subs.edges,\n  #                                         root.nt = root.nt,\n  #                                         tree = tree,\n  #                                         coaltree = coaltree)\n  #\n  #   } # end for loop\n  # } # end of snps.assoc generation\n  ############################################## ## END OLD METHOD ##\n\n\n  ###########################################\n  ## GET COMPLETE SNPS MATRIX (\"genomes\"): ##\n  ###########################################\n\n  ## Create genomes matrix:\n  genomes <- temp\n\n  ## Attach snps.assoc loci to last column:\n  if(!is.null(snps.assoc.nodes)){\n    genomes <- cbind(genomes[,c(1:(ncol(genomes)-(n.snps.assoc)))], snps.assoc.nodes[1:n.ind,])\n  }\n\n\n  ## keep only rows containing terminal individuals:\n  genomes <- genomes[1:n.ind, ]\n\n  ####   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ####\n\n\n  ###############################################\n  ## MODIFY SNPS.ASSOC ACCORDING TO ASSOC.PROB ##\n  ###############################################\n\n  # if(n.snps.assoc != 0){\n  #   ## if we have any imperfect associations... ##\n  #   if(any(assoc.prob != 100)){\n  #     ## check length\n  #     if(length(assoc.prob) != n.snps.assoc){\n  #       ## if only 1 prob value given...\n  #       if(length(assoc.prob) == 1){\n  #         ## ... assume uniform assoc.prob;\n  #         assoc.prob <- rep(assoc.prob, n.snps.assoc)\n  #         ## no warning needed\n  #       }else{\n  #         ## BUT if assoc.prob of random length:\n  #         ## repeat until of length n.snps.assoc\n  #         assoc.prob <- rep(assoc.prob, length.out=n.snps.assoc)\n  #         ## and print warning (only if not of length n.snps.assoc OR 1)\n  #         warning(\"assoc.prob not of length n.snps.assoc;\n  #                 sequence will be repeated until correct length is reached.\")\n  #       }\n  #       } # end checks\n  #\n  #     ## for each associated SNP,\n  #     ## we undo some associations | assoc.prob for that snp.assoc\n  #     for(i in 1:n.snps.assoc){\n  #\n  #       ## re-pseudo-randomise seed:\n  #       if(!is.null(seed)){\n  #         seed.i <- seed*i*10\n  #         set.seed(seed.i)\n  #       }\n  #\n  #       prob <- assoc.prob[i]\n  #       ## only if the association is imperfect\n  #       if(prob != 100){\n  #         ## draw genomes to change at snps.assoc[i]\n  #         n.toChange <- round(nrow(genomes)*(1 - (prob/100)))\n  #         toChange <- sample(c(1:nrow(genomes)), n.toChange)\n  #\n  #         ## change those genomes at rows toChange, loci snps.assoc[i]\n  #         for(j in 1:length(toChange)){\n  #           genomes[toChange[j], snps.assoc[i]] <-\n  #             selectBiallelicSNP(genomes[toChange[j], snps.assoc[i]])\n  #         } # end for loop\n  #       }\n  #     } # end for loop\n  #     } # end any assoc.prob != 100\n  # } # end modification | assoc.prob\n\n\n  ##############################\n  ## PLOTS & TREECONSTRUCTION ##\n  ##############################\n  if(heatmap == TRUE || reconstruct!=FALSE){\n    if(set == 3){\n      warning(\"Tree reconstruction and heatmap are not available for set3-type simulations.\n              (Because they are simulated directly as binary data, as.DNAbin cannot be used\n              as it would be within other simulations.)\")\n    }\n    }else{\n      if(heatmap == TRUE || reconstruct!=FALSE){\n        dna <- as.DNAbin(genomes)\n        rownames(dna) <- c(1:nrow(genomes))\n      }\n\n      #############\n      ## HEATMAP ##\n      #############\n      if(heatmap==TRUE){\n        heatmap.DNAbin(dna=dna,\n                       dist.dna.model=dist.dna.model)\n      }\n\n      ##########################################\n      ## PLOT 2: RECONSTRUCTING THE PHYLOGENY ##\n      ##########################################\n      tree.reconstructed <- NULL\n      if(reconstruct!=FALSE){\n        if(reconstruct==TRUE){\n          warning(\"reconstruct should be one of 'UPGMA', 'nj', 'ml'. Choosing 'UPGMA'.\")\n        }\n\n        tree.reconstructed <- tree.reconstruct(dna[1:n.ind,],\n                                               method=reconstruct,\n                                               dist.dna.model=dist.dna.model,\n                                               plot=TRUE)\n      }\n    }\n\n  ##################\n  ## CONVERT SNPS ##\n  ##################\n\n  ## Convert from nts in genomes (for all nodes) to binary SNPs (for terminal nodes only):\n\n  ## Keep only rows containing terminal individuals?:\n  ## (NOTE -- Consider moving this to AFTER snps.assoc assoc.prob section!)\n  # genomes <- genomes[1:n.ind, ]\n\n  ## working with snps in matrix form\n  snps.ori <- genomes\n  snps <- matrix(as.numeric(snps.ori), nrow=nrow(snps.ori), ncol=ncol(snps.ori))\n\n  ## NO LONGER NEED THIS SECTION? ##\n  gen.size <- ncol(snps)\n\n  ## assign snps row and column names:\n  colnames(snps) <- 1:ncol(snps)\n  rownames(snps) <- 1:nrow(snps)\n\n  if(set == 3){\n    ## keep snps.assoc as matrix:\n    snps.assoc <- snps[, (ncol(snps)-n.snps.assoc+1):ncol(snps)]\n  }\n\n\n  if(!is.null(snps.assoc)){\n\n    ## NO LONGER NEED THIS CHECK FOR POLYMORPH HERE:\n    ## identify any columns of snps.bin that\n    ## do NOT meet DNAbin2genind polyThres\n    ## /are NOT SNPs\n    #     x <- snps.bin\n    #     if(is.list(x)) x <- as.matrix(x)\n    #     if(is.null(colnames(x))) colnames(x) <- 1:ncol(x)\n    #\n    #     temp <- lapply(1:ncol(x), function(i)\n    #       .getFixed(x[,i], i)) # process all loci, return a list\n    #     fixed.loci <- which(temp==TRUE) ## identify loci that are NOT SNPs\n\n    ## update snps.assoc to reflect true loci\n    gen.size.final <- ncol(snps)\n    snps.assoc.loci.ori <- c((gen.size.final-(n.snps.assoc-1)):gen.size.final)\n\n    #########################################\n    ## RANDOMIZE SNPS.ASSOC LOCI POSITIONS ##\n    #########################################\n\n    ## Re-enabled snps.assoc loci \"randomization\" by\n    ## just drawing indices and shuffling the columns accordingly...\n    ## draw which SNPs will be associated to the phenotype\n    snps.assoc.loci <- sort(sample(c(1:gen.size.final),\n                                   n.snps.assoc,\n                                   replace=FALSE))\n\n    snps.indices <- c(1:gen.size.final)\n    snps.ori <- snps\n\n    snps.non.assoc <- snps[,c(1:(gen.size.final-n.snps.assoc))]\n    snps.assoc <- snps[,snps.assoc.loci.ori]\n    snps.new <- matrix(99, nrow=nrow(snps), ncol=gen.size.final)\n    snps.new[,snps.indices[-snps.assoc.loci]] <- snps.non.assoc\n    snps.new[,snps.assoc.loci] <- snps.assoc\n    snps <- snps.new\n    snps.assoc <- snps.assoc.loci\n\n  } # end snps.assoc randomization\n\n  ###############################\n  ## Assign row & column names ##\n  ###############################\n\n  ## assign/generate row.names\n  if(!is.null(row.names)){\n    if(length(row.names) == nrow(snps)){\n      rownames(snps) <- row.names\n    }else{\n      if(is.null(rownames(snps))) rownames(snps) <- c(1:nrow(snps))\n    }\n  }else{\n    if(is.null(rownames(snps))) rownames(snps) <- c(1:nrow(snps))\n  }\n\n  ## generate column names:\n  colnames(snps) <- 1:ncol(snps)\n\n\n  #################################################\n  ## SIM SET 2 (complementary clade-wise assoc): ##\n  #################################################\n  sets <- NULL\n  if(!is.null(snps.assoc)){\n    if(!is.null(set)){\n      if(set == 2){\n\n        ## Want to divide tree into 2 sets of clades btw 1/3:2/3 and 1/2:1/2\n        clades <- tab <- grp.options <- sets.complete <- list()\n\n        min.size <- ceiling((tree$Nnode+1)*(1/3))\n        max.size <- floor((tree$Nnode+1)*(2/3))\n        grp1 <- tree$Nnode+1\n\n        ## get 2 sets of clades:\n\n        ##############\n        ## coaltree ##\n        ##############\n\n        if(coaltree == TRUE){\n          ## Get tree as hclust tree:\n          tree.hc <- as.hclust.phylo(tree)\n\n          i <- 2\n          counter <- 0\n          #######################################\n          ## WHILE LOOP to get size of clades: ##\n          #######################################\n          while(grp1 < min.size | grp1 > max.size){\n            clades[[i]] <- cutree(tree.hc, k=i)\n            tab[[i]] <- table(clades[[i]])\n            # grp.opts <- grp.options[[i]] <- sapply(c(1:(i-1)), function(e) sum(tab[[i]][1:e]))\n            grp.opts <- grp.options[[i]] <- sapply(c(1:(i)), function(e) sum(tab[[i]][1:e]))\n            ## make grp1 first clade in grp.options:\n            group1 <- grp.opts[1]\n            ## remove first clade from options:\n            grp.opts <- grp.opts[-1]\n            ## and record n.grps:\n            n.grp <- 1\n            ## try to identify a (set of) clade(s) that's big enough (but not too big):\n            while(group1 < min.size){\n              group1 <- sum(group1, grp.opts[1])\n              grp.opts <- grp.opts[-1]\n              n.grp <- n.grp+1\n            }\n            sets.complete[[i]] <- replace(clades[[i]], which(clades[[i]] %in% (1:n.grp)), 1)\n            sets.complete[[i]] <- replace(sets.complete[[i]], which(!clades[[i]] %in% (1:n.grp)), 2)\n            grp1 <- sum(grp.options[[i]][1:n.grp])\n            k <- i\n            i <- i+1\n            counter <- counter+1\n          } # end while loop\n          ###########\n\n          sets <- sets.complete[[length(sets.complete)]]\n\n          ###########\n\n        }else{\n          ###########\n          ## rtree ##\n          ###########\n          dec <- grp <- sets.temp <- sets.complete <- list()\n\n          inds <- c(1:(tree$Nnode+1))\n          new.root <- tree$edge[1,1] # initial root\n\n          counter <- 0\n          #######################################\n          ## WHILE LOOP to get size of clades: ##\n          #######################################\n          while(grp1 < min.size | grp1 > max.size){\n\n            ## get all descendants of root node:\n            all.dec <- .getDescendants(tree, node=new.root)\n\n            ## get all descendants in first 2 major clades:\n            dec[[1]] <- .getDescendants(tree, node=all.dec[1])\n            dec[[2]] <- .getDescendants(tree, node=all.dec[2])\n\n            ## get terminal inds only:\n            sets.temp[[1]] <- dec[[1]][which(dec[[1]] %in% inds)]\n            sets.temp[[2]] <- dec[[2]][which(dec[[2]] %in% inds)]\n\n            grp[[1]] <- length(sets.temp[[1]])\n            grp[[2]] <- length(sets.temp[[2]])\n\n            max.grp <- which.max(c(grp[[1]], grp[[2]]))\n            new.root <- all.dec[max.grp]\n\n            set1 <- sets.temp[[max.grp]]\n\n            sets <- rep(2, length(inds))\n            sets <- replace(sets, set1, 1)\n            names(sets) <- rownames(snps)\n\n            counter <- counter+1\n\n            grp1 <- grp[[max.grp]]\n\n          } # end while loop\n\n        } # end rtree\n\n        ###########################\n        ## BOTH coaltree & rtree ##\n        ###########################\n\n        set1 <- names(sets)[which(sets == 1)]\n        set2 <- names(sets)[which(sets == 2)]\n        ###########\n\n        ########################\n        ## MODIFY SNPS.ASSOC: ##\n        ########################\n        snps.assoc.set1 <- 1:round(length(snps.assoc)/2)\n        snps.assoc.set2 <- (round(length(snps.assoc)/2)+1):length(snps.assoc)\n\n        ## replace set1 snps with 0 at all inds in clade.set1:\n        for(e in 1:length(snps.assoc.set1)){\n          snps[which(rownames(snps) %in% set1), snps.assoc[snps.assoc.set1[e]]] <- 0\n        }\n        ## replace set2 snps with 0 at all inds in clade.set2:\n        for(e in 1:length(snps.assoc.set2)){\n          snps[which(rownames(snps) %in% set2), snps.assoc[snps.assoc.set2[e]]] <- 0\n        }\n      }\n    }\n  } # end sim set 2\n\n\n  ##################\n  ## get RESULTS: ##\n  ##################\n  out <- list(snps, snps.assoc, tree.reconstructed, sets, phen, phen.nodes)\n  names(out) <- c(\"snps\", \"snps.assoc\", \"tree.reconstructed\", \"sets\", \"phen\", \"phen.nodes\")\n\n  return(out)\n\n  } # end snp.sim.Q\n\n\n\n\n#####################\n## .getDescendants ##\n#####################\n## get clades --> numbers of descendants in successive major clades:\n## phytools (?) fn from Revell blog:\n## http://blog.phytools.org/2012/01/function-to-get-descendant-node-numbers.html\n.getDescendants<-function(tree,node,curr=NULL){\n\n  if(is.null(curr)) curr <- vector()\n\n  daughters <- tree$edge[which(tree$edge[,1]==node),2]\n  curr <- c(curr,daughters)\n\n  w <- which(daughters>=length(tree$tip))\n  if(length(w) > 0) for(i in 1:length(w))\n    curr <- .getDescendants(tree, daughters[w[i]], curr)\n\n  return(curr)\n} # end .getDescendants\n\n\n\n\n\n\n##################\n## .get.locus01 ##\n##################\n\n# ########################################################################\n#\n# ###################\n# ## DOCUMENTATION ##\n# ###################\n#\n# #' Short one-phrase description.\n# #'\n# #' Longer proper discription of function...\n# #'\n# #' @param snps description.\n# #'\n# #' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n# #' @export\n# #'\n# #' @examples\n# #' ## Example ##\n#\n# ########################################################################\n\n.get.locus01 <- function(subs.edges, root.nt, tree, coaltree=TRUE){\n\n  ## convert subs.edges into appropriate format:\n  snps.loci <- list()\n  snps.loci[[1]] <- subs.edges\n\n  ## rearrange snps.loci s.t it becomes a\n  ## list of length tree$edge.length,\n  ## each element of which contains the\n  ## locations of the mutations that will\n  ## occur on that branch\n  snps.loci <- sapply(c(1:length(tree$edge.length)),\n                      function(f)\n                        seq_along(snps.loci)[sapply(snps.loci,\n                                                    function(e) f %in% e)])\n\n\n  # we will store the output in a list called locus:\n  locus <- list()\n  ## get the node names for all individuals (terminal and internal)\n  all.inds <- sort(unique(as.vector(unlist(tree$edge))))\n  ## we start w all inds having same genotype as root:\n  for(j in all.inds){\n    locus[[j]] <- root.nt\n  }\n\n  ## store replacement nts in list new.nts:\n  new.nts <- list()\n  ## distinguish btw list of loci and unique list\n  snps.loci.ori <- snps.loci\n  ## will need to treat repeat loci differently...\n  snps.loci.unique <- lapply(snps.loci, unique)\n  ## the last individual in the first column of tree$edge\n  ## (ie. ind.length(tree$tip.label)+1 ) is our root individual:\n  x <- rev(c(1:nrow(tree$edge)))\n\n  if(coaltree == FALSE){\n    ## use normal/reverse (top:bottom) edge mat:\n    x <- 1:nrow(tree$edge)\n  }\n\n  #############################\n  ## For Loop to get new nts ##\n  #############################\n  for(i in x){\n    ## for all locus other than root, we mutate the\n    ## genome of the node preceding it, according to snps.loci.\n    ## Draw new nts for each locus selected for mutation:\n    if(!.is.integer0(snps.loci.unique[[i]])){\n      new.nts[[i]] <- sapply(c(1:length(snps.loci.unique[[i]])), function(e)\n        selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                             %in% locus[[tree$edge[i,1]]]\n                                             [snps.loci.unique[[i]][e]])]))\n      ## if any loci are selected for multiple mutations\n      ## within their given branch length:\n      if(length(snps.loci.ori[[i]]) != length(snps.loci.unique[[i]])){\n        ## identify which loci are repeaters\n        repeats <-table(snps.loci.ori[[i]])[which(table(snps.loci.ori[[i]])!=1)]\n        ## how many times they repeat\n        n.reps <- repeats - 1\n        ## the positions of these loci in the vector of snps loci\n        toRepeat <- which(snps.loci.unique[[i]] %in% names(repeats))\n        ## run chain of re-sampling to end in our new nt for repeater loci:\n        foo <- list()\n        for(j in 1:length(toRepeat)){\n          foo[[j]] <- new.nts[[i]][toRepeat[j]]\n          for(k in 1:n.reps[j]){\n            if(k==1){\n              foo[[j]][k] <- selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                                                  %in% foo[[j]][1])])\n\n            }else{\n              foo[[j]][k] <- selectBiallelicSNP(c(\"0\", \"1\")[which(c(\"0\", \"1\")\n                                                                  %in% foo[[j]][k-1])])\n            }\n          }\n          ## retain only the last nt selected\n          out <- sapply(c(1:length(foo)),\n                        function(e) foo[[e]][length(foo[[e]])])\n        }\n        ## for the loci with repeated mts, replace these positions\n        ## in new.nts with the corresponding elements of out, above.\n        new.nts[[i]][toRepeat] <- out\n      } # end of if statement for repeaters\n\n      ## update ancestral genotype with new.nts:\n      temp <- locus[[tree$edge[i,1]]]\n      temp[snps.loci.unique[[i]]] <- new.nts[[i]]\n      locus[[tree$edge[i,2]]] <- temp\n\n    }else{\n      ## if no mts occur on branch, set genotype of\n      ## downstream individual to be equal to ancestor's\n      locus[[tree$edge[i,2]]] <- locus[[tree$edge[i,1]]]\n    }\n  } # end of for loop selecting new nts at mutator loci\n\n  ## turn locus into a vector for easier post-handling\n  locus <- as.vector(unlist(locus))\n\n  return(locus)\n\n} # end .get.locus01\n",
    "created" : 1476486673082.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2805740938",
    "id" : "2ED4BD6E",
    "lastKnownWriteTime" : 1476501654,
    "path" : "C:/Users/Caitlin/treeWAS/pkg/R/snp.sim.Q.R",
    "project_path" : "R/snp.sim.Q.R",
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : true,
    "type" : "r_source"
}