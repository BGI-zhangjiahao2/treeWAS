{
    "contents" : "\n\n\n#########\n## asr ##\n#########\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param var Either a matrix or a vector containing the state of a variable (eg. SNPs or a phenotype)\n#' for all individuals (ie. for all terminal nodes in the tree).\n#' @param tree A phylo object containing the tree representing the ancestral relationships\n#' between the individuals for which snps and phen are known.\n#' @param type A character string specifying whether ancestral state reconstruction should be\n#' performed by \\code{parsimony} or \\code{ace} (as performed in package \\emph{ape}).\n#' @param method A character string specifying the type of ACE method to implement (only used if\n#' \\code{type} is set to \"ace\").\n#'\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#'\n#' @import ape\n\n########################################################################\n\nasr <- function(var,\n                tree,\n                type = c(\"parsimony\", \"ace\"),\n                method = \"discrete\"){\n\n  # require(ape)\n\n  ## get tree edges\n  edges <- tree$edge\n  ord <- NULL\n\n  #######################\n  ## MATRIX (eg. SNPs) ##\n  #######################\n  if(class(var) == \"matrix\"){\n\n    snps <- var\n\n    ###############################\n    ## get unique SNPs patterns: ##\n    ###############################\n    temp <- get.unique.matrix(snps, MARGIN=2)\n    snps.unique <- temp$unique.data\n    index <- temp$index\n\n    if(ncol(snps.unique) == ncol(snps)){\n      all.unique <- TRUE\n    }else{\n      all.unique <- FALSE\n    }\n\n    ## work w only unique snps:\n    snps.ori <- snps\n    snps <- snps.unique\n\n    ############################\n    ## run PARSIMONY on SNPs: ##\n    ############################\n    if(type == \"parsimony\"){\n\n      ## run get.ancestral.pars\n      snps.pars <- get.ancestral.pars(var=snps, tree=tree)\n\n      ## get elements of output\n      snps.rec <- snps.pars$var.rec\n      snps.subs.edges <- snps.pars$subs.edges\n\n    } # end parsimony\n\n\n    ######################\n    ## run ACE on SNPs: ##\n    ######################\n    if(type == \"ace\"){\n\n      snps.rec <- snps.ACE <- list()\n\n      for(i in 1:ncol(snps)){\n\n        ## get variable i\n        var <- snps[,i]\n\n        ## get terminal values\n        var.terminal <- var\n\n        ## get internal values (from ACE output for variable i)\n        snps.ACE[[i]] <- ace(var, tree, type=method)\n        var.internal <- snps.ACE[[i]]$lik.anc[,2]\n\n        ## get reconstruction from terminal & internal values\n        snps.rec[[i]] <- c(var.terminal, var.internal)\n      }\n\n      ## bind columns of snps.rec together\n      snps.rec <- do.call(\"cbind\", snps.rec)\n      colnames(snps.rec) <- colnames(snps)#\n\n    } # end ace\n\n\n    ############################################\n    ## get values for duplicate snps columns: ##\n    ############################################\n\n    ## get reconstruction for all original sites\n    if(all.unique == TRUE){\n      var.rec <- snps.rec\n    }else{\n      var.rec <- snps.rec[, index]\n      rownames(var.rec) <- rownames(snps.rec)\n      colnames(var.rec) <- colnames(snps.ori)\n    }\n\n    ## get sub locations on branches for all original sites\n    if(type == \"parsimony\"){\n      if(all.unique == TRUE){\n        subs.edges <- snps.subs.edges\n      }else{\n        subs.edges <- snps.subs.edges[index]\n      }\n    }\n\n\n\n  }else{ # end matrix (snps)   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n    #######################\n    ## VECTOR (eg. phen) ##\n    #######################\n    phen <- var\n\n    ############################\n    ## run PARSIMONY on phen: ##\n    ############################\n    if(type == \"parsimony\"){\n      ## run get.ancestral.pars\n      phen.pars <- get.ancestral.pars(var=phen, tree=tree)\n\n      ## get elements of output\n      var.rec <- phen.pars$var.rec\n      subs.edges <- phen.pars$subs.edges\n\n    } # end parsimony\n\n\n    ######################\n    ## run ACE on phen: ##\n    ######################\n    if(type == \"ace\"){\n      ## Do we need to check phen is numeric??\n\n      ## get terminal values\n      phen.terminal <- phen\n\n      ## get internal values (from ACE output)\n      phen.ACE <- ace(phen, tree, type=method)\n      phen.internal <- phen.ACE$lik.anc[,2]\n\n      ## get reconstruction from terminal & internal values\n      var.rec <- c(phen.terminal, phen.internal)\n\n    } # end ace\n\n  } # end vector (phen)   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n\n  ################\n  ## GET OUTPUT ##\n  ################\n  if(type == \"parsimony\"){\n    output <- list(\"var.rec\" = var.rec,\n                   \"subs.edges\" = subs.edges)\n  }else{\n    ## NOTE that ACE does NOT return subs.edges...\n    output <- list(\"var.rec\" = var.rec)\n  }\n\n  ## return output\n  return(output)\n\n} # end asr\n\n\n\n\n\n\n\n\n\n\n\n\n\n########################\n## get.ancestral.pars ##\n########################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Ancestral sequence reconstruction via parsimony\n#'\n#' A wrapper for the \\code{ancestral.pars} function from \\emph{ape}. Can perform\n#' parsimonious ASR for variables in matrix or vector form.\n#'\n#' @param var A matrix or vector containing a variable whose state at ancestral nodes we want to infer.\n#' @param tree A phylo object containing a phylogenetic tree whose tips contain the same individuals as are\n#' in the elements of \\code{var}, if \\code{var} is a vector,\n#' or in the rows of \\code{var}, if \\code{var} is a matrix.\n#'\n#' @details Note that the (row)names of \\code{var} should match the tip.labels of \\code{tree}.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#'\n#' @import phangorn ape\n#'\n#' @export\n#'\n\n########################################################################\n\nget.ancestral.pars <- function(var, tree){\n\n  # require(ape)\n  # require(phangorn)\n\n  ord <- NULL\n  edges <- tree$edge\n\n  #############################\n  ## RUN PARSIMONY on MATRIX ##\n  #############################\n\n  if(is.matrix(var)){\n\n    snps <- var\n\n    ###############################\n    ## get unique SNPs patterns: ##\n    ###############################\n    temp <- get.unique.matrix(snps, MARGIN=2)\n    snps.unique <- temp$unique.data\n    index <- temp$index\n\n    if(ncol(snps.unique) == ncol(snps)){\n      all.unique <- TRUE\n    }else{\n      all.unique <- FALSE\n    }\n\n    ## work w only unique snps:\n    snps.ori <- snps\n    snps <- snps.unique\n\n    ##########################################\n    ## get SNP states of all internal nodes ##\n    ##########################################\n\n    #############\n    ## ACCTRAN ##\n    #############\n\n    ## pace == ancestral.pars ## (ape)\n    ## parsimony version of ace ## based on the fitch algorithm.\n    ## ACCTRAN = \"ACCelerated TRANsformation\"\n\n    ## as.phyDat requires row/col names:\n    if(is.null(row.names(snps))){\n      warning(\"Replacing NULL row.names(snps) with tree$tip.label (or assigning 1:N to both).\n              Careful--if tree$tip.label and row.names(snps) should NOT be in the same order,\n              please STOP and assign these names in the correct order.\")\n      if(!is.null(tree$tip.label)){\n        row.names(snps) <- tree$tip.label\n      }else{\n        row.names(snps) <- c(1:nrow(snps))\n        tree$tip.label <- c(1:nrow(snps)) # ???\n      }\n    }\n    if(is.null(colnames(snps))) colnames(snps) <- c(1:ncol(snps))\n    ## get levels (ie. 0, 1)\n    snps.levels <- sort(unique(as.vector(snps)))\n    ## returns only unique patterns...\n    snps.phyDat <- as.phyDat(as.matrix(snps),\n                             type=\"USER\", levels=snps.levels)\n    ## get index of all original snps columns to map to unique pattern\n    index <- attr(snps.phyDat, \"index\")\n\n    ## pace == ancestral.pars\n    pa.ACCTRAN <- pace(tree, snps.phyDat, type=\"ACCTRAN\")\n\n    ## NOTE: pace  --> diff resuls w MPR vs. ACCTRAN\n    # pa.MPR <- pace(tree, snps.phyDat, type=\"MPR\")\n    #diffs <- sapply(c(1:length(pa.ACCTRAN)), function(e) identical(pa.MPR[[e]], pa.ACCTRAN[[e]]))\n\n    ###########################################\n    ## convert reconstruction back to snps.. ##\n    ###########################################\n    ## each of the n.ind elements of pa is a matrix w n.snps rows and either:\n    ## 2 columns, for the 2 binary SNP states, or\n    ## 4 columns, each for the 4 nts possible (acgt)\n\n    # rec <- pa.MPR\n    rec <- pa.ACCTRAN\n\n    ## Handle terminal nodes (ie. reorder)\n\n    ## (1) Bind rows together:\n    #     REC <- list()\n    #     for(i in 1:length(rec)) REC[[i]] <- rec[[i]][,2]\n    #     REC <- do.call(\"rbind\", REC)\n    #     row.names(REC) <- names(rec)\n    #     colnames(REC) <- colnames(snps)\n    #\n    #     ## (2) Reorder rows to correctly match labels, SNPs...??????????????????????\n    #     df.ori <- data.frame(REC[1:100,1:10], snps[1:100,1:10])\n    #     df.ori[1:10,]\n    #     ## EQUIVALENTLY, EITHER.........\n    #\n    #     ## (2.A)\n    #     ord <- list()\n    #     for(i in 1:nrow(snps)) ord[[i]] <- which(row.names(snps) == i)\n    #     ord <- as.vector(unlist(ord))\n    #     ## check\n    #     df <- data.frame(REC[ord,1:10], snps[1:100,1:10])\n    #\n    #     ## (2.B)\n    #     ord <- as.numeric(row.names(snps))\n    #     REC2 <- matrix(NA, nrow=nrow(REC), ncol=ncol(REC))\n    #     for(i in ord) REC2[i,] <- REC[which(ord == i),]\n    #     REC <- REC2\n    #     row.names(REC) <- names(rec)\n    #     colnames(REC) <- colnames(snps)\n    #     ## check\n    #     df2 <- data.frame(REC2[1:100,1:10], snps[1:100,1:10])\n\n    ## NOTE: pace works with terminal SNPs in the order they appear in tree$tip.label\n    ## First, check to ensure all row.names(snps) are matched in tree$tip.label\n    if(all(row.names(snps) %in% tree$tip.label)){\n      ord <- match(tree$tip.label, rownames(snps))\n    }else{\n      ord <- 1:length(rownames(snps))\n      warning(\"rownames(snps) and tree$tip.label contain different labels.\n              Careful-- we proceed by assuming snps rows and tree tips are labelled in the same order!\")\n    }\n    ## Want rec (list) to be in order of tree$tip.label\n    ## eg. if tree$tip.label[1] is \"31\", ord[1] should be 31 (assuming rownames(snps) are 1:nrow)\n    ord <- c(ord, c(nrow(snps)+1):length(rec))\n    snps.rec <- do.call(cbind, rec[ord])\n    snps.rec <- t(snps.rec[, seq(2, ncol(snps.rec), 2)])\n\n    ## assign rownames for all terminal and internal nodes\n    rownames(snps.rec) <- c(rownames(snps), c((nrow(snps)+1):((nrow(snps)*2)-1)))\n    colnames(snps.rec) <- c(1:length(snps.phyDat[[1]]))\n\n\n    ###########################################\n    ## get LOCATIONS (branches) of snps subs ##\n    ###########################################\n    subs.edges <- rep(list(NULL), ncol(snps.rec))\n\n    subs.logical <- matrix(snps.rec[edges[, 1], ] == snps.rec[edges[, 2], ], nrow=nrow(edges), byrow=F)\n\n    ## get states of anc and dec:\n    df.anc <- snps.rec[edges[, 1], ]\n    # df.dec <- snps.rec[edges[, 2], ]\n\n\n    ## get indices of all edges containing a substitution\n    for(i in 1:ncol(snps.rec)){\n      subs.total <- which(subs.logical[, i] == FALSE)\n\n      ## get indices of all edges w a positive sub (0 --> 1)\n      subs.pos <- subs.total[which(subs.total %in% which(df.anc[,i] == 0))]\n      ## get indices of all edges w a negative sub (1 --> 0)\n      subs.neg <- subs.total[which(subs.total %in% which(df.anc[,i] == 1))]\n\n      ## get output list\n      subs.edges[[i]] <- rep(list(NULL), 3)\n      names(subs.edges[[i]]) <- c(\"total\", \"pos\", \"neg\")\n      if(length(subs.total) > 0) subs.edges[[i]][[\"total\"]] <- subs.total\n      if(length(subs.pos) > 0) subs.edges[[i]][[\"pos\"]] <- subs.pos\n      if(length(subs.neg) > 0) subs.edges[[i]][[\"neg\"]] <- subs.neg\n    }\n\n    ####################\n    ## PLOT to CHECK? ##\n    ####################\n    ## for SNP1, does it identify the correct/reasonable branches?\n    #     edgeCol <- rep(\"black\", nrow(edges))\n    #     edgeCol <- replace(edgeCol, subs.edges[[1]][[\"total\"]], \"green\")\n    #\n    #     ## plot the i'th character's reconstruction on the tree:\n    #     #require(adegenet)\n    #     plotAnc(tree, pa.ACCTRAN, i=1,\n    #             col=transp(c(\"red\", \"royalblue\"), 0.75),\n    #             cex.pie=0.1, pos=NULL,\n    #             edge.color=edgeCol, edge.width=2, use.edge.length=FALSE, type=\"c\")\n\n\n    ############################################\n    ## get values for duplicate snps columns: ##\n    ############################################\n\n    ## get reconstruction for all original sites\n    if(ncol(snps.ori) == ncol(snps.rec)){\n      snps.rec.complete <- snps.rec\n    }else{\n      snps.rec.complete <- snps.rec[, index]\n      rownames(snps.rec.complete) <- rownames(snps.rec)\n      colnames(snps.rec.complete) <- colnames(snps.ori)\n    }\n\n    ## get sub locations on branches for all original sites\n    snps.subs.edges <- subs.edges\n    if(ncol(snps.ori) == ncol(snps.rec)){\n      snps.subs.edges.complete <- snps.subs.edges\n    }else{\n      snps.subs.edges.complete <- snps.subs.edges[index]\n    }\n\n\n    ################\n    ## Get output ##\n    ################\n\n    ## CHECK-- compare cost from fitch and pace: ##\n    ###########\n    ## get n.subs per site by fitch:\n    # cost <- get.fitch.n.mts(snps, tree)\n\n    ## get n.subs per site by pace:\n    # cost2 <- sapply(c(1:length(snps.subs.edges.complete)),\n    # function(e) length(snps.subs.edges.complete[[e]][[\"total\"]]))\n\n    ## NOTE: cost2 differs somewhat noticeably from original fitch cost\n    ## (ie. parsimony shifts distribution toward 1/reduces the weight of the upper tail...)\n    ## WHY? Which should we use to get n.subs????????????????????????????????????????????????????????????\n\n    ## Get final output list:\n    var.rec <- snps.rec.complete\n    subs.edges <- snps.subs.edges.complete\n\n    out <- list(\"var.rec\" = var.rec,\n                \"subs.edges\" = subs.edges)\n\n  }else{ # end matrix (snps) parsimony\n\n    ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n\n    #############################\n    ## RUN PARSIMONY on VECTOR ##\n    #############################\n\n    ## Eg. get PHEN states of all internal nodes\n\n    phen <- var\n\n    #############\n    ## ACCTRAN ##\n    #############\n\n    phen.ori <- phen\n    phen <- as.numeric(as.character(phen))\n    ## as.phyDat requires names...\n    if(is.null(names(phen))){\n      if(!is.null(tree$tip.label)) names(phen) <- tree$tip.label\n    }\n\n    ## get levels (ie. 0, 1)\n    phen.levels <- sort(unique(phen))\n    phen.phyDat <- as.phyDat(as.matrix(phen),\n                             type=\"USER\", levels=phen.levels)\n    ## pace == ancestral.pars\n    rec <- phen.pa.ACCTRAN <- pace(tree, phen.phyDat, type=\"ACCTRAN\")\n\n    ## get reconstruction:\n    if(is.null(ord)) ord <- 1:length(rec)\n    phen.rec <- do.call(cbind, rec[ord])\n    phen.rec <- as.vector(phen.rec[, seq(2, ncol(phen.rec), 2)])\n\n    names(phen.rec) <- c(names(phen), c((length(phen)+1):((length(phen)*2)-1)))\n\n    ###########################################\n    ## get LOCATIONS (branches) of phen subs ##\n    ###########################################\n\n    ## make empty output list\n    phen.subs.edges <- rep(list(NULL), 3)\n    names(phen.subs.edges) <- c(\"total\", \"pos\", \"neg\")\n\n    ## identify if subs occur on each branch:\n    phen.subs.logical <- phen.rec[edges[, 1]] == phen.rec[edges[, 2]]\n    names(phen.subs.logical) <- 1:nrow(edges) ## WHY DID IT AUTOMATICALLY LABEL THE ROWS IN REVERSE ORDER (199:101) ?????\n    ## get indices of all edges containing a substitution\n    phen.subs.total <- which(phen.subs.logical == FALSE)\n    ## get df of states of ancestor and descendants nodes on these edges\n    df <- data.frame(phen.rec[edges[phen.subs.total,1]], phen.rec[edges[phen.subs.total,2]])\n    names(df) <- c(\"anc\", \"dec\")\n    ## get indices of all edges w a positive sub (0 --> 1)\n    phen.subs.pos <- phen.subs.total[which(df$anc==0)]\n    ## get indices of all edges w a negative sub (1 --> 0)\n    phen.subs.neg <- phen.subs.total[which(df$anc==1)]\n\n    ## get output list\n    if(length(phen.subs.total) > 0) phen.subs.edges[[\"total\"]] <- phen.subs.total\n    if(length(phen.subs.pos) > 0) phen.subs.edges[[\"pos\"]] <- phen.subs.pos\n    if(length(phen.subs.neg) > 0) phen.subs.edges[[\"neg\"]] <- phen.subs.neg\n\n    ####################\n    ## PLOT to CHECK? ##\n    ####################\n    ## for SNP1, does it identify the correct/reasonable branches?\n    #     edgeCol <- rep(\"black\", nrow(edges))\n    #     edgeCol <- replace(edgeCol, phen.subs.edges[[\"total\"]], \"green\")\n    #\n    #     ## plot the i'th character's reconstruction on the tree:\n    #     #require(adegenet)\n    #     plotAnc(tree, phen.pa.ACCTRAN, i=1,\n    #             col=transp(c(\"red\", \"royalblue\"), 0.75),\n    #             cex.pie=0.1, pos=NULL,\n    #             edge.color=edgeCol, edge.width=2, use.edge.length=FALSE, type=\"c\")\n\n    ################\n    ## Get output ##\n    ################\n    var.rec <- phen.rec\n    subs.edges <- phen.subs.edges\n    out <- list(\"var.rec\" = var.rec,\n                \"subs.edges\" = subs.edges)\n\n  } # end vector (phen) parsimony\n\n  return(out)\n\n} # end get.ancestral.pars\n\n\n\n",
    "created" : 1476793462485.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1852415305",
    "id" : "462A7CC0",
    "lastKnownWriteTime" : 1476797813,
    "path" : "C:/Users/Caitlin/treeWAS/pkg/R/reconstruct.R",
    "project_path" : "R/reconstruct.R",
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : true,
    "type" : "r_source"
}