{
    "contents" : "\n#####################\n## subsequent.test ## ## NEW ORIGINAL SCORE 3 (w integral score, no edge-length) ##\n#####################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param tree A phylo object.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## basic use of fn\n#' tree <- coalescent.tree.sim(n.ind = 100, seed = 1)\n#'\n\n########################################################################\n\nsubsequent.test <- function(snps.reconstruction,\n                            phen.reconstruction,\n                            tree){\n\n  snps.rec <- snps.reconstruction\n  phen.rec <- phen.reconstruction\n\n  ## get tree edges:\n  edges <- tree$edge\n\n  #########################\n  ## Get UNIQUE snps.rec ##\n  #########################\n  temp <- get.unique.matrix(snps.rec, MARGIN=2)\n  snps.rec.unique <- temp$unique.data\n  index <- temp$index\n\n  if(ncol(snps.rec.unique) == ncol(snps.rec)){\n    all.unique <- TRUE\n  }else{\n    all.unique <- FALSE\n  }\n\n  ## work w only unique snps:\n  snps.rec.ori <- snps.rec\n  snps.rec <- snps.rec.unique\n\n  ###############################\n  ## GET SCORE ACROSS BRANCHES ##\n  ###############################\n\n  Pa <- phen.rec[edges[,1]]\n  Pd <- phen.rec[edges[,2]]\n  Sa <- snps.rec[edges[,1], ]\n  Sd <- snps.rec[edges[,2], ]\n  bl <- tree$edge.length\n\n  #################################################################     #####\n  ###############\n  ## SCORE 3.1 ##\n  ###############\n  ## SIMPLE UNWEIGHTED TALLY SCORE (1 point for each of \"subsequent\", \"maintained\", \"simultaneous\")\n\n  score3.p <- c(\"00|00\", \"11|11\", \"00|11\", \"11|00\", \"01|00\", \"10|00\", \"01|11\", \"10|11\")\n  score3.n <- c(\"00|01\", \"00|10\", \"11|01\", \"11|10\", \"01|01\", \"10|10\", \"01|10\", \"10|01\")\n\n  score3.1 <- t(matrix(paste(Sa, Pa, \"|\", Sd, Pd, sep=\"\"), nrow=ncol(snps.rec), byrow=T))\n  score3.1 <- abs(sapply(c(1:ncol(score3.1)), function(e) length(which(score3.1[,e] %in% score3.p)) - length(which(score3.1[,e] %in% score3.n))))\n\n  names(score3.1) <- colnames(snps.rec)\n\n  #################################################################     #####\n  ###############\n  ## SCORE 3.0 ##\n  ###############\n  ## ORIGINAL AND NEW INTEGRAL-BASED SCORE3 (with and without edge length):\n  score3.L <- get.score3(Pa = Pa, Pd = Pd, Sa = Sa, Sd = Sd, l = bl)\n  score3.NoL <- get.score3(Pa = Pa, Pd = Pd, Sa = Sa, Sd = Sd, l = NULL)\n\n  score3.L <- abs(colSums(score3.L, na.rm=TRUE))\n  names(score3.L) <- colnames(snps.rec)\n\n  score3.NoL <- abs(colSums(score3.NoL, na.rm=TRUE))\n  names(score3.NoL) <- colnames(snps.rec)\n\n  ################################################\n  ## get values for duplicate snps.rec columns: ##\n  ################################################\n\n  ## get reconstruction for all original sites\n  if(all.unique == TRUE){\n    score3.1.complete <- score3.1\n    score3.L.complete <- score3.L\n    score3.NoL.complete <- score3.NoL\n  }else{\n    score3.1.complete <- score3.1[index]\n    names(score3.1.complete) <- colnames(snps.rec.ori)\n    score3.L.complete <- score3.L[index]\n    names(score3.L.complete) <- colnames(snps.rec.ori)\n    score3.NoL.complete <- score3.NoL[index]\n    names(score3.NoL.complete) <- colnames(snps.rec.ori)\n  }\n\n  score3.1 <- score3.1.complete\n  score3.L <- score3.L.complete\n  score3.NoL <- score3.NoL.complete\n\n  score <- list(\"score3.1\" = score3.1,\n                \"score3.L\" = score3.L,\n                \"score3.NoL\" = score3.NoL)\n  return(score)\n\n} # end subsequent.test\n\n\n\n\n\n\n\n\n################\n## get.score3 ##\n################\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param Pa A numeric value containing either the state,\n#' or the probability of the state, of the phenotype at a given \\emph{ancestral} node.\n#' @param Pd A numeric value containing either the state,\n#' or the probability of the state, of the phenotype at a given \\emph{descendant} node.\n#' @param Sa A numeric value containing either the state,\n#' or the probability of the state, of SNPi at a given \\emph{ancestral} node.\n#' @param Sd A numeric value containing either the state,\n#' or the probability of the state, of SNPi at a given \\emph{descendant} node.\n#' @param l A numeric value specifying the length of the branch in the phylogenetic tree\n#' that joins the ancestral and descendant node.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## basic use of fn\n#' tree <- coalescent.tree.sim(n.ind = 100, seed = 1)\n#'\n\n########################################################################\n\nget.score3 <- function(Pa, Pd, Sa, Sd, l=NULL){\n\n  score3 <- NULL\n\n  if(!is.null(l)){\n    ## NEW original integral-based score (WITHOUT edge-length!)...\n    score3 <- l*(((4/3)*Pa*Sa) +\n                   ((2/3)*Pa*Sd) +\n                   ((2/3)*Pd*Sa) +\n                   ((4/3)*Pd*Sd) -\n                   Pa -\n                   Pd -\n                   Sa -\n                   Sd +\n                   1)\n  }else{\n    ## NEW original integral-based score (WITHOUT edge-length!)...\n    score3 <- (((4/3)*Pa*Sa) +\n                 ((2/3)*Pa*Sd) +\n                 ((2/3)*Pd*Sa) +\n                 ((4/3)*Pd*Sd) -\n                 Pa -\n                 Pd -\n                 Sa -\n                 Sd +\n                 1)\n  }\n\n  return(score3)\n\n} # end get.score3\n\n\n\n#\n\n\n\n\n\n#\n",
    "created" : 1476305742618.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "635634713",
    "id" : "EC07634A",
    "lastKnownWriteTime" : 1476069212,
    "path" : "C:/Users/Caitlin/treeWAS/pkg/R/subsequent.test.R",
    "project_path" : "R/subsequent.test.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}