{
    "collab_server" : "",
    "contents" : "\n#############\n## treeWAS ##\n#############\n\n\n## Re-implementation of GWAS method developed in Sheppard et al 2014,\n## based on the generation of a phylogenetically-correct p-value\n## derived by comparing correlation btw SNPs\n## and a phenotype of interest to a null distribution\n## (Poisson dist w parameter 1) OR\n## (modification based on similar method developed in Farhat et al 2013)\n## based on permutation of empirically-derived\n## n.mts per site (except we determine this with the Fitch algorithm).\n\n############\n## TO DO: ##\n############\n## 1) Implement an internal protocol to get the n.subs distribution\n## from the data either by\n## (A) linking to/calling ClonalFrameML,\n## (B) using the code used in ClonalFrameML without calling the program,\n## (C) writing separate code using R fns (available or self-generated)\n## 2)\n\n\n########################################################################\n\n###################\n## DOCUMENTATION ##\n###################\n\n#' Short one-phrase description.\n#'\n#' Longer proper discription of function...\n#'\n#' @param test A character string or vector containing one or more of the following available tests of association:\n#' \"terminal\", \"simultaneous\", \"subsequent\", \"cor\", \"fisher\". By default, the first three tests are run.\n#' See details for more information on what these tests do and when they may be appropriate.\n#'\n#' @author Caitlin Collins \\email{caitiecollins@@gmail.com}\n#' @export\n#' @examples\n#'\n#' ## load data\n#' data(dist)\n#' str(dist)\n#'\n#' ## basic use of fn\n#' fn(arg1, arg2)\n#'\n#' #' ## more elaborate use of fn\n#' fn(arg1, arg2)\n#'\n#' @import adegenet ape phangorn\n#' @importFrom Hmisc all.is.numeric\n#'\n#' @export\n\n########################################################################\n\n################################\n## EXAMPLE (data/parameters): ##\n################################\n\n##############\n## DATA #1: ##\n##############\n# data(\"snps.ace\")\n# data(\"phen.ace\")\n# data(\"tree.ace\")\n#\n# snps <- snps.ori <- snps.ace\n# phen <- phen.ori <- phen.ace\n# tree <- tree.ori <- tree.ace\n\n\n##############\n## DATA #2: ##\n##############\n# foo <- coalescent.sim(n.ind = 100,\n#                       n.snps = 10000,\n#                       n.subs = 1,\n#                       n.snps.assoc = 10,\n#                       assoc.prob = 90,\n#                       n.phen.subs = 15,\n#                       phen = NULL,\n#                       plot = TRUE,\n#                       heatmap = FALSE,\n#                       reconstruct = FALSE,\n#                       dist.dna.model = \"JC69\",\n#                       row.names = NULL,\n#                       grp.min = 0.25,\n#                       seed = 4)\n#\n# snps <- snps.ori <- foo$snps\n# snps.assoc.loci <- snps.assoc <- foo$snps.assoc\n# phen <- phen.ori <- foo$phen\n# tree <- tree.ori <- foo$tree\n\n#################\n## PARAMETERS: ##\n#################\n\n# n.subs <- NULL\n# dist.dna.model <- \"JC69\"\n# plot.tree <- FALSE\n# test <- c(\"terminal\", \"simultaneous\", \"subsequent\")\n# p.value <- 0.001\n# p.value.correct <- \"fdr\"\n# p.value.by <- \"count\"\n# sim.n.snps <- ncol(snps)*10\n# n.reps <- 1\n# plot.manhattan <- TRUE\n# plot.null.dist <- TRUE\n# plot.dist <- FALSE\n# snps.reconstruction <- \"parsimony\"\n# phen.reconstruction <- \"parsimony\"\n\ntreeWAS <- function(snps,\n                    phen,\n                    n.subs = NULL,\n                    tree = c(\"UPGMA\", \"nj\", \"ml\"),\n                    dist.dna.model = \"JC69\",\n                    plot.tree = FALSE,\n                    test = c(\"terminal\", \"simultaneous\", \"subsequent\"),\n                    p.value = 0.001,\n                    p.value.correct = c(\"bonf\", \"fdr\", FALSE), ## DO WE WANT TO ALLOW USERS TO RUN MANY DIFFERENT MULTIPLE TESTING CORRECTION METHODS FOR EACH TEST?????????\n                    p.value.by = c(\"count\", \"density\"),\n                    sim.n.snps = ncol(snps),\n                    n.reps = 1,\n                    plot.manhattan = TRUE,\n                    plot.null.dist = TRUE,\n                    plot.dist = FALSE,\n                    snps.assoc = NULL, # for (manhattan) plot\n                    snps.reconstruction = \"parsimony\",\n                    phen.reconstruction = \"parsimony\",\n                    coaltree = TRUE,\n                    filename.plot = NULL){\n\n  ###################\n  ## LOAD PACKAGES ##\n  ###################\n  # require(adegenet)\n  # require(phangorn)\n  # require(ape)\n  # # require(ade4) #?\n  # require(Hmisc) # all.is.numeric\n\n  #####################################################################\n  ## 0) HANDLE INPUT DATA #############################################\n  #####################################################################\n\n  #####################\n  ## HANDLE TEST ARG ##\n  #####################\n\n  ## Allow partial matching of argument names:\n  test <- match.arg(arg = test,\n                    choices = c(\"terminal\", \"simultaneous\", \"subsequent\", \"cor\", \"fisher\"),\n                    several.ok = TRUE)\n\n  ########################\n  ## HANDLE SNPS & PHEN ##\n  ########################\n  if(!is.matrix(snps)) snps <- as.matrix(snps)\n  x <- snps\n  n.snps <- ncol(snps)\n\n  ## convert phenotype to factor\n  phen <- as.factor(phen)\n  y <- phen\n\n  ## set n.ind:\n  n.ind <- length(y)\n  inds <- c(1:n.ind)\n\n  #################\n  ## HANDLE TREE ##\n  #################\n\n  ## RECONSTRUCTED TREE ##\n\n  if(class(tree) == \"character\"){\n\n    tree <- tolower(tree)\n\n    if(!any(c(\"upgma\", \"nj\", \"ml\") %in% tree)){\n      warning(\"If tree is not a phylo object,\n              it should be one of 'UPGMA', 'NJ', 'ML',\n              specifying which method is to be used to\n              reconstruct the phylogenetic tree from the snps provided.\n              Choosing 'UPGMA' by default.\")\n      tree <- \"upgma\"\n    }\n    tree <- tree.reconstruct(snps,\n                             method = tree,\n                             dist.dna.model = dist.dna.model,\n                             plot = plot.tree)\n  }else{\n\n    ## USER-PROVIDED TREE ##\n\n    ## If user has already submitted a tree as input:\n    ## Work with a centered phylo tree for\n    ## consistency and visualisation's sake:\n    if(class(tree) != \"phylo\") tree <- as.phylo(tree)\n    ## if the tree is not already rooted, root it:\n    if(is.rooted(tree)==FALSE) tree <- midpoint(tree)\n\n\n    if(plot.tree==TRUE){\n      plot(tree)\n      title(\"Phylogenetic tree (original)\")\n      axisPhylo()\n    } # end plot.tree\n\n  }# end tree...\n\n\n  ##############################\n  ## HANDLE TIP & NODE LABELS ##\n  ##############################\n\n  ## Use Fitch Parsimony to get homoplasy distribution (n.subs per site)\n  ## unless n.subs distribution has been provided by the user.\n\n  ## tree's tip.labels and node.labels must be numeric (for Fitch parsimony step)\n  tree.ori <- tree\n\n  ## NOTE--COERCING TO NUMERIC CAN CAUSE BIG PROBLEMS!!!!\n  ## TO DO--FIX FITCH PARSIMONY FN S.T IT CAN WORK WITH\n  ## TIP.LABELS & NODE.LABELS THAT ARE NOT NUMERIC!\n\n  if(is.null(n.subs)){\n\n    ## TIP labels ##\n    if(all.is.numeric(tree$tip.label)){\n      ## if we can convert to numeric, do so:\n      tree$tip.label <- as.numeric(tree$tip.label)\n    }else{\n\n      ## if we can remove \"NODE_\" to get numeric, do so:\n      prefix <- keepFirstN(tree$tip.label, 1)\n      if(all(tolower(prefix) == \"t\")){\n        temp <- removeFirstN(tree$tip.label, 1)\n        if(all.is.numeric(temp)){\n          tree$tip.label <- as.numeric(temp)\n        }else{\n          ## else, replace with numeric indices:\n          # tree$tip.label <- c(1:length(tree$tip.label))\n          warning(\"Site-wise parsimony scores (phangorn's\n                  fitch parsimony function) may not be calculated correctly\n                  when tip.labels are not numeric.\n                  Please change tree$tip.label to numeric values.\")\n        }\n      }\n    }\n\n    ## NODE labels ##\n    if(all.is.numeric(tree$node.label)){\n      tree$node.label <- as.numeric(tree$node.label)\n    }else{\n      ## if we can remove \"NODE_\" to get numeric, do so:\n      prefix <- keepFirstN(tree$node.label, 4)\n      if(all(tolower(prefix) == \"node\")){\n        temp <- removeFirstN(tree$node.label, 5)\n        if(all.is.numeric(temp)){\n          tree$node.label <- as.numeric(temp)\n        }else{\n          ## else, replace with numeric indices:\n          # tree$node.label <- c((n.ind+1):(n.ind+tree$Nnode))\n          warning(\"Site-wise parsimony scores (phangorn's\n                  fitch parsimony function) may not be calculated correctly\n                  when node.labels are not numeric.\n                  Please change tree$node.label to numeric values.\")\n        }\n        }\n        }\n        }\n\n\n  ###################\n  ## HANDLE N.SUBS ##\n  ###################\n\n  ## if n.subs is a vector (ie. distribution) ##\n  ## we use this distribution directly (but in proportion with the number of sites)\n  ## to specify the n.subs per site. (Handled within snp.sim fn.)\n\n  ## if n.subs is NULL ##\n  ## we compute the distribution of the n.subs-per-site\n  ## using the Fitch parsimony score calculation fns from phangorn.\n\n  if(is.null(n.subs)){\n\n    ###########\n    ## TO DO ##   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n    ###########\n\n    ## if either test 2 or test 3 will be run with parsimonious/user-provided reconstruction,\n    ## get n.subs from this to avoid duplication..?\n    #     if(any(c(\"simultaneous\", \"subsequent\") %in% test) & snps.reconstruction != \"ace\"){\n    #\n    #       ## run get.ancestral.pars\n    #       snps.pars <- get.ancestral.pars(var=snps, tree=tree)\n    #\n    #       ## get elements of output\n    #       snps.rec <- snps.pars$var.rec\n    #       snps.subs.edges <- snps.pars$subs.edges\n    #\n    #       ## CHECK--Compare costs:\n    #       cost1 <- get.fitch.n.mts(snps=snps, tree=tree)\n    #       cost2 <- sapply(c(1:length(snps.subs.edges)), function(e) length(snps.subs.edges[[e]][[\"total\"]]))\n    #       table(cost1)\n    #       table(cost2) ## longer tail...\n    #\n    #     }else{\n\n    ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n    ## get parsimomy cost for each SNP locus using fitch:\n    n.subs <- get.fitch.n.mts(snps=snps, tree=tree)\n    n.subs <- table(n.subs)\n    ## handle n.subs \"levels\" with 0 SNP loci at those levels:\n    noms <- as.numeric(names(n.subs))\n    temp <- rep(0, max(noms))\n    for(i in 1:max(noms)){\n      if(i %in% noms) temp[i] <- n.subs[which(noms==i)]\n    }\n    n.subs <- temp\n    # }\n  }\n\n\n\n  #####################################################\n  ## 1) Simulate multiple snps datasets to compare your\n  ## real correlations w phen to  #####################\n  #####################################################\n\n  if(is.null(sim.n.snps)) sim.n.snps <- n.snps\n  out <- genomes <- snps.mat <- list()\n\n  for(i in 1:n.reps){\n    ## SIMULATE A DATASET | your tree ##\n    out[[i]] <- snp.sim(n.snps = sim.n.snps,\n                        n.subs = n.subs,\n                        n.snps.assoc = 0,\n                        assoc.prob = 100,\n                        tree = tree,\n                        phen.loci = NULL,\n                        heatmap = FALSE,\n                        reconstruct = FALSE,\n                        dist.dna.model = dist.dna.model,\n                        row.names = row.names(snps),\n                        coaltree = coaltree,\n                        seed = NULL)\n\n    genomes[[i]] <- out[[i]][[1]]\n\n    ## Modify genomes/snps matrices\n    if(!is.null(genomes[[i]])){\n      snps.mat[[i]] <- genomes[[i]]\n    }else{\n      snps.mat[[i]] <- NULL\n    }\n\n    gc()\n\n  } # end for loop\n\n  print(\"treeWAS snps sim done.\")\n\n\n  ################################################################\n  ## 3) Get results:##############################################\n  #### Determine the phylogenetially correct p-values for SNPs | #\n  ##   null distributions of correlations from simulated data ####\n  #### Synthesize results output: List of all significant SNPs, ##\n  ##   their names/locations, their p-values for this phenotype ##\n  ################################################################\n\n  ##################################################\n  ## RUN CHECKS ONCE BEFORE get.sig.snps FOR LOOP ##\n  ##################################################\n\n  ## NOTE: These checks are repeated within the get.sig.snps fn\n  ## as an extra layer of safety/ in case users want to use it alone,\n  ## but it is more economical to run them once outside of the for loop..\n\n\n  ## NOTE TO CHECK! ##   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n  ## Are we SLOWING things down significantly by identifying UNIQUE snps & snps.sim WITHIN the get.sig.snps fn??\n  ## And could we identify unique snps/snps.sim HERE (AND add an extra INDEX argument to get.sig.snps)??\n  ## (ie. get.sig.snps INPUT = UNIQUE snps, snps.sim + index & OUTPUT = results for ALL ORIGINAL/NON-unique sites...).\n\n  ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n  snps.unique <- snps.index <- snps.sim.unique <- snps.sim.index <- NULL\n\n  #################\n  ## Handle snps ##\n  #################\n  ## Check snps column names\n  if(is.null(colnames(snps))) colnames(snps) <- c(1:ncol(snps))\n\n  ################################\n  ## Handle snps.sim --> matrix ##\n  ################################\n  snps.sim <- snps.mat\n\n  ## Handle matrix/list input:\n  if(class(snps.sim) == \"list\"){\n    ## If list of length 1...\n    if(length(snps.sim) == 1){\n      ## keep matrix:\n      snps.sim <- snps.sim[[1]]\n    }else{\n      ## If list of multiple matrices...\n      ## merge all elements into one big matrix\n      ## by pasting columns together:\n      snps.sim <- do.call(\"cbind\", snps.sim)\n    }\n  }\n\n\n  #################\n  ## Handle phen ##\n  #################\n  ## convert phenotype to numeric:\n  ## NOTE--this is also necessary for returning results in step (5)!\n  phen.ori <- phen\n  if(!is.numeric(phen)) phen <- as.numeric(phen)\n  ## for ease of interpretation,\n  ## if phen has 2 levels, 1 and 2,\n  ## make these 0 and 1:\n  if(length(unique(phen))!=2){\n    stop(\"This function is only designed for phenotypes with two levels.\")\n  }else{\n    if(length(phen[-c(which(phen==1), which(phen==2))])==0){\n      phen <- replace(phen, which(phen==1), 0)\n      phen <- replace(phen, which(phen==2), 1)\n    }\n  }\n  ## ensure ind names not lost\n  names(phen) <- names(phen.ori)\n\n  ##############################################################################################\n  ## Reconstruct ancestral SNPs & phen by parsimony/ACE (for tests simultaneous & subsequent) ##\n  ##############################################################################################\n\n  ## Ensure we are only reconstructing ancestral states ONCE here, to be used in MULTIPLE tests later.\n  snps.REC <- snps.sim.REC <- phen.REC <- NULL\n\n  if(any(c(\"simultaneous\", \"subsequent\") %in% test)){\n\n\n    ############\n    ## TO DO: ##   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n    ############\n\n    ## ADD CODE TO HANDLE USER-INPUTTED SNPS/PHEN.RECONSTRUCTIONS:\n    ## - Extract code to get subs.edges from within get.ancestral.pars fn in ace.R --> make a get.subs.edges fn.\n    ## --> Determine if user input is from ACE or PARSIMONY (eg. Are all values 0/1/0.5 (= parsimony) or are any in between (=ace))\n    ## --> NOTE--even if reconstruction provided, will still need to perform reconstruction on SNPS.SIM (& probably phen). Will use\n    ##     inferred snps reconstruction method on snps.sim as well... (OR could add another argument to control this??)\n    ## --> If input = from PARSIMONY, run get.subs.edges fn\n    ## --> Store info as list of snps/phen.REC containing inputted data as var.rec (and get.subs.edges output as subs.edges if parsimony)\n    ## --> Proceed by handling this output as you would if snps/phen were reconstructed within treeWAS as below...\n\n\n    ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###\n\n\n\n\n    #######################\n    ## Reconstruct SNPs: ##\n    #######################\n\n    ## By PARSIMONY: ##\n    if(snps.reconstruction == \"parsimony\"){\n      ## Reconstruct REAL SNPs: ##\n      snps.REC <- asr(var = snps, tree = tree, type = \"parsimony\")\n      snps.rec <- snps.REC$var.rec\n\n      ## Reconstruct SIMULATED SNPs: ##\n      snps.sim.REC <- asr(var = snps.sim, tree = tree, type = \"parsimony\")\n      snps.sim.rec <- snps.sim.REC$var.rec\n    }\n\n    ## By ACE: ##\n    if(snps.reconstruction == \"ace\"){\n      ## Reconstruct REAL SNPs: ##\n      snps.REC <- asr(var = snps, tree = tree, type = \"ace\")\n      snps.rec <- snps.REC$var.rec\n\n      ## Reconstruct SIMULATED SNPs: ##\n      snps.sim.REC <- asr(var = snps.sim, tree = tree, type = \"ace\")\n      snps.sim.rec <- snps.sim.REC$var.rec\n    }\n\n    #######################\n    ## Reconstruct phen: ##\n    #######################\n\n    ## By PARSIMONY: ##\n    if(phen.reconstruction == \"parsimony\"){\n      phen.REC <- asr(var = phen, tree = tree, type = \"parsimony\")\n      phen.rec <- phen.REC$var.rec\n    }\n\n    ## By ACE: ##\n    if(phen.reconstruction == \"ace\"){\n      phen.REC <- asr(var = phen, tree = tree, type = \"ace\")\n      phen.rec <- phen.REC$var.rec\n    }\n\n  } # end reconstruction for tests 2 & 3\n\n  # save(snps.rec, file= \"/home/caitiecollins/treeWAS/misc/snps.rec.Rdata\")\n  # save(snps.sim.rec, file= \"/home/caitiecollins/treeWAS/misc/snps.sim.rec.Rdata\")\n  # save(phen.rec, file= \"/home/caitiecollins/treeWAS/misc/phen.rec.Rdata\")\n\n  ###########################\n  ## GET UNIQUE SNPS(.SIM) ##\n  ###########################\n\n  ## TO DO: ## !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ###\n  ## NOTE--WOULD BE GOOD TO ADD SIMILAR SOLN FOR RECONSTRUCT ABOVE AS W GET.SIG.SNPS BELOW (ie.\n  ## ALLOW FOR INPUT OF UNIQUE VAR AND INDEX AS ARGUMENTS).\n  ## ONCE DONE--MOVE UNIQUE CODE BELOW TO ABOVE THE RECONSTRUCTION CODE SEGMENT...\n\n  ## !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ### !!! ###\n\n  ## Get UNIQUE snps + index\n  snps.complete <- snps\n  temp <- get.unique.matrix(snps, MARGIN=2)\n  snps.unique <- temp$unique.data\n  snps.index <- temp$index\n\n  ## Get UNIQUE snps.sim + index\n  snps.sim.complete <- snps.sim\n  temp <- get.unique.matrix(snps.sim, MARGIN=2)\n  snps.sim.unique <- temp$unique.data\n  snps.sim.index <- temp$index\n\n  ## Get UNIQUE snps.reconstruction\n  snps.rec.complete <- snps.rec\n  temp <- get.unique.matrix(snps.rec, MARGIN=2)\n  snps.rec <- temp$unique.data\n  snps.rec.index <- temp$index\n  if(!identical(snps.rec.index, snps.index)){\n    warning(\"Careful-- snps and snps.rec should have the same index when reduced\n              to their unique forms!\") ## SHOULD THIS BE A \"STOP\" INSTEAD? OR IS THIS ERROR NOT FATAL OR NOT POSSIBLE????\n  }\n\n  ## Get UNIQUE snps.sim.reconstruction\n  snps.sim.rec.complete <- snps.sim.rec\n  temp <- get.unique.matrix(snps.sim.rec, MARGIN=2)\n  snps.sim.rec <- temp$unique.data\n  snps.sim.rec.index <- temp$index\n  if(!identical(snps.sim.rec.index, snps.sim.index)){\n    warning(\"Careful-- snps.sim and snps.sim.rec should have the same index when reduced\n              to their unique forms!\") ## SHOULD THIS BE A \"STOP\" INSTEAD? OR IS THIS ERROR NOT FATAL OR NOT POSSIBLE????\n  }\n\n  print(\"reconstructions done\")\n\n  #######################\n  ## identify sig.snps ##\n  #######################\n\n  ## Note: UNIQUE snps & snps.sim are identified WITHIN the get.sig.snps fn\n  ## to reduce computational time, but results are identified on the basis of all\n  ## ORIGINAL snps & snps.sim columns inputted.\n\n  sig.list <- list()\n\n  # test <- c(\"terminal\", \"simultaneous\", \"subsequent\")\n  TEST <- as.list(test)\n\n  ## Run get.sig.snps fn once for each association test:\n  system.time( # 100 - 164 (why such a difference?)\n  for(i in 1:length(TEST)){\n    if(TEST[[i]] != \"subsequent\"){\n    sig.list[[i]] <- get.sig.snps(snps = snps,\n                                  snps.unique = snps.unique,\n                                  snps.index = snps.index,\n                                  snps.sim = snps.sim,\n                                  snps.sim.unique = snps.sim.unique,\n                                  snps.sim.index = snps.sim.index,\n                                  phen = phen,\n                                  tree = tree,\n                                  test = TEST[[i]],\n                                  n.tests = length(TEST),\n                                  p.value = p.value,\n                                  p.value.correct = p.value.correct,\n                                  p.value.by = p.value.by,\n                                  snps.reconstruction = snps.rec,\n                                  snps.sim.reconstruction = snps.sim.rec,\n                                  phen.reconstruction = phen.rec)\n    }else{\n      sig.list3 <- get.sig.snps(snps = snps,\n                                    snps.unique = snps.unique,\n                                    snps.index = snps.index,\n                                    snps.sim = snps.sim,\n                                    snps.sim.unique = snps.sim.unique,\n                                    snps.sim.index = snps.sim.index,\n                                    phen = phen,\n                                    tree = tree,\n                                    test = TEST[[i]],\n                                    n.tests = length(TEST),\n                                    p.value = p.value,\n                                    p.value.correct = p.value.correct,\n                                    p.value.by = p.value.by,\n                                    snps.reconstruction = snps.rec,\n                                    snps.sim.reconstruction = snps.sim.rec,\n                                    phen.reconstruction = phen.rec)\n      sig.list[[i]] <- sig.list3[[1]]\n      SCORE3 <- sig.list3$SCORE3\n    }\n  }\n  )\n  names(sig.list) <- test\n  # str(sig.list)\n\n  print(\"get sig snps done.\")\n\n  ## DOUBLE CHECKING ##\n  #   str(sig.list[[i]])\n  #   sig.list[[i]]$sig.snps\n  #   sig.list[[i]]$sig.corrs\n  #   ## plot\n  # hist(sig.list[[i]][[1]]$corr.sim)\n  # hist(sig.list[[i]][[1]]$corr.dat)\n\n  # sig.list[[2]][[1]]$corr.dat[snps.assoc]\n  # sig.list[[3]][[1]]$corr.dat[snps.assoc]\n\n  ## BUG CHECKING ##\n  ## get.sig.snps\n  #     snps <-  snps\n  #     snps.sim <- snps.sim\n  #     phen <- phen\n  #     tree <- tree\n  #     test <- \"simultaneous\"\n  #     p.value <- p.value\n  #     p.value.correct <- p.value.correct\n  #     p.value.by <- p.value.by\n  #     snps.reconstruction <- snps.rec\n  #     snps.sim.reconstruction <- snps.sim.rec\n  #     phen.reconstruction <- phen.rec\n\n\n  #################\n  ## GET RESULTS ##\n  #################\n\n  RES <- thresholds <- VALS <- DAT <- list()\n\n  ## get results for each test run:\n  for(j in 1:length(sig.list)){\n\n    RES[[j]] <- list()\n\n    ## get corr.dat, corr.sim, p.vals x2:\n    VALS[[j]] <- list()\n    VALS[[j]][[1]] <- sig.list[[j]][[1]]$corr.dat\n    VALS[[j]][[2]] <- sig.list[[j]][[1]]$corr.sim\n\n    VALS[[j]][[3]] <- list()\n    VALS[[j]][[3]][[1]] <- sig.list[[j]][[1]]$p.vals\n    VALS[[j]][[3]][[2]] <- sig.list[[j]][[2]]$p.vals\n    names(VALS[[j]][[3]]) <- c(\"10.x.n.snps\", \"1.x.n.snps\")\n\n\n    names(VALS[[j]]) <- c(\"corr.dat\",\n                         \"corr.sim\",\n                         \"p.vals\")\n\n    ## isolate thresholds for plot:\n    THRESH <- list()\n    for(n in 1:length(sig.list[[j]])){\n      THRESH[[n]] <- sig.list[[j]][[n]]$sig.thresh\n    }\n    names(THRESH) <- names(sig.list[[j]])\n    thresholds[[j]] <- THRESH\n\n\n    ##########################\n    ## NEW: MANHATTAN PLOT! ##\n    ##########################\n    if(plot.manhattan == TRUE){\n\n      ## save next plot:\n      if(!is.null(filename.plot)){\n        if(length(filename.plot) == length(sig.list)){\n          if(class(filename.plot) != \"list\") filename.plot <- as.list(filename.plot)\n\n          ## save whatever plots before dev.off:\n          pdf(file=filename.plot[[j]][1], width=7, height=11)\n        }\n      }\n\n\n      manhattan.plot(p.vals = sig.list[[j]][[1]]$corr.dat,\n                     col = \"wasp\",\n                     transp = 0.75,\n                     sig.thresh = THRESH,\n                     thresh.col=\"seasun\",\n                     snps.assoc = snps.assoc,\n                     snps.assoc.col = \"red\",\n                     jitter.amount = 0.00001,\n                     min.p = NULL,\n                     log10=FALSE,\n                     ylab=paste(TEST[[j]], \"score\", sep=\" \"))\n\n      ## End saving:\n      ## CHECK-- Do we need if statements??\n      dev.off() ## Not sure what happens if you run this without having used pdf or dev.copy previously..\n\n\n      ####\n      ## NOTE-- if you want to see the plot, you need to plot it again (dev.copy not working consistently!)\n      manhattan.plot(p.vals = sig.list[[j]][[1]]$corr.dat,\n                     col = \"wasp\",\n                     transp = 0.75,\n                     sig.thresh = THRESH,\n                     thresh.col=\"seasun\",\n                     snps.assoc = snps.assoc,\n                     snps.assoc.col = \"red\",\n                     jitter.amount = 0.00001,\n                     min.p = NULL,\n                     log10=FALSE,\n                     ylab=paste(TEST[[j]], \"score\", sep=\" \"))\n\n      # ## save plot:\n      # if(!is.null(filename.plot)){\n      #   if(length(filename.plot) == length(sig.list)){\n      #     if(class(filename.plot) != \"list\") filename.plot <- as.list(filename.plot)\n      #     dev.copy(pdf, file=filename.plot[[j]][1], width=7, height=11) # , pointsize=12\n      #     dev.off()\n      #   }\n      # } # end save pdf\n\n    } # end plot.manhattan\n\n\n    ########################################################\n    ## Plot the null distribution w thresholds & findings ##\n    ########################################################\n\n    ## NOTE: For simplicity & clarity, only plotting truly significant SNPs,\n    ## instead of plotting all findings from all tests/thresholds.\n\n\n    ## save next plot:\n    if(!is.null(filename.plot)){\n      if(length(filename.plot) == length(sig.list)){\n        if(class(filename.plot) != \"list\") filename.plot <- as.list(filename.plot)\n\n        if(length(filename.plot[[j]]) > 1){\n          pdf(file=filename.plot[[j]][2], width=7, height=11) # , pointsize=12\n        }else{\n          pdf(file=filename.plot[[j]][1], width=7, height=11) # , pointsize=12\n        }\n      }\n    }\n\n    ## Generate one histogram per test:\n    plot.sig.snps(corr.dat = sig.list[[j]][[1]]$corr.dat,\n                  corr.sim = sig.list[[j]][[1]]$corr.sim,\n                  corr.sim.subset = sig.list[[j]][[1]]$corr.sim[1:10000],\n                  sig.corrs = corr.dat[snps.assoc],\n                  sig.snps = snps.assoc,\n                  sig.thresh = unique(round(as.vector(unlist(THRESH)), 2)),\n                  test = TEST[[j]],\n                  sig.snps.col = \"blue\",\n                  hist.col = rgb(0,0,1,0.5), # rgb(0,0,1,0.5) # blue ## OR ## rgb(0.1,0.1,0.1,0.5) # darkgrey\n                  hist.subset.col = rgb(1,0,0,0.5), # rgb(1,0,0,0.5) # red ## OR ## rgb(0.8,0.8,0.8,0.5) # lightgrey\n                  thresh.col = \"red\",\n                  snps.assoc = snps.assoc,\n                  snps.assoc.col = \"black\",\n                  bg = \"lightgrey\",\n                  grid = TRUE,\n                  plot.null.dist = TRUE,\n                  plot.dist = FALSE)\n\n    ## End saving:\n    dev.off()\n\n\n\n\n    #####\n    ## Again-- to see this plot as simTest runs, need to plot again bc dev.copy failing/corrupting at random...\n    plot.sig.snps(corr.dat = sig.list[[j]][[1]]$corr.dat,\n                  corr.sim = sig.list[[j]][[1]]$corr.sim,\n                  corr.sim.subset = sig.list[[j]][[1]]$corr.sim[1:10000],\n                  sig.corrs = corr.dat[snps.assoc],\n                  sig.snps = snps.assoc,\n                  sig.thresh = unique(round(as.vector(unlist(THRESH)), 2)),\n                  test = TEST[[j]],\n                  sig.snps.col = \"blue\",\n                  hist.col = rgb(0,0,1,0.5), # rgb(0,0,1,0.5) # blue ## OR ## rgb(0.1,0.1,0.1,0.5) # darkgrey\n                  hist.subset.col = rgb(1,0,0,0.5), # rgb(1,0,0,0.5) # red ## OR ## rgb(0.8,0.8,0.8,0.5) # lightgrey\n                  thresh.col = \"red\",\n                  snps.assoc = snps.assoc,\n                  snps.assoc.col = \"black\",\n                  bg = \"lightgrey\",\n                  grid = TRUE,\n                  plot.null.dist = TRUE,\n                  plot.dist = FALSE)\n\n    # ## save plot:\n    # if(!is.null(filename.plot)){\n    #   if(length(filename.plot) == length(sig.list)){\n    #     if(class(filename.plot) != \"list\") filename.plot <- as.list(filename.plot)\n    #     if(length(filename.plot[[j]]) > 1){\n    #       dev.copy(pdf, file=filename.plot[[j]][2], width=7, height=11) # , pointsize=12\n    #     }else{\n    #       dev.copy(pdf, file=filename.plot[[j]][1], width=7, height=11) # , pointsize=12\n    #     }\n    #     dev.off()\n    #   }\n    # } # edn save pdf\n\n\n    ## legend for thresholds? ##\n\n  for(i in 1:length(sig.list[[j]])){\n\n    #############################################\n    ## isolate elements of get.sig.snps output ##\n    #############################################\n\n    corr.dat <- sig.list[[j]][[i]]$corr.dat\n    corr.sim <- sig.list[[j]][[i]]$corr.sim\n    p.vals <- sig.list[[j]][[i]]$p.vals\n    sig.snps.names <- sig.list[[j]][[i]]$sig.snps.names\n    sig.snps <- sig.list[[j]][[i]]$sig.snps\n    sig.corrs <- sig.list[[j]][[i]]$sig.corrs\n    sig.p.vals <- sig.list[[j]][[i]]$sig.p.vals\n    min.p <- sig.list[[j]][[i]]$min.p\n    sig.thresh <- sig.list[[j]][[i]]$sig.thresh\n\n    ########################################\n\n\n    ##################################\n    ## 4) (A) Plot the distribution ##\n    ##################################\n\n    # plot.sig.snps(corr.dat, corr.sim, sig.corrs, sig.snps,\n    #               sig.thresh=sig.thresh, test=TEST[[j]],\n    #               plot.null.dist = plot.null.dist,\n    #               plot.dist = plot.dist)\n\n\n    ########################################\n    ## 5) Return results list ##############\n    ########################################\n\n    if(length(sig.snps)==0) sig.snps <- sig.corrs <- NULL\n\n    ###########\n    ## make a data.frame containing all relevant output for sig.snps\n    if(length(sig.snps) > 0){\n\n      ## Get counts for n.sig.snps in each cell of the contingency table:\n      #     toKeep <- sapply(c(1:length(sig.snps)),\n      #                      function(e)\n      #                        which(dimnames(snps)[[2]] == sig.snps))\n      toKeep <- sig.snps\n      snps.toKeep <- snps[,toKeep]\n\n      ##\n      if(length(toKeep) > 1){\n        S1P1 <- sapply(c(1:ncol(snps.toKeep)),\n                       function(e)\n                         length(which(snps.toKeep[which(phen==1),e]==1)))\n        S0P0 <- sapply(c(1:ncol(snps.toKeep)),\n                       function(e)\n                         length(which(snps.toKeep[which(phen==0),e]==0)))\n        S1P0 <- sapply(c(1:ncol(snps.toKeep)),\n                       function(e)\n                         length(which(snps.toKeep[which(phen==0),e]==1)))\n        S0P1 <- sapply(c(1:ncol(snps.toKeep)),\n                       function(e)\n                         length(which(snps.toKeep[which(phen==1),e]==0)))\n      }else{\n        ## if only ONE sig snp (haploid) identified:\n        S1P1 <- length(which(snps.toKeep[which(phen==1)]==1))\n        S0P0 <- length(which(snps.toKeep[which(phen==0)]==0))\n        S1P0 <- length(which(snps.toKeep[which(phen==0)]==1))\n        S0P1 <- length(which(snps.toKeep[which(phen==1)]==0))\n\n      }\n      df <- data.frame(sig.snps,\n                       sig.p.vals,\n                       sig.corrs,\n                       S1P1, S0P0, S1P0, S0P1)\n      names(df) <- c(\"SNP.locus\",\n                     \"p.value\",\n                     \"Test.statistic\",\n                     \"S1P1\", \"S0P0\", \"S1P0\", \"S0P1\")\n\n      ## NOTE: Could return sig.snps.names somewhere here\n      ## in addition to sig.snps loci ####    ####    ####    ####\n\n    }else{\n      df <- \"No significant SNPs found.\"\n    }\n\n    ## 0 p.vals\n    #   min.p <- paste(\"p-values listed as 0 are <\",\n    #                  1/length(corr.sim), sep=\" \")\n    min.p <- 1/length(corr.sim)\n    names(min.p) <- c(\"p-values listed as 0 are less than:\")\n\n    ## TO DO:\n    ## ADD MANHATTAN PLOT\n\n    results <- list()\n    results[[1]] <- sig.thresh\n    results[[2]] <- df\n    results[[3]] <- min.p\n\n    names(results) <- c(\"sig.thresh\",\n                        \"sig.snps\",\n                        \"min.p.value\")\n\n    RES[[j]][[i]] <- results\n  } # end for loop (i)\n\n    names(RES[[j]]) <- names(sig.list[[j]])\n\n  } # end for loop (j)\n\n  ## assign test names to main list components:\n  names(RES) <- names(VALS) <- test\n\n  ## get data:\n  DAT <- list(snps.sim = snps.sim.complete,\n              snps.rec = snps.rec.complete,\n              snps.sim.rec = snps.sim.rec.complete,\n              phen.rec = phen.rec)\n\n  ## get output:\n  results <- list(dat=DAT,\n                  vals=VALS,\n                  thresh=thresholds,\n                  res=RES,\n                  SCORE3=SCORE3)\n\n  return(results)\n\n} # end treeWAS\n\n\n\n\n##############################################################################################\n## legend (temporary?)\n## Not necessarily needed--usually only a couple UNIQUE thresholds...\n#     par(mfrow=c(1,2))\n#     par(oma = c(5,4,0,0) + 0.1)\n#     par(mar = c(0,0,1,1) + 0.1)\n#     ## column 1:\n#     midpoints1 <- barplot(rep(10, length(THRESH)/2),\n#                         col = seasun(length(THRESH))[1:(length(THRESH)/2)],\n#                         horiz=TRUE)\n#     ##overlay names:\n#     text(3, midpoints1, labels=names(THRESH)[1:(length(THRESH)/2)], cex=0.75, adj=0.3)\n#\n#     ## column 2:\n#     midpoints2 <- barplot(rep(10, length(THRESH)/2),\n#                           col = seasun(length(THRESH))[((length(THRESH)/2)+1):length(THRESH)],\n#                           horiz=TRUE)\n#     ##overlay names:\n#     text(3, midpoints2, labels=names(THRESH)[((length(THRESH)/2)+1):length(THRESH)], cex=0.75, adj=0.3)\n#\n#     ## return to original par settings:\n#     par(mfrow=c(1,1))\n#\n#     ## add title\n#     title(\"Legend: Significance Thresholds\")\n#\n#     par(oma=c(0,0,0,0))\n#     par(mar=c(5,4,4,2)+0.1)\n##############################################################################################\n\n\n\n# ## only 2 unique sets of p.vals for each test\n# ## (for n.snps & 10x n.snps):\n# pv <- list()\n# summ <- list()\n# for(j in 1:length(results)){\n#   pv[[j]] <- list()\n#   summ[[j]] <- list()\n# for(i in 1:length(results[[j]])){\n#   pv[[j]][[i]] <- results[[j]][[i]]$p.vals\n#   summ[[j]][[i]] <- summary(pv[[j]][[i]])\n# }\n# }\n#\n# length(unique(summ[[2]]))\n# length(unique(summ[[2]][seq(2, length(summ[[3]]), 2)]))\n# length(unique(summ[[2]][seq(2, length(summ[[3]]), 2)]))\n\n\n\n\n###############\n## CHECK!!!! ##\n###############\n## w assoc.prob == 100, still getting low/0(!) scores for \"snps.assoc\"\n## get original phen for all terminal + internal nodes and edges...\n\n## checking simultaneous score:\n\n# str(foo)\n# phen.str <- foo$phen.plot.col\n# phen1 <- foo$phen\n# phen2 <- phen.str$all.nodes\n#\n# head(phen1, 20)\n# head(phen2, 20)\n#\n# phen2[which(phen2 == \"blue\")] <- \"A\"\n# phen2[which(phen2 == \"red\")] <- \"B\"\n# phen2 <- as.factor(phen2)\n# names(phen2) <- paste(\"ind\", 1:length(phen2), sep=\".\")\n#\n# phen.edges <- phen.str$edges\n# phen.edges[which(phen.edges == \"blue\")] <- \"A\"\n# phen.edges[which(phen.edges == \"red\")] <- \"B\"\n# # phen.edges[which(phen.edges == \"green\")] <- \"C\"\n# phen.edges <- as.factor(phen.edges)\n# names(phen.edges) <- paste(\"ind\", 1:length(phen.edges), sep=\".\")\n# head(phen.edges)\n#\n# ## which edges should/do contain phen subs?\n# which(phen.edges == \"green\")\n# ## run relevant code in reconstruct to get phen.subs.edges list (to see which edges are identified):\n# phen.subs.edges$total\n#\n# snps.diffs <- list()\n# snps.assoc.index <- index[snps.assoc] ## GAK! -- all snps.assoc have the same index (915)! set.seed problem, for a start...\n# for(i in snps.assoc.index){\n#   snps.diffs[[i]] <- get.branch.diffs(var = snps.rec[,i],\n#                                       edges = edges)\n# }\n# which(abs(snps.diffs[[i]]) == 1)\n# ## ALSO--important to NOTE that a lot of the reconstructed edges are only off by one...\n# ## (thus should the subsequent score not be doing much better????)\n# length(which(which(abs(snps.diffs[[i]]) == 1) %in% phen.subs.edges$total)) ## SO Shouldn't the max corr.dat score2 be 11????\n\n###############\n## CHECK!!!! ##\n###############\n## The FPR for Score 2 (simultaneous) should NOT be that high-- something wrong with the threshold selection??\n#\n# snps.assoc.ori.ori <- snps.assoc\n#\n# sim.dat <- sim.dat.ori <- results$dat$simultaneous\n# corr.dat <- corr.dat.ori <- sim.dat$corr.dat\n# corr.sim <- corr.sim.ori <- sim.dat$corr.sim\n# p.vals <- p.vals.ori <- sim.dat$p.vals\n#\n# sim.res <- sim.res.ori <- results$res$simultaneous\n# str(sim.res[[1]])\n# str(sim.res[[32]])\n# thresh.ori <- thresh <- sim.res[[1]]$sig.thresh\n# thresh.ori <- thresh <- sim.res[[32]]$sig.thresh\n#\n# table(corr.sim)\n#\n# hist(corr.sim)\n# lines(density(corr.sim), col=\"red\", lwd=2)\n#\n# str(density(corr.sim))\n#\n# ## with first 10000 only??\n# corr.sim.ori <- corr.sim\n# corr.sim <- corr.sim.ori[1:10000]\n# table(corr.sim)\n\n\n\n# ###\n#\n# t.corr.sim <- results$dat$terminal$corr.sim\n#\n# ########################\n# ## get density curve: ##\n# ########################\n#\n# ## SIMULTANEOUS SCORE: ##\n# dat <- corr.sim[1:10000]\n# d <- density(dat)\n# # from=0 may be necessary for aligning polygon w hsit alon x-axis, BUT may cause problems for polygon drawing (try lines instead?)\n# xmax <- max(hist(dat)$mids)+min(hist(dat)$mids)\n# ymax <- ceiling(max(d$y))\n# hist(dat, freq=F, xlim=c(0,xmax), ylim=c(0,ymax))\n# # lines(d, col=\"red\", lwd=2, xlim=c(0,1), ylim=c(0,ymax))\n# polygon(d, col=transp(\"red\", 0.25), border=\"red\", lwd=2, xlim=c(0,xmax), ylim=c(0,ymax))\n#\n# ## TERMINAL SCORE ##\n# dat <- t.corr.sim\n# d <- density(dat, from=0)\n# ymax <- ceiling(max(d$y))\n# hist(dat, freq=F, xlim=c(0,1), ylim=c(0,ymax))\n# # lines(d, col=\"red\", lwd=2, xlim=c(0,1), ylim=c(0,ymax))\n# polygon(d, col=transp(\"red\", 0.25), border=\"red\", lwd=2, xlim=c(0,1), ylim=c(0,ymax))\n\n\n###\n\n\n\n\n###\n",
    "created" : 1474604608584.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "28317894",
    "id" : "DE3FEDEB",
    "lastKnownWriteTime" : 1473277705,
    "last_content_update" : 1473277705,
    "path" : "D:/treeWAS/pkg/R/treeWAS.eval.R",
    "project_path" : "R/treeWAS.eval.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}