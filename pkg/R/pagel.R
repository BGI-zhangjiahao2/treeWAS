

################
## Pagel 1994 ##
################

#######################
## Example w my data ##
#######################

data("snps.ace")
data("phen.ace")
data("tree.ace")
snps <- snps.ace
phen <- phen.ace
tree <- tree.ace

## Attempt w SNP1 ##
var <- snps[,1]

x <- var
y <- phen

fit.ape<-fitPagel(tree,x,y, method="ace") # warnings OK (?? if perfectly correlated only??)
fit.ape

fit.Mk<-fitPagel(tree,x,y, method="fitMk")
fit.Mk

## Not sure why this one is giving me p-values of 1 and disagreeing w ape's ace...??
fit.geiger<-fitPagel(tree,x,y,method="fitDiscrete") # warnings OK
fit.geiger

###############

n.ind <- 100

set.seed(1)
tree <- pbtree(n=n.ind, scale=1)


################
## get.n.subs ##
################

## identify the n.subs generated by sim.history
## if the transition rate matrix Q is -1, 1, 1, -1 divided by n.

## HYPOTHESIS:
## Setting n to sum(tree$edge.length) should make
## the expected value of n.subs to be 1 sub per tree...

## EG:
# foo <- replicate(100, get.n.subs(sum(tree$edge.length)))
# hist(foo)
# summary(foo)

get.n.subs <- function(n){
  Q <- matrix(c(-1/n, 1/n, 1/n, -1/n), 2, 2)
  rownames(Q) <- colnames(Q) <- letters[1:2]
  tt1 <- sim.history(tree, Q)
  ## Done simulation(s).

  maps <- tt1$maps
  n.subs <- length(as.vector(unlist(maps)))-length(maps)
  return(n.subs)
} # end get.n.subs


## plot
#library(adegenet)
#par(mfrow=c(1,1))
plotSimmap(tt1,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1)
edgelabels(c(1:nrow(tree$edge)), cex=0.5, bg=transp("yellow", 0.3))

# states <- list()
# for(i in 1:length(maps)){
#   states[[i]] <- names(maps[[i]])
# }

# subs <- list()
# subs[[1]] <- length(states[[1]])-1
# for(i in 2:length(states)){
#   anc <- states[[i-1]]
#   dec <- states[[i]]
#
#   ## If first or only state in dec
#   ## is the same as the last or only state of anc,
#   ## do not add this maintained state to the tally of subs:
#   if(dec[1] == anc[length(anc)]){
#     subs[[i]] <- length(dec)-1
#   }else{
#     ## If a mt has occurred btw anc and dec,
#     ## add this to the tally, in addition to length(dec):
#     subs[[i]] <- length(dec)
#   }
# }
#
# subs
# sum(as.vector(unlist(subs)))

# subs <- list()
# subs[[1]] <- length(states[[1]])-1
# for(i in 2:length(states)){
#   anc <- states[[i-1]]
#   dec <- states[[i]]
#
#   ## If first or only state in dec
#   ## is the same as the last or only state of anc,
#   ## do not add this maintained state to the tally of subs:
#   if(dec[1] == anc[length(anc)]){
#     subs[[i]] <- length(dec)-1
#   }else{
#     ## If a mt has occurred btw anc and dec,
#     ## add this to the tally, in addition to length(dec):
#     subs[[i]] <- length(dec)
#   }
# }
#
# subs
# sum(as.vector(unlist(subs)))

# subs <- list()
# for(i in 1:nrow(tree$edge)){
#   anc <- states[[tree$edge[i,1]]]
#   dec <- states[[tree$edge[i,2]]]
#
#   ## If first or only state in dec
#   ## is the same as the last or only state of anc,
#   ## do not add this maintained state to the tally of subs:
#   if(dec[1] == anc[length(anc)]){
#     if(i == 1){
#       subs[[i]] <- sum((length(anc)-1), (length(dec)-1))
#     }else{
#       subs[[i]] <- length(dec)-1
#     }
#   }else{
#     ## If a mt has occurred btw anc and dec,
#     ## add this to the tally, in addition to length(dec):
#     if(i == 1){
#       subs[[i]] <- sum((length(anc)-1), (length(dec)-1))
#     }else{
#       subs[[i]] <- length(dec)-1
#     }
#   }
# }

tt2<-sim.history(tree,Q)
## Done simulation(s).

## these are uncorrelated, see:
par(mfrow=c(1,2))
plotSimmap(tt1,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1)
plotSimmap(tt2,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1,direction="leftwards")

###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###   ###

fitMk<-function(tree,x,model="SYM",fixedQ=NULL,...){
  if(hasArg(output.liks)) output.liks<-list(...)$output.liks
  else output.liks<-FALSE
  N<-Ntip(tree)
  M<-tree$Nnode
  if(is.matrix(x)){
    x<-x[tree$tip.label,]
    m<-ncol(x)
    states<-colnames(x)
  } else {
    ##############
    ## CC EDITS ##
    ##############

    ## issue: if x variable is a factor with N levels,
    ## and the model (eg. as created within fitPagel) is based on all N levels
    ## BUT some of these levels are empty in x,
    ## fitMk complains that model does not have the right number of columns.

    ## soln: adding empty level to matrix x.

    if(is.factor(x) && any(table(x) == 0)){
      ## identify empty level(s):
      levels.x <- levels(x)
      missing <- which(table(x) == 0)
      ## make matrix of input x:
      x<-to.matrix(x,sort(unique(x)))
      ## make dummy matrix, bind x matrix and empty columns:
      mat <- matrix(NA, nrow=nrow(x), ncol=length(levels.x))
      mat[, c(1:length(levels.x))[-missing]] <- x
      mat[, missing] <- rep(0, nrow(x))
      colnames(mat) <- levels.x
      rownames(mat) <- rownames(x)
      x <- mat
      x<-x[tree$tip.label,]
      m<-ncol(x)
      states<-colnames(x)

    }else{
      ## make matrix of input x:
      x<-to.matrix(x,sort(unique(x)))
    } ############## # end CC edits

    x<-x[tree$tip.label,]
    m<-ncol(x)
    states<-colnames(x)
  }
  if(hasArg(pi)) pi<-list(...)$pi
  else pi<-"equal"
  if(pi[1]=="equal") pi<-setNames(rep(1/m,m),states)
  else if(pi[1]=="estimated"){
    pi<-if(!is.null(fixedQ)) statdist(fixedQ) else statdist(summary(fitMk(tree,x,model),quiet=TRUE)$Q)
    cat("Using pi estimated from the stationary distribution of Q assuming a flat prior.\npi =\n")
    print(round(pi,6))
    cat("\n")
  }
  else pi<-pi/sum(pi)
  if(is.null(fixedQ)){
    if(is.character(model)){
      rate<-matrix(NA,m,m)
      if(model=="ER"){
        k<-rate[]<-1
        diag(rate)<-NA
      } else if(model=="ARD"){
        k<-m*(m-1)
        rate[col(rate)!=row(rate)]<-1:k
      } else if(model=="SYM"){
        k<-m*(m-1)/2
        ii<-col(rate)<row(rate)
        rate[ii]<-1:k
        rate<-t(rate)
        rate[ii]<-1:k
      }
    } else {
      if(ncol(model)!=nrow(model))
        stop("model is not a square matrix")
      if(ncol(model)!=ncol(x))
        stop("model does not have the right number of columns")
      rate<-model
      k<-max(rate)
    }
    Q<-matrix(0,m,m)
  } else {
    rate<-matrix(NA,m,m)
    k<-m*(m-1)
    rate[col(rate)!=row(rate)]<-1:k
    Q<-fixedQ
  }
  index.matrix<-rate
  tmp<-cbind(1:m,1:m)
  rate[tmp]<-0
  rate[rate==0]<-k+1
  liks<-rbind(x,matrix(0,M,m,dimnames=list(1:M+N,states)))
  pw<-reorder(tree,"pruningwise")
  lik<-function(pp,output.liks=FALSE,pi){
    if(any(is.nan(pp))||any(is.infinite(pp))) return(1e50)
    comp<-vector(length=N+M,mode="numeric")
    Q[]<-c(pp,0)[rate]
    diag(Q)<--rowSums(Q)
    parents<-unique(pw$edge[,1])
    root<-min(parents)
    for(i in 1:length(parents)){
      anc<-parents[i]
      ii<-which(pw$edge[,1]==parents[i])
      desc<-pw$edge[ii,2]
      el<-pw$edge.length[ii]
      v<-vector(length=length(desc),mode="list")
      for(j in 1:length(v))
        v[[j]]<-matexpo(Q*el[j])%*%liks[desc[j],]
      vv<-if(anc==root) Reduce('*',v)[,1]*pi else Reduce('*',v)[,1]
      comp[anc]<-sum(vv)
      liks[anc,]<-vv/comp[anc]
    }
    if(output.liks)return(liks[1:M+N,,drop=FALSE])
    logL<--sum(log(comp[1:M+N]))
    return(if(is.na(logL)) Inf else logL)
  }
  if(is.null(fixedQ)){
    fit<-nlminb(rep(0.1,k),function(p) lik(p,pi=pi),lower=rep(0,k),upper=rep(1e50,k))
    obj<-list(logLik=-fit$objective,
              rates=fit$par,
              index.matrix=index.matrix,
              states=states,
              pi=pi)
    if(output.liks) obj$lik.anc<-lik(obj$rates,TRUE,pi=pi)
  } else {
    fit<-lik(Q[sapply(1:k,function(x,y) which(x==y),index.matrix)],pi=pi)
    obj<-list(logLik=-fit,
              rates=Q[sapply(1:k,function(x,y) which(x==y),index.matrix)],
              index.matrix=index.matrix,
              states=states,
              pi=pi)
    if(output.liks) obj$lik.anc<-lik(obj$rates,TRUE,pi=pi)
  }
  class(obj)<-"fitMk"
  return(obj)
}

## print method for objects of class "fitMk"
print.fitMk<-function(x,digits=6,...){
  cat("Object of class \"fitMk\".\n\n")
  cat("Fitted (or set) value of Q:\n")
  Q<-matrix(NA,length(x$states),length(x$states))
  Q[]<-c(0,x$rates)[x$index.matrix+1]
  diag(Q)<-0
  diag(Q)<--rowSums(Q)
  colnames(Q)<-rownames(Q)<-x$states
  print(round(Q,digits))
  cat("\nFitted (or set) value of pi:\n")
  print(x$pi)
  cat(paste("\nLog-likelihood:",round(x$logLik,digits),"\n\n"))
}

## summary method for objects of class "fitMk"
summary.fitMk<-function(object,...){
  if(hasArg(digits)) digits<-list(...)$digits
  else digits<-6
  if(hasArg(quiet)) quiet<-list(...)$quiet
  else quiet<-FALSE
  if(!quiet) cat("Fitted (or set) value of Q:\n")
  Q<-matrix(NA,length(object$states),length(object$states))
  Q[]<-c(0,object$rates)[object$index.matrix+1]
  diag(Q)<-0
  diag(Q)<--rowSums(Q)
  colnames(Q)<-rownames(Q)<-object$states
  if(!quiet) print(round(Q,digits))
  if(!quiet) cat(paste("\nLog-likelihood:",round(object$logLik,digits),"\n\n"))
  invisible(list(Q=Q,logLik=object$logLik))
}

## logLik method for objects of class "fitMk"
logLik.fitMk<-function(object,...) object$logLik

## AIC method
AIC.fitMk<-function(object,...,k=2){
  np<-length(object$rates)
  -2*logLik(object)+np*k
}


fitPagel<-function(tree,x,y,method="fitMk",...){
  if(!inherits(tree,"phylo")) stop("tree should be object of class \"phylo\".")
  if(method=="fitDiscrete"){
    chk<-.check.pkg("geiger")
    if(!chk){
      cat("  method = \"fitDiscrete\" requires the package \"geiger\"\n")
      cat("  Defaulting to method = \"fitMk\"\n\n")
      method<-"fitMk"
      fitDiscrete<-function(...) NULL
    }
  }
  if(!is.factor(x)) x<-as.factor(x)
  levels.x<-levels(x)
  if(!is.factor(y)) y<-as.factor(y)
  levels.y<-levels(y)
  y<-y[names(x)]
  if(length(levels.x)!=2||length(levels.y)!=2)
    stop("Only binary characters for x & y currently permitted.")
  xy<-setNames(factor(paste(x,y,sep="|"),
                      levels=sapply(levels.x,paste,levels.y,sep="|")),
               names(x))
  ## fit independent model
  iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
  rownames(iQ)<-colnames(iQ)<-levels(xy)
  fit.iQ<-if(method=="fitDiscrete") fitDiscrete(tree,xy,model=iQ,...)
  else if(method=="ace") ace(xy,tree,type="discrete",model=iQ,...)
  else fitMk(tree,xy,model=iQ,...)
  ## fit dependendent model
  dQ<-matrix(c(0,1,2,0,3,0,0,4,5,0,0,6,0,7,8,0),4,4,byrow=TRUE)
  rownames(dQ)<-colnames(dQ)<-levels(xy)
  fit.dQ<-if(method=="fitDiscrete") fitDiscrete(tree,xy,model=dQ,...)
  else if(method=="ace") ace(xy,tree,type="discrete",model=dQ,...)
  else fitMk(tree,xy,model=dQ,...)
  ## back translate independent model
  if(method=="fitDiscrete") iQ<-.Qmatrix.from.gfit(fit.iQ)
  else {
    I<-fit.iQ$index.matrix
    I[I==0]<-NA
    iQ<-apply(I,2,function(i,x) x[i],x=fit.iQ$rates)
    iQ[is.na(iQ)]<-0
    diag(iQ)<--rowSums(iQ)
    rownames(iQ)<-colnames(iQ)
  }
  ## dependent model
  if(method=="fitDiscrete") dQ<-.Qmatrix.from.gfit(fit.dQ)
  else {
    I<-fit.dQ$index.matrix
    I[I==0]<-NA
    dQ<-apply(I,2,function(i,x) x[i],x=fit.dQ$rates)
    dQ[is.na(dQ)]<-0
    diag(dQ)<--rowSums(dQ)
    rownames(dQ)<-colnames(dQ)
  }
  ## assemble object to return
  obj<-list(independent.Q=iQ,
            dependent.Q=dQ,
            independent.logL=logLik(fit.iQ),
            dependent.logL=logLik(fit.dQ),
            lik.ratio=2*(logLik(fit.dQ)-logLik(fit.iQ)),
            P=pchisq(2*(logLik(fit.dQ)-logLik(fit.iQ)),
                     df=length(levels(x))+length(levels(y)),
                     lower.tail=FALSE),
            method=method)
  class(obj)<-"fitPagel"
  obj
}

## print method for objects of class "fitPagel"
## written by Liam J. Revell 2014

print.fitPagel<-function(x,...){
  cat("\n  Pagel's binary character correlation test:\n")
  cat("\nIndependent model rate matrix:\n")
  print(x$independent.Q)
  cat("\nDependent model rate matrix:\n")
  print(x$dependent.Q)
  cat("\nModel fit:\n")
  obj<-matrix(c(x$independent.logL,x$dependent.logL),2,1)
  rownames(obj)<-c("independent","dependent")
  colnames(obj)<-"log-likelihood"
  print(obj)
  cat("\nHypothesis test result:\n")
  cat(paste("  likelihood-ratio: ",signif(x$lik.ratio,7),"\n"))
  cat(paste("  p-value: ",signif(x$P,7),"\n"))
  cat(paste("\nModel fitting method used was",x$method,"\n\n"))
}

## function borrowed from geiger to pull the Q-matrix from a fit returned by fitDiscrete

.Qmatrix.from.gfit<-function(x){
  if(!.check.pkg("geiger")) argn<-function(...) NULL
  lik=x$lik
  numberize=function(x){
    y=gsub("q","",x)
    sp=(nn<-nchar(y))/2
    as.numeric(c(substring(y,1,sp),substring(y,sp+1,
                                             nn)))
  }
  att=attributes(lik)
  att$k=length(att$levels)
  Qmat=matrix(0,att$k,att$k)
  nms=att$argn[att$trns]
  other=att$argn[!att$trns]
  if("constrained"%in%class(lik)){
    cpars=x$opt[argn(lik)]
    apars=names(lik(unlist(cpars),pars.only=TRUE))
    nms=apars[!apars%in%other]
  }
  trns=x$opt[nms]
  for(i in 1:length(trns)){
    nm=names(trns)[i]
    idx=numberize(nm)
    Qmat[idx[1],idx[2]]=trns[[i]]
  }
  diag(Qmat)=-rowSums(Qmat)
  rownames(Qmat)<-colnames(Qmat)<-levels(lik)
  Qmat
}

## BELOW NOW IN PHYTOOLS (?!) ######################################################################



##################################################################################
## EXAMPLE FROM: #################################################################
##################################################################################
## http://blog.phytools.org/2014/12/r-function-for-pagels-1994-correlation.html ##
##################################################################################

## first load packages & source code
library(phytools)
library(geiger)
# source("fitPagel.R")
.check.pkg<-phytools:::.check.pkg

##################
## UNcorrelated ##
##################

set.seed(1)
## now let's simulate some uncorrelated data
tree<-pbtree(n=300,scale=1)
Q<-matrix(c(-1,1,1,-1),2,2)
rownames(Q)<-colnames(Q)<-letters[1:2]
tt1<-sim.history(tree,Q)
## Done simulation(s).

tt2<-sim.history(tree,Q)
## Done simulation(s).

## these are uncorrelated, see:
par(mfrow=c(1,2))
plotSimmap(tt1,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1)
plotSimmap(tt2,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1,direction="leftwards")


## run Pagel's binary character correlation test:
x<-tt1$states
y<-tt2$states

fit.ape<-fitPagel(tree,x,y, method="ace")
fit.ape

fit.Mk <- fitPagel(tree, x, y, method="fitMk")
fit.Mk

fit.geiger<-fitPagel(tree,x,y,method="fitDiscrete") # warnings OK
fit.geiger


################
## CORRELATED ##
################

Q<-matrix(c(0,0.5,0.5,0,2,0,0,2,2,0,0,2,0,0.5,0.5,0),4,4,byrow=TRUE)
rownames(Q)<-colnames(Q)<-c("aa","ab","ba","bb")
diag(Q)<--rowSums(Q)
tt<-sim.history(tree,t(Q))

tt1<-mergeMappedStates(tt,c("aa","ab"),"a")
tt1<-mergeMappedStates(tt1,c("ba","bb"),"b")
tt2<-mergeMappedStates(tt,c("aa","ba"),"a")
tt2<-mergeMappedStates(tt2,c("ab","bb"),"b")

## these data are correlated, see:
par(mfrow=c(1,2))
plotSimmap(tt1,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1)
plotSimmap(tt2,setNames(c("blue","red"),letters[1:2]),ftype="off",lwd=1,direction="leftwards")

x<-getStates(tt1,"tips")
y<-getStates(tt2,"tips")

fit.ape<-fitPagel(tree,x,y, method="ace")
fit.ape

fit.Mk <- fitPagel(tree, x, y, method="fitMk")
fit.Mk

fit.geiger<-fitPagel(tree,x,y,method="fitDiscrete") # warnings OK
fit.geiger




##################################################################################
## FUNCTIONS FROM: ###############################################################
##################################################################################
## http://blog.phytools.org/2014/12/r-function-for-pagels-1994-correlation.html ##
## Posted here: http://www.phytools.org/fitPagel/v0.1/fitPagel.R #################
##################################################################################

## function fits Pagel '94 model of correlated evolution of two binary characters
## uses ape::ace or geiger::fitDiscrete internally
## written by Liam J. Revell 2014

fitPagel<-function(tree,x,y,...){
  if(hasArg(method)) method<-list(...)$method
  else method<-"ace"
  if(method=="fitDiscrete"){
    chk<-.check.pkg("geiger")
    if(!chk){
      cat("  method = \"fitDiscrete\" requires the package \"geiger\"\n")
      cat("  Defaulting to method = \"ace\"\n\n")
      method<-"ace"
      fitDiscrete<-function(...) NULL
    }
  }
  if(!is.factor(x)) x<-as.factor(x)
  levels.x<-levels(x)
  if(!is.factor(y)) y<-as.factor(y)
  levels.y<-levels(y)
  y<-y[names(x)]
  if(length(levels.x)!=2||length(levels.y)!=2)
    stop("Only binary characters for x & y currently permitted.")
  xy<-setNames(factor(paste(x,y,sep="|"),
                      levels=sapply(levels.x,paste,levels.y,sep="|")),
               names(x))
  ## fit independent model
  iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
  rownames(iQ)<-colnames(iQ)<-levels(xy)
  fit.iQ<-if(method=="fitDiscrete") fitDiscrete(tree,xy,model=iQ) else ace(xy,tree,type="discrete",model=iQ)
  ## fit dependendent model
  dQ<-matrix(c(0,1,2,0,3,0,0,4,5,0,0,6,0,7,8,0),4,4,byrow=TRUE)
  rownames(dQ)<-colnames(dQ)<-levels(xy)
  fit.dQ<-if(method=="fitDiscrete") fitDiscrete(tree,xy,model=dQ) else ace(xy,tree,type="discrete",model=dQ)
  ## back translate independent model
  if(method=="fitDiscrete") iQ<-geiger:::.Qmatrix.from.gfit(fit.iQ)
  else {
    I<-fit.iQ$index.matrix
    I[I==0]<-NA
    iQ<-apply(I,2,function(i,x) x[i],x=fit.iQ$rates)
    iQ[is.na(iQ)]<-0
    diag(iQ)<--rowSums(iQ)
    rownames(iQ)<-colnames(iQ)
  }
  ## dependent model
  if(method=="fitDiscrete") dQ<-geiger:::.Qmatrix.from.gfit(fit.dQ)
  else {
    I<-fit.dQ$index.matrix
    I[I==0]<-NA
    dQ<-apply(I,2,function(i,x) x[i],x=fit.dQ$rates)
    dQ[is.na(dQ)]<-0
    diag(dQ)<--rowSums(dQ)
    rownames(dQ)<-colnames(dQ)
  }
  ## assemble object to return
  obj<-list(independent.Q=iQ,
            dependent.Q=dQ,
            independent.logL=logLik(fit.iQ),
            dependent.logL=logLik(fit.dQ),
            lik.ratio=2*(logLik(fit.dQ)-logLik(fit.iQ)),
            P=pchisq(2*(logLik(fit.dQ)-logLik(fit.iQ)),
                     df=length(levels(x))+length(levels(y)),
                     lower.tail=FALSE))
  class(obj)<-"fitPagel"
  obj
} # end fitPagel

print.fitPagel<-function(x,...){
  cat("\n  Pagel's binary character correlation test:\n")
  cat("\nIndepedent model rate matrix:\n")
  print(x$independent.Q)
  cat("\nDependent model rate matrix:\n")
  print(x$dependent.Q)
  cat("\nModel fit:\n")
  obj<-matrix(c(x$independent.logL,x$dependent.logL),2,1)
  rownames(obj)<-c("independent","dependent")
  colnames(obj)<-"log-likelihood"
  print(obj)
  cat("\nHypothesis test result:\n")
  cat(paste("  likelihood-ratio: ",signif(x$lik.ratio,7),"\n"))
  cat(paste("  p-value: ",signif(x$P,7),"\n"))
} # end print.fitPagel
